/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// This file was generated by "./hack/update-codegen.sh". Do not edit directly.
// directly.

package composite

import (
	"fmt"

	cloudprovider "github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud"
	"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud/filter"
	"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud/meta"
	computealpha "google.golang.org/api/compute/v0.alpha"
	computebeta "google.golang.org/api/compute/v0.beta"
	compute "google.golang.org/api/compute/v1"
	"google.golang.org/api/googleapi"
	"k8s.io/cloud-provider-gcp/providers/gce"
	compositemetrics "k8s.io/ingress-gce/pkg/composite/metrics"
	"k8s.io/klog/v2"
)

// AWSV4Signature is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type AWSV4Signature struct {
	// The access key used for s3 bucket authentication. Required for
	// updating or creating a backend that uses AWS v4 signature
	// authentication, but will not be returned as part of the configuration
	// when queried with a REST API GET request. @InputOnly
	AccessKey string `json:"accessKey,omitempty"`
	// The identifier of an access key used for s3 bucket authentication.
	AccessKeyId string `json:"accessKeyId,omitempty"`
	// The optional version identifier for the access key. You can use this
	// to keep track of different iterations of your access key.
	AccessKeyVersion string `json:"accessKeyVersion,omitempty"`
	// The name of the cloud region of your origin. This is a free-form
	// field with the name of the region your cloud uses to host your
	// origin. For example, "us-east-1" for AWS or "us-ashburn-1" for OCI.
	OriginRegion    string   `json:"originRegion,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// Address is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Address struct {
	// Version keeps track of the intended compute version for this Address.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// The static IP address represented by this resource.
	Address string `json:"address,omitempty"`
	// The type of address to reserve, either INTERNAL or EXTERNAL. If
	// unspecified, defaults to EXTERNAL.
	AddressType string `json:"addressType,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this field when you
	// create the resource.
	Description string `json:"description,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// The IP version that will be used by this address. Valid options are
	// IPV4 or IPV6.
	IpVersion string `json:"ipVersion,omitempty"`
	// The endpoint type of this address, which should be VM or NETLB. This
	// is used for deciding which type of endpoint this address can be used
	// after the external IPv6 address reservation.
	Ipv6EndpointType string `json:"ipv6EndpointType,omitempty"`
	// [Output Only] Type of the resource. Always compute#address for
	// addresses.
	Kind string `json:"kind,omitempty"`
	// A fingerprint for the labels being applied to this Address, which is
	// essentially a hash of the labels set used for optimistic locking. The
	// fingerprint is initially generated by Compute Engine and changes
	// after every request to modify or update labels. You must always
	// provide an up-to-date fingerprint hash in order to update or change
	// labels, otherwise the request will fail with error 412
	// conditionNotMet. To see the latest fingerprint, make a get() request
	// to retrieve an Address.
	LabelFingerprint string `json:"labelFingerprint,omitempty"`
	// Labels for this resource. These can only be added or modified by the
	// setLabels method. Each label key/value pair must comply with RFC1035.
	// Label values may be empty.
	Labels map[string]string `json:"labels,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first
	// character must be a lowercase letter, and all following characters
	// (except for the last character) must be a dash, lowercase letter, or
	// digit. The last character must be a lowercase letter or digit.
	Name string `json:"name,omitempty"`
	// The URL of the network in which to reserve the address. This field
	// can only be used with INTERNAL type with the VPC_PEERING purpose.
	Network string `json:"network,omitempty"`
	// This signifies the networking tier used for configuring this address
	// and can only take the following values: PREMIUM or STANDARD. Internal
	// IP addresses are always Premium Tier; global external IP addresses
	// are always Premium Tier; regional external IP addresses can be either
	// Standard or Premium Tier. If this field is not specified, it is
	// assumed to be PREMIUM.
	NetworkTier string `json:"networkTier,omitempty"`
	// The prefix length if the resource represents an IP range.
	PrefixLength int64 `json:"prefixLength,omitempty"`
	// The purpose of this resource, which can be one of the following
	// values: - GCE_ENDPOINT for addresses that are used by VM instances,
	// alias IP ranges, load balancers, and similar resources. -
	// DNS_RESOLVER for a DNS resolver address in a subnetwork for a Cloud
	// DNS inbound forwarder IP addresses (regional internal IP address in a
	// subnet of a VPC network) - VPC_PEERING for global internal IP
	// addresses used for private services access allocated ranges. -
	// NAT_AUTO for the regional external IP addresses used by Cloud NAT
	// when allocating addresses using automatic NAT IP address allocation.
	// - IPSEC_INTERCONNECT for addresses created from a private IP range
	// that are reserved for a VLAN attachment in an *HA VPN over Cloud
	// Interconnect* configuration. These addresses are regional resources.
	// - `SHARED_LOADBALANCER_VIP` for an internal IP address that is
	// assigned to multiple internal forwarding rules. -
	// `PRIVATE_SERVICE_CONNECT` for a private network address that is used
	// to configure Private Service Connect. Only global internal addresses
	// can use this purpose.
	Purpose string `json:"purpose,omitempty"`
	// [Output Only] The URL of the region where a regional address resides.
	// For regional addresses, you must specify the region as a path
	// parameter in the HTTP request URL. *This field is not applicable to
	// global addresses.*
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// [Output Only] The status of the address, which can be one of
	// RESERVING, RESERVED, or IN_USE. An address that is RESERVING is
	// currently in the process of being reserved. A RESERVED address is
	// currently reserved and available to use. An IN_USE address is
	// currently being used by another resource and is not available.
	Status string `json:"status,omitempty"`
	// The URL of the subnetwork in which to reserve the address. If an IP
	// address is specified, it must be within the subnetwork's IP range.
	// This field can only be used with INTERNAL type with a GCE_ENDPOINT or
	// DNS_RESOLVER purpose.
	Subnetwork string `json:"subnetwork,omitempty"`
	// [Output Only] The URLs of the resources that are using this address.
	Users                    []string `json:"users,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// AuthenticationPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type AuthenticationPolicy struct {
	// List of authentication methods that can be used for origin
	// authentication. Similar to peers, these will be evaluated in order
	// the first valid one will be used to set origin identity. If none of
	// these methods pass, the request will be rejected with authentication
	// failed error (401). Leave the list empty if origin authentication is
	// not required.
	Origins []*OriginAuthenticationMethod `json:"origins,omitempty"`
	// List of authentication methods that can be used for peer
	// authentication. They will be evaluated in order the first valid one
	// will be used to set peer identity. If none of these methods pass, the
	// request will be rejected with authentication failed error (401).
	// Leave the list empty if peer authentication is not required.
	Peers []*PeerAuthenticationMethod `json:"peers,omitempty"`
	// Define whether peer or origin identity should be used for principal.
	// Default value is USE_PEER. If peer (or origin) identity is not
	// available, either because peer/origin authentication is not defined,
	// or failed, principal will be left unset. In other words, binding rule
	// does not affect the decision to accept or reject request. This field
	// can be set to one of the following: USE_PEER: Principal will be set
	// to the identity from peer authentication. USE_ORIGIN: Principal will
	// be set to the identity from origin authentication.
	PrincipalBinding string `json:"principalBinding,omitempty"`
	// Configures the mechanism to obtain server-side security certificates
	// and identity information.
	ServerTlsContext *TlsContext `json:"serverTlsContext,omitempty"`
	ForceSendFields  []string    `json:"-"`
	NullFields       []string    `json:"-"`
}

// AuthorizationConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type AuthorizationConfig struct {
	// List of RbacPolicies.
	Policies        []*RbacPolicy `json:"policies,omitempty"`
	ForceSendFields []string      `json:"-"`
	NullFields      []string      `json:"-"`
}

// Backend is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Backend struct {
	// Specifies how to determine whether the backend of a load balancer can
	// handle additional traffic or is fully loaded. For usage guidelines,
	// see Connection balancing mode. Backends must use compatible balancing
	// modes. For more information, see Supported balancing modes and target
	// capacity settings and Restrictions and guidance for instance groups.
	// Note: Currently, if you use the API to configure incompatible
	// balancing modes, the configuration might be accepted even though it
	// has no impact and is ignored. Specifically, Backend.maxUtilization is
	// ignored when Backend.balancingMode is RATE. In the future, this
	// incompatible combination will be rejected.
	BalancingMode string `json:"balancingMode,omitempty"`
	// A multiplier applied to the backend's target capacity of its
	// balancing mode. The default value is 1, which means the group serves
	// up to 100% of its configured capacity (depending on balancingMode). A
	// setting of 0 means the group is completely drained, offering 0% of
	// its available capacity. The valid ranges are 0.0 and [0.1,1.0]. You
	// cannot configure a setting larger than 0 and smaller than 0.1. You
	// cannot configure a setting of 0 when there is only one backend
	// attached to the backend service. Not available with backends that
	// don't support using a balancingMode. This includes backends such as
	// global internet NEGs, regional serverless NEGs, and PSC NEGs.
	CapacityScaler float64 `json:"capacityScaler,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// This field designates whether this is a failover backend. More than
	// one failover backend can be configured for a given BackendService.
	Failover bool `json:"failover,omitempty"`
	// The fully-qualified URL of an instance group or network endpoint
	// group (NEG) resource. To determine what types of backends a load
	// balancer supports, see the [Backend services
	// overview](https://cloud.google.com/load-balancing/docs/backend-service
	// #backends). You must use the *fully-qualified* URL (starting with
	// https://www.googleapis.com/) to specify the instance group or NEG.
	// Partial URLs are not supported.
	Group string `json:"group,omitempty"`
	// Defines a target maximum number of simultaneous connections. For
	// usage guidelines, see Connection balancing mode and Utilization
	// balancing mode. Not available if the backend's balancingMode is RATE.
	MaxConnections int64 `json:"maxConnections,omitempty"`
	// Defines a target maximum number of simultaneous connections. For
	// usage guidelines, see Connection balancing mode and Utilization
	// balancing mode. Not available if the backend's balancingMode is RATE.
	MaxConnectionsPerEndpoint int64 `json:"maxConnectionsPerEndpoint,omitempty"`
	// Defines a target maximum number of simultaneous connections. For
	// usage guidelines, see Connection balancing mode and Utilization
	// balancing mode. Not available if the backend's balancingMode is RATE.
	MaxConnectionsPerInstance int64 `json:"maxConnectionsPerInstance,omitempty"`
	// Defines a maximum number of HTTP requests per second (RPS). For usage
	// guidelines, see Rate balancing mode and Utilization balancing mode.
	// Not available if the backend's balancingMode is CONNECTION.
	MaxRate int64 `json:"maxRate,omitempty"`
	// Defines a maximum target for requests per second (RPS). For usage
	// guidelines, see Rate balancing mode and Utilization balancing mode.
	// Not available if the backend's balancingMode is CONNECTION.
	MaxRatePerEndpoint float64 `json:"maxRatePerEndpoint,omitempty"`
	// Defines a maximum target for requests per second (RPS). For usage
	// guidelines, see Rate balancing mode and Utilization balancing mode.
	// Not available if the backend's balancingMode is CONNECTION.
	MaxRatePerInstance float64 `json:"maxRatePerInstance,omitempty"`
	// Optional parameter to define a target capacity for the UTILIZATION
	// balancing mode. The valid range is [0.0, 1.0]. For usage guidelines,
	// see Utilization balancing mode.
	MaxUtilization float64 `json:"maxUtilization,omitempty"`
	// This field indicates whether this backend should be fully utilized
	// before sending traffic to backends with default preference. The
	// possible values are: - PREFERRED: Backends with this preference level
	// will be filled up to their capacity limits first, based on RTT. -
	// DEFAULT: If preferred backends don't have enough capacity, backends
	// in this layer would be used and traffic would be assigned based on
	// the load balancing algorithm you use. This is the default
	Preference      string   `json:"preference,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendService is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendService struct {
	// Version keeps track of the intended compute version for this BackendService.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// Lifetime of cookies in seconds. This setting is applicable to
	// Application Load Balancers and Traffic Director and requires
	// GENERATED_COOKIE or HTTP_COOKIE session affinity. If set to 0, the
	// cookie is non-persistent and lasts only until the end of the browser
	// session (or equivalent). The maximum allowed value is two weeks
	// (1,209,600). Not supported when the backend service is referenced by
	// a URL map that is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	AffinityCookieTtlSec int64 `json:"affinityCookieTtlSec,omitempty"`
	// The list of backends that serve this BackendService.
	Backends []*Backend `json:"backends,omitempty"`
	// Cloud CDN configuration for this BackendService. Only available for
	// specified load balancer types.
	CdnPolicy       *BackendServiceCdnPolicy `json:"cdnPolicy,omitempty"`
	CircuitBreakers *CircuitBreakers         `json:"circuitBreakers,omitempty"`
	// Compress text responses using Brotli or gzip compression, based on
	// the client's Accept-Encoding header.
	CompressionMode    string              `json:"compressionMode,omitempty"`
	ConnectionDraining *ConnectionDraining `json:"connectionDraining,omitempty"`
	// Connection Tracking configuration for this BackendService. Connection
	// tracking policy settings are only available for external passthrough
	// Network Load Balancers and internal passthrough Network Load
	// Balancers.
	ConnectionTrackingPolicy *BackendServiceConnectionTrackingPolicy `json:"connectionTrackingPolicy,omitempty"`
	// Consistent Hash-based load balancing can be used to provide soft
	// session affinity based on HTTP headers, cookies or other properties.
	// This load balancing policy is applicable only for HTTP connections.
	// The affinity to a particular destination host will be lost when one
	// or more hosts are added/removed from the destination service. This
	// field specifies parameters that control consistent hashing. This
	// field is only applicable when localityLbPolicy is set to MAGLEV or
	// RING_HASH. This field is applicable to either: - A regional backend
	// service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
	// load_balancing_scheme set to INTERNAL_MANAGED. - A global backend
	// service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
	ConsistentHash *ConsistentHashLoadBalancerSettings `json:"consistentHash,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// Headers that the load balancer adds to proxied requests. See
	// [Creating custom
	// headers](https://cloud.google.com/load-balancing/docs/custom-headers).
	CustomRequestHeaders []string `json:"customRequestHeaders,omitempty"`
	// Headers that the load balancer adds to proxied responses. See
	// [Creating custom
	// headers](https://cloud.google.com/load-balancing/docs/custom-headers).
	CustomResponseHeaders []string `json:"customResponseHeaders,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// [Output Only] The resource URL for the edge security policy
	// associated with this backend service.
	EdgeSecurityPolicy string `json:"edgeSecurityPolicy,omitempty"`
	// If true, enables Cloud CDN for the backend service of a global
	// external Application Load Balancer.
	EnableCDN bool `json:"enableCDN,omitempty"`
	// Specifies the canary migration state. Possible values are PREPARE,
	// TEST_BY_PERCENTAGE, and TEST_ALL_TRAFFIC. To begin the migration from
	// EXTERNAL to EXTERNAL_MANAGED, the state must be changed to PREPARE.
	// The state must be changed to TEST_ALL_TRAFFIC before the
	// loadBalancingScheme can be changed to EXTERNAL_MANAGED. Optionally,
	// the TEST_BY_PERCENTAGE state can be used to migrate traffic by
	// percentage using externalManagedMigrationTestingPercentage. Rolling
	// back a migration requires the states to be set in reverse order. So
	// changing the scheme from EXTERNAL_MANAGED to EXTERNAL requires the
	// state to be set to TEST_ALL_TRAFFIC at the same time. Optionally, the
	// TEST_BY_PERCENTAGE state can be used to migrate some traffic back to
	// EXTERNAL or PREPARE can be used to migrate all traffic back to
	// EXTERNAL.
	ExternalManagedMigrationState string `json:"externalManagedMigrationState,omitempty"`
	// Determines the fraction of requests that should be processed by the
	// Global external Application Load Balancer. The value of this field
	// must be in the range [0, 100]. Session affinity options will slightly
	// affect this routing behavior, for more details, see: Session
	// Affinity. This value can only be set if the loadBalancingScheme in
	// the BackendService is set to EXTERNAL (when using the classic
	// Application Load Balancer) and the migration state is
	// TEST_BY_PERCENTAGE.
	ExternalManagedMigrationTestingPercentage float64 `json:"externalManagedMigrationTestingPercentage,omitempty"`
	// Requires at least one backend instance group to be defined as a
	// backup (failover) backend. For load balancers that have configurable
	// failover: [Internal passthrough Network Load
	// Balancers](https://cloud.google.com/load-balancing/docs/internal/failo
	// ver-overview) and [external passthrough Network Load
	// Balancers](https://cloud.google.com/load-balancing/docs/network/networ
	// klb-failover-overview).
	FailoverPolicy *BackendServiceFailoverPolicy `json:"failoverPolicy,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a BackendService. An up-to-date fingerprint
	// must be provided in order to update the BackendService, otherwise the
	// request will fail with error 412 conditionNotMet. To see the latest
	// fingerprint, make a get() request to retrieve a BackendService.
	Fingerprint string `json:"fingerprint,omitempty"`
	// Configuring haPolicy is not supported.
	HaPolicy *BackendServiceHAPolicy `json:"haPolicy,omitempty"`
	// The list of URLs to the healthChecks, httpHealthChecks (legacy), or
	// httpsHealthChecks (legacy) resource for health checking this backend
	// service. Not all backend services support legacy health checks. See
	// Load balancer guide. Currently, at most one health check can be
	// specified for each backend service. Backend services with instance
	// group or zonal NEG backends must have a health check. Backend
	// services with internet or serverless NEG backends must not have a
	// health check.
	HealthChecks []string `json:"healthChecks,omitempty"`
	// The configurations for Identity-Aware Proxy on this resource. Not
	// available for internal passthrough Network Load Balancers and
	// external passthrough Network Load Balancers.
	Iap *BackendServiceIAP `json:"iap,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// Specifies a preference for traffic sent from the proxy to the backend
	// (or from the client to the backend for proxyless gRPC). The possible
	// values are: - IPV4_ONLY: Only send IPv4 traffic to the backends of
	// the backend service (Instance Group, Managed Instance Group, Network
	// Endpoint Group), regardless of traffic from the client to the proxy.
	// Only IPv4 health checks are used to check the health of the backends.
	// This is the default setting. - PREFER_IPV6: Prioritize the connection
	// to the endpoint's IPv6 address over its IPv4 address (provided there
	// is a healthy IPv6 address). - IPV6_ONLY: Only send IPv6 traffic to
	// the backends of the backend service (Instance Group, Managed Instance
	// Group, Network Endpoint Group), regardless of traffic from the client
	// to the proxy. Only IPv6 health checks are used to check the health of
	// the backends. This field is applicable to either: - Advanced global
	// external Application Load Balancer (load balancing scheme
	// EXTERNAL_MANAGED), - Regional external Application Load Balancer, -
	// Internal proxy Network Load Balancer (load balancing scheme
	// INTERNAL_MANAGED), - Regional internal Application Load Balancer
	// (load balancing scheme INTERNAL_MANAGED), - Traffic Director with
	// Envoy proxies and proxyless gRPC (load balancing scheme
	// INTERNAL_SELF_MANAGED).
	IpAddressSelectionPolicy string `json:"ipAddressSelectionPolicy,omitempty"`
	// [Output Only] Type of resource. Always compute#backendService for
	// backend services.
	Kind string `json:"kind,omitempty"`
	// Specifies the load balancer type. A backend service created for one
	// type of load balancer cannot be used with another. For more
	// information, refer to Choosing a load balancer.
	LoadBalancingScheme string `json:"loadBalancingScheme,omitempty"`
	// A list of locality load-balancing policies to be used in order of
	// preference. When you use localityLbPolicies, you must set at least
	// one value for either the localityLbPolicies[].policy or the
	// localityLbPolicies[].customPolicy field. localityLbPolicies overrides
	// any value set in the localityLbPolicy field. For an example of how to
	// use this field, see Define a list of preferred policies. Caution:
	// This field and its children are intended for use in a service mesh
	// that includes gRPC clients only. Envoy proxies can't use backend
	// services that have this configuration.
	LocalityLbPolicies []*BackendServiceLocalityLoadBalancingPolicyConfig `json:"localityLbPolicies,omitempty"`
	// The load balancing algorithm used within the scope of the locality.
	// The possible values are: - ROUND_ROBIN: This is a simple policy in
	// which each healthy backend is selected in round robin order. This is
	// the default. - LEAST_REQUEST: An O(1) algorithm which selects two
	// random healthy hosts and picks the host which has fewer active
	// requests. - RING_HASH: The ring/modulo hash load balancer implements
	// consistent hashing to backends. The algorithm has the property that
	// the addition/removal of a host from a set of N hosts only affects 1/N
	// of the requests. - RANDOM: The load balancer selects a random healthy
	// host. - ORIGINAL_DESTINATION: Backend host is selected based on the
	// client connection metadata, i.e., connections are opened to the same
	// address as the destination address of the incoming connection before
	// the connection was redirected to the load balancer. - MAGLEV: used as
	// a drop in replacement for the ring hash load balancer. Maglev is not
	// as stable as ring hash but has faster table lookup build times and
	// host selection times. For more information about Maglev, see
	// https://ai.google/research/pubs/pub44824 This field is applicable to
	// either: - A regional backend service with the service_protocol set to
	// HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to
	// INTERNAL_MANAGED. - A global backend service with the
	// load_balancing_scheme set to INTERNAL_SELF_MANAGED, INTERNAL_MANAGED,
	// or EXTERNAL_MANAGED. If sessionAffinity is not NONE, and this field
	// is not set to MAGLEV or RING_HASH, session affinity settings will not
	// take effect. Only ROUND_ROBIN and RING_HASH are supported when the
	// backend service is referenced by a URL map that is bound to target
	// gRPC proxy that has validateForProxyless field set to true.
	LocalityLbPolicy string `json:"localityLbPolicy,omitempty"`
	// This field denotes the logging options for the load balancer traffic
	// served by this backend service. If logging is enabled, logs will be
	// exported to Stackdriver.
	LogConfig *BackendServiceLogConfig `json:"logConfig,omitempty"`
	// Specifies the default maximum duration (timeout) for streams to this
	// service. Duration is computed from the beginning of the stream until
	// the response has been completely processed, including all retries. A
	// stream that does not complete in this duration is closed. If not
	// specified, there will be no timeout limit, i.e. the maximum duration
	// is infinite. This value can be overridden in the PathMatcher
	// configuration of the UrlMap that references this backend service.
	// This field is only allowed when the loadBalancingScheme of the
	// backend service is INTERNAL_SELF_MANAGED.
	MaxStreamDuration *Duration `json:"maxStreamDuration,omitempty"`
	// Deployment metadata associated with the resource to be set by a GKE
	// hub controller and read by the backend RCTH
	Metadatas map[string]string `json:"metadatas,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// The URL of the network to which this backend service belongs. This
	// field can only be specified when the load balancing scheme is set to
	// INTERNAL.
	Network string `json:"network,omitempty"`
	// Configures traffic steering properties of internal passthrough
	// Network Load Balancers.
	NetworkPassThroughLbTrafficPolicy *BackendServiceNetworkPassThroughLbTrafficPolicy `json:"networkPassThroughLbTrafficPolicy,omitempty"`
	// Settings controlling the ejection of unhealthy backend endpoints from
	// the load balancing pool of each individual proxy instance that
	// processes the traffic for the given backend service. If not set, this
	// feature is considered disabled. Results of the outlier detection
	// algorithm (ejection of endpoints from the load balancing pool and
	// returning them back to the pool) are executed independently by each
	// proxy instance of the load balancer. In most cases, more than one
	// proxy instance handles the traffic received by a backend service.
	// Thus, it is possible that an unhealthy endpoint is detected and
	// ejected by only some of the proxies, and while this happens, other
	// proxies may continue to send requests to the same unhealthy endpoint
	// until they detect and eject the unhealthy endpoint. Applicable
	// backend endpoints can be: - VM instances in an Instance Group -
	// Endpoints in a Zonal NEG (GCE_VM_IP, GCE_VM_IP_PORT) - Endpoints in a
	// Hybrid Connectivity NEG (NON_GCP_PRIVATE_IP_PORT) - Serverless NEGs,
	// that resolve to Cloud Run, App Engine, or Cloud Functions Services -
	// Private Service Connect NEGs, that resolve to Google-managed regional
	// API endpoints or managed services published using Private Service
	// Connect Applicable backend service types can be: - A global backend
	// service with the loadBalancingScheme set to INTERNAL_SELF_MANAGED or
	// EXTERNAL_MANAGED. - A regional backend service with the
	// serviceProtocol set to HTTP, HTTPS, or HTTP2, and loadBalancingScheme
	// set to INTERNAL_MANAGED or EXTERNAL_MANAGED. Not supported for
	// Serverless NEGs. Not supported when the backend service is referenced
	// by a URL map that is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	OutlierDetection *OutlierDetection `json:"outlierDetection,omitempty"`
	// Deprecated in favor of portName. The TCP port to connect on the
	// backend. The default value is 80. For internal passthrough Network
	// Load Balancers and external passthrough Network Load Balancers, omit
	// port.
	Port int64 `json:"port,omitempty"`
	// A named port on a backend instance group representing the port for
	// communication to the backend VMs in that group. The named port must
	// be [defined on each backend instance
	// group](https://cloud.google.com/load-balancing/docs/backend-service#na
	// med_ports). This parameter has no meaning if the backends are NEGs.
	// For internal passthrough Network Load Balancers and external
	// passthrough Network Load Balancers, omit port_name.
	PortName string `json:"portName,omitempty"`
	// The protocol this BackendService uses to communicate with backends.
	// Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC.
	// depending on the chosen load balancer or Traffic Director
	// configuration. Refer to the documentation for the load balancers or
	// for Traffic Director for more information. Must be set to GRPC when
	// the backend service is referenced by a URL map that is bound to
	// target gRPC proxy.
	Protocol string `json:"protocol,omitempty"`
	// [Output Only] URL of the region where the regional backend service
	// resides. This field is not applicable to global backend services. You
	// must specify this field as part of the HTTP request URL. It is not
	// settable as a field in the request body.
	Region string `json:"region,omitempty"`
	// [Output Only] The resource URL for the security policy associated
	// with this backend service.
	SecurityPolicy string `json:"securityPolicy,omitempty"`
	// This field specifies the security settings that apply to this backend
	// service. This field is applicable to a global backend service with
	// the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
	SecuritySettings *SecuritySettings `json:"securitySettings,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// URLs of networkservices.ServiceBinding resources. Can only be set if
	// load balancing scheme is INTERNAL_SELF_MANAGED. If set, lists of
	// backends and health checks must be both empty.
	ServiceBindings []string `json:"serviceBindings,omitempty"`
	// URL to networkservices.ServiceLbPolicy resource. Can only be set if
	// load balancing scheme is EXTERNAL, EXTERNAL_MANAGED, INTERNAL_MANAGED
	// or INTERNAL_SELF_MANAGED and the scope is global.
	ServiceLbPolicy string `json:"serviceLbPolicy,omitempty"`
	// Type of session affinity to use. The default is NONE. Only NONE and
	// HEADER_FIELD are supported when the backend service is referenced by
	// a URL map that is bound to target gRPC proxy that has
	// validateForProxyless field set to true. For more details, see:
	// [Session
	// Affinity](https://cloud.google.com/load-balancing/docs/backend-service
	// #session_affinity).
	SessionAffinity string `json:"sessionAffinity,omitempty"`
	// Describes the HTTP cookie used for stateful session affinity. This
	// field is applicable and required if the sessionAffinity is set to
	// STRONG_COOKIE_AFFINITY.
	StrongSessionAffinityCookie *BackendServiceHttpCookie `json:"strongSessionAffinityCookie,omitempty"`
	Subsetting                  *Subsetting               `json:"subsetting,omitempty"`
	// The backend service timeout has a different meaning depending on the
	// type of load balancer. For more information see, Backend service
	// settings. The default is 30 seconds. The full range of timeout values
	// allowed goes from 1 through 2,147,483,647 seconds. This value can be
	// overridden in the PathMatcher configuration of the UrlMap that
	// references this backend service. Not supported when the backend
	// service is referenced by a URL map that is bound to target gRPC proxy
	// that has validateForProxyless field set to true. Instead, use
	// maxStreamDuration.
	TimeoutSec int64                   `json:"timeoutSec,omitempty"`
	UsedBy     []*BackendServiceUsedBy `json:"usedBy,omitempty"`
	// The network scope of the backends that can be added to the backend
	// service. This field can be either GLOBAL_VPC_NETWORK or
	// REGIONAL_VPC_NETWORK. A backend service with the VPC scope set to
	// GLOBAL_VPC_NETWORK is only allowed to have backends in global VPC
	// networks. When the VPC scope is set to REGIONAL_VPC_NETWORK the
	// backend service is only allowed to have backends in regional networks
	// in the same scope as the backend service. Note: if not specified then
	// GLOBAL_VPC_NETWORK will be used.
	VpcNetworkScope          string `json:"vpcNetworkScope,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// BackendServiceCdnPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceCdnPolicy struct {
	// Bypass the cache when the specified request headers are matched -
	// e.g. Pragma or Authorization headers. Up to 5 headers can be
	// specified. The cache is bypassed for all cdnPolicy.cacheMode
	// settings.
	BypassCacheOnRequestHeaders []*BackendServiceCdnPolicyBypassCacheOnRequestHeader `json:"bypassCacheOnRequestHeaders,omitempty"`
	// The CacheKeyPolicy for this CdnPolicy.
	CacheKeyPolicy *CacheKeyPolicy `json:"cacheKeyPolicy,omitempty"`
	// Specifies the cache setting for all responses from this backend. The
	// possible values are: USE_ORIGIN_HEADERS Requires the origin to set
	// valid caching headers to cache content. Responses without these
	// headers will not be cached at Google's edge, and will require a full
	// trip to the origin on every request, potentially impacting
	// performance and increasing load on the origin server. FORCE_CACHE_ALL
	// Cache all content, ignoring any "private", "no-store" or "no-cache"
	// directives in Cache-Control response headers. Warning: this may
	// result in Cloud CDN caching private, per-user (user identifiable)
	// content. CACHE_ALL_STATIC Automatically cache static content,
	// including common image formats, media (video and audio), and web
	// assets (JavaScript and CSS). Requests and responses that are marked
	// as uncacheable, as well as dynamic content (including HTML), will not
	// be cached.
	CacheMode string `json:"cacheMode,omitempty"`
	// Specifies a separate client (e.g. browser client) maximum TTL. This
	// is used to clamp the max-age (or Expires) value sent to the client.
	// With FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is
	// used for the response max-age directive, along with a "public"
	// directive. For cacheable content in CACHE_ALL_STATIC mode, client_ttl
	// clamps the max-age from the origin (if specified), or else sets the
	// response max-age directive to the lesser of the client_ttl and
	// default_ttl, and also ensures a "public" cache-control directive is
	// present. If a client TTL is not specified, a default value (1 hour)
	// will be used. The maximum allowed value is 31,622,400s (1 year).
	ClientTtl int64 `json:"clientTtl,omitempty"`
	// Specifies the default TTL for cached content served by this origin
	// for responses that do not have an existing valid TTL (max-age or
	// s-max-age). Setting a TTL of "0" means "always revalidate". The value
	// of defaultTTL cannot be set to a value greater than that of maxTTL,
	// but can be equal. When the cacheMode is set to FORCE_CACHE_ALL, the
	// defaultTTL will overwrite the TTL set in all responses. The maximum
	// allowed value is 31,622,400s (1 year), noting that infrequently
	// accessed objects may be evicted from the cache before the defined
	// TTL.
	DefaultTtl int64 `json:"defaultTtl,omitempty"`
	// Specifies the maximum allowed TTL for cached content served by this
	// origin. Cache directives that attempt to set a max-age or s-maxage
	// higher than this, or an Expires header more than maxTTL seconds in
	// the future will be capped at the value of maxTTL, as if it were the
	// value of an s-maxage Cache-Control directive. Headers sent to the
	// client will not be modified. Setting a TTL of "0" means "always
	// revalidate". The maximum allowed value is 31,622,400s (1 year),
	// noting that infrequently accessed objects may be evicted from the
	// cache before the defined TTL.
	MaxTtl int64 `json:"maxTtl,omitempty"`
	// Negative caching allows per-status code TTLs to be set, in order to
	// apply fine-grained caching for common errors or redirects. This can
	// reduce the load on your origin and improve end-user experience by
	// reducing response latency. When the cache mode is set to
	// CACHE_ALL_STATIC or USE_ORIGIN_HEADERS, negative caching applies to
	// responses with the specified response code that lack any
	// Cache-Control, Expires, or Pragma: no-cache directives. When the
	// cache mode is set to FORCE_CACHE_ALL, negative caching applies to all
	// responses with the specified response code, and override any caching
	// headers. By default, Cloud CDN will apply the following default TTLs
	// to these status codes: HTTP 300 (Multiple Choice), 301, 308
	// (Permanent Redirects): 10m HTTP 404 (Not Found), 410 (Gone), 451
	// (Unavailable For Legal Reasons): 120s HTTP 405 (Method Not Found),
	// 421 (Misdirected Request), 501 (Not Implemented): 60s. These defaults
	// can be overridden in negative_caching_policy.
	NegativeCaching bool `json:"negativeCaching,omitempty"`
	// Sets a cache TTL for the specified HTTP status code. negative_caching
	// must be enabled to configure negative_caching_policy. Omitting the
	// policy and leaving negative_caching enabled will use Cloud CDN's
	// default cache TTLs. Note that when specifying an explicit
	// negative_caching_policy, you should take care to specify a cache TTL
	// for all response codes that you wish to cache. Cloud CDN will not
	// apply any default negative caching when a policy exists.
	NegativeCachingPolicy []*BackendServiceCdnPolicyNegativeCachingPolicy `json:"negativeCachingPolicy,omitempty"`
	// If true then Cloud CDN will combine multiple concurrent cache fill
	// requests into a small number of requests to the origin.
	RequestCoalescing bool `json:"requestCoalescing,omitempty"`
	// Serve existing content from the cache (if available) when
	// revalidating content with the origin, or when an error is encountered
	// when refreshing the cache. This setting defines the default
	// "max-stale" duration for any cached responses that do not specify a
	// max-stale directive. Stale responses that exceed the TTL configured
	// here will not be served. The default limit (max-stale) is 86400s (1
	// day), which will allow stale content to be served up to this limit
	// beyond the max-age (or s-max-age) of a cached response. The maximum
	// allowed value is 604800 (1 week). Set this to zero (0) to disable
	// serve-while-stale.
	ServeWhileStale int64 `json:"serveWhileStale,omitempty"`
	// Maximum number of seconds the response to a signed URL request will
	// be considered fresh. After this time period, the response will be
	// revalidated before being served. Defaults to 1hr (3600s). When
	// serving responses to signed URL requests, Cloud CDN will internally
	// behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in responses
	// will not be altered.
	SignedUrlCacheMaxAgeSec int64 `json:"signedUrlCacheMaxAgeSec,omitempty,string"`
	// [Output Only] Names of the keys for signing request URLs.
	SignedUrlKeyNames []string `json:"signedUrlKeyNames,omitempty"`
	ForceSendFields   []string `json:"-"`
	NullFields        []string `json:"-"`
}

// BackendServiceCdnPolicyBypassCacheOnRequestHeader is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceCdnPolicyBypassCacheOnRequestHeader struct {
	// The header field name to match on when bypassing cache. Values are
	// case-insensitive.
	HeaderName      string   `json:"headerName,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceCdnPolicyNegativeCachingPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceCdnPolicyNegativeCachingPolicy struct {
	// The HTTP status code to define a TTL against. Only HTTP status codes
	// 300, 301, 302, 307, 308, 404, 405, 410, 421, 451 and 501 are can be
	// specified as values, and you cannot specify a status code more than
	// once.
	Code int64 `json:"code,omitempty"`
	// The TTL (in seconds) for which to cache responses with the
	// corresponding status code. The maximum allowed value is 1800s (30
	// minutes), noting that infrequently accessed objects may be evicted
	// from the cache before the defined TTL.
	Ttl             int64    `json:"ttl,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceConnectionTrackingPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceConnectionTrackingPolicy struct {
	// Specifies connection persistence when backends are unhealthy. The
	// default value is DEFAULT_FOR_PROTOCOL. If set to
	// DEFAULT_FOR_PROTOCOL, the existing connections persist on unhealthy
	// backends only for connection-oriented protocols (TCP and SCTP) and
	// only if the Tracking Mode is PER_CONNECTION (default tracking mode)
	// or the Session Affinity is configured for 5-tuple. They do not
	// persist for UDP. If set to NEVER_PERSIST, after a backend becomes
	// unhealthy, the existing connections on the unhealthy backend are
	// never persisted on the unhealthy backend. They are always diverted to
	// newly selected healthy backends (unless all backends are unhealthy).
	// If set to ALWAYS_PERSIST, existing connections always persist on
	// unhealthy backends regardless of protocol and session affinity. It is
	// generally not recommended to use this mode overriding the default.
	// For more details, see [Connection Persistence for Network Load
	// Balancing](https://cloud.google.com/load-balancing/docs/network/networ
	// klb-backend-service#connection-persistence) and [Connection
	// Persistence for Internal TCP/UDP Load
	// Balancing](https://cloud.google.com/load-balancing/docs/internal#conne
	// ction-persistence).
	ConnectionPersistenceOnUnhealthyBackends string `json:"connectionPersistenceOnUnhealthyBackends,omitempty"`
	// Enable Strong Session Affinity for external passthrough Network Load
	// Balancers. This option is not available publicly.
	EnableStrongAffinity bool `json:"enableStrongAffinity,omitempty"`
	// Specifies how long to keep a Connection Tracking entry while there is
	// no matching traffic (in seconds). For internal passthrough Network
	// Load Balancers: - The minimum (default) is 10 minutes and the maximum
	// is 16 hours. - It can be set only if Connection Tracking is less than
	// 5-tuple (i.e. Session Affinity is CLIENT_IP_NO_DESTINATION, CLIENT_IP
	// or CLIENT_IP_PROTO, and Tracking Mode is PER_SESSION). For external
	// passthrough Network Load Balancers the default is 60 seconds. This
	// option is not available publicly.
	IdleTimeoutSec int64 `json:"idleTimeoutSec,omitempty"`
	// Specifies the key used for connection tracking. There are two
	// options: - PER_CONNECTION: This is the default mode. The Connection
	// Tracking is performed as per the Connection Key (default Hash Method)
	// for the specific protocol. - PER_SESSION: The Connection Tracking is
	// performed as per the configured Session Affinity. It matches the
	// configured Session Affinity. For more details, see [Tracking Mode for
	// Network Load
	// Balancing](https://cloud.google.com/load-balancing/docs/network/networ
	// klb-backend-service#tracking-mode) and [Tracking Mode for Internal
	// TCP/UDP Load
	// Balancing](https://cloud.google.com/load-balancing/docs/internal#track
	// ing-mode).
	TrackingMode    string   `json:"trackingMode,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceFailoverPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceFailoverPolicy struct {
	// This can be set to true only if the protocol is TCP. The default is
	// false.
	DisableConnectionDrainOnFailover bool `json:"disableConnectionDrainOnFailover,omitempty"`
	// If set to true, connections to the load balancer are dropped when all
	// primary and all backup backend VMs are unhealthy.If set to false,
	// connections are distributed among all primary VMs when all primary
	// and all backup backend VMs are unhealthy. For load balancers that
	// have configurable failover: [Internal passthrough Network Load
	// Balancers](https://cloud.google.com/load-balancing/docs/internal/failo
	// ver-overview) and [external passthrough Network Load
	// Balancers](https://cloud.google.com/load-balancing/docs/network/networ
	// klb-failover-overview). The default is false.
	DropTrafficIfUnhealthy bool `json:"dropTrafficIfUnhealthy,omitempty"`
	// The value of the field must be in the range [0, 1]. If the value is
	// 0, the load balancer performs a failover when the number of healthy
	// primary VMs equals zero. For all other values, the load balancer
	// performs a failover when the total number of healthy primary VMs is
	// less than this ratio. For load balancers that have configurable
	// failover: [Internal TCP/UDP Load
	// Balancing](https://cloud.google.com/load-balancing/docs/internal/failo
	// ver-overview) and [external TCP/UDP Load
	// Balancing](https://cloud.google.com/load-balancing/docs/network/networ
	// klb-failover-overview).
	FailoverRatio   float64  `json:"failoverRatio,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceHAPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceHAPolicy struct {
	// Enabling fastIPMove is not supported.
	FastIPMove string `json:"fastIPMove,omitempty"`
	// Setting a leader is not supported.
	Leader          *BackendServiceHAPolicyLeader `json:"leader,omitempty"`
	ForceSendFields []string                      `json:"-"`
	NullFields      []string                      `json:"-"`
}

// BackendServiceHAPolicyLeader is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceHAPolicyLeader struct {
	// Setting backendGroup is not supported.
	BackendGroup string `json:"backendGroup,omitempty"`
	// Setting a network endpoint as leader is not supported.
	NetworkEndpoint *BackendServiceHAPolicyLeaderNetworkEndpoint `json:"networkEndpoint,omitempty"`
	ForceSendFields []string                                     `json:"-"`
	NullFields      []string                                     `json:"-"`
}

// BackendServiceHAPolicyLeaderNetworkEndpoint is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceHAPolicyLeaderNetworkEndpoint struct {
	// Specifying the instance name of a leader is not supported.
	Instance        string   `json:"instance,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceHttpCookie is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceHttpCookie struct {
	// Name of the cookie.
	Name string `json:"name,omitempty"`
	// Path to set for the cookie.
	Path string `json:"path,omitempty"`
	// Lifetime of the cookie.
	Ttl             *Duration `json:"ttl,omitempty"`
	ForceSendFields []string  `json:"-"`
	NullFields      []string  `json:"-"`
}

// BackendServiceIAP is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceIAP struct {
	// Whether the serving infrastructure will authenticate and authorize
	// all incoming requests.
	Enabled bool `json:"enabled,omitempty"`
	// OAuth2 client ID to use for the authentication flow.
	Oauth2ClientId string `json:"oauth2ClientId,omitempty"`
	// [Input Only] OAuth client info required to generate client id to be
	// used for IAP.
	Oauth2ClientInfo *BackendServiceIAPOAuth2ClientInfo `json:"oauth2ClientInfo,omitempty"`
	// OAuth2 client secret to use for the authentication flow. For security
	// reasons, this value cannot be retrieved via the API. Instead, the
	// SHA-256 hash of the value is returned in the oauth2ClientSecretSha256
	// field. @InputOnly
	Oauth2ClientSecret string `json:"oauth2ClientSecret,omitempty"`
	// [Output Only] SHA256 hash value for the field oauth2_client_secret
	// above.
	Oauth2ClientSecretSha256 string   `json:"oauth2ClientSecretSha256,omitempty"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// BackendServiceIAPOAuth2ClientInfo is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceIAPOAuth2ClientInfo struct {
	// Application name to be used in OAuth consent screen.
	ApplicationName string `json:"applicationName,omitempty"`
	// Name of the client to be generated. Optional - If not provided, the
	// name will be autogenerated by the backend.
	ClientName string `json:"clientName,omitempty"`
	// Developer's information to be used in OAuth consent screen.
	DeveloperEmailAddress string   `json:"developerEmailAddress,omitempty"`
	ForceSendFields       []string `json:"-"`
	NullFields            []string `json:"-"`
}

// BackendServiceLocalityLoadBalancingPolicyConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceLocalityLoadBalancingPolicyConfig struct {
	CustomPolicy    *BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy `json:"customPolicy,omitempty"`
	Policy          *BackendServiceLocalityLoadBalancingPolicyConfigPolicy       `json:"policy,omitempty"`
	ForceSendFields []string                                                     `json:"-"`
	NullFields      []string                                                     `json:"-"`
}

// BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy struct {
	// An optional, arbitrary JSON object with configuration data,
	// understood by a locally installed custom policy implementation.
	Data string `json:"data,omitempty"`
	// Identifies the custom policy. The value should match the name of a
	// custom implementation registered on the gRPC clients. It should
	// follow protocol buffer message naming conventions and include the
	// full path (for example, myorg.CustomLbPolicy). The maximum length is
	// 256 characters. Do not specify the same custom policy more than once
	// for a backend. If you do, the configuration is rejected. For an
	// example of how to use this field, see Use a custom policy.
	Name            string   `json:"name,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceLocalityLoadBalancingPolicyConfigPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceLocalityLoadBalancingPolicyConfigPolicy struct {
	// The name of a locality load-balancing policy. Valid values include
	// ROUND_ROBIN and, for Java clients, LEAST_REQUEST. For information
	// about these values, see the description of localityLbPolicy. Do not
	// specify the same policy more than once for a backend. If you do, the
	// configuration is rejected.
	Name            string   `json:"name,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceLogConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceLogConfig struct {
	// Denotes whether to enable logging for the load balancer traffic
	// served by this backend service. The default value is false.
	Enable bool `json:"enable,omitempty"`
	// Deprecated in favor of optionalMode. This field can only be specified
	// if logging is enabled for this backend service. Configures whether
	// all, none or a subset of optional fields should be added to the
	// reported logs. One of [INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL,
	// CUSTOM]. Default is EXCLUDE_ALL_OPTIONAL.
	Optional string `json:"optional,omitempty"`
	// This field can only be specified if logging is enabled for this
	// backend service and "logConfig.optionalMode" was set to CUSTOM.
	// Contains a list of optional fields you want to include in the logs.
	// For example: serverInstance, serverGkeDetails.cluster,
	// serverGkeDetails.pod.podNamespace
	OptionalFields []string `json:"optionalFields,omitempty"`
	// This field can only be specified if logging is enabled for this
	// backend service. Configures whether all, none or a subset of optional
	// fields should be added to the reported logs. One of
	// [INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM]. Default is
	// EXCLUDE_ALL_OPTIONAL.
	OptionalMode string `json:"optionalMode,omitempty"`
	// This field can only be specified if logging is enabled for this
	// backend service. The value of the field must be in [0, 1]. This
	// configures the sampling rate of requests to the load balancer where
	// 1.0 means all logged requests are reported and 0.0 means no logged
	// requests are reported. The default value is 1.0.
	SampleRate      float64  `json:"sampleRate,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceNetworkPassThroughLbTrafficPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceNetworkPassThroughLbTrafficPolicy struct {
	// When configured, new connections are load balanced across healthy
	// backend endpoints in the local zone.
	ZonalAffinity   *BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity `json:"zonalAffinity,omitempty"`
	ForceSendFields []string                                                      `json:"-"`
	NullFields      []string                                                      `json:"-"`
}

// BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity struct {
	// This field indicates whether zonal affinity is enabled or not. The
	// possible values are: - ZONAL_AFFINITY_DISABLED: Default Value. Zonal
	// Affinity is disabled. The load balancer distributes new connections
	// to all healthy backend endpoints across all zones. -
	// ZONAL_AFFINITY_STAY_WITHIN_ZONE: Zonal Affinity is enabled. The load
	// balancer distributes new connections to all healthy backend endpoints
	// in the local zone only. If there are no healthy backend endpoints in
	// the local zone, the load balancer distributes new connections to all
	// backend endpoints in the local zone. -
	// ZONAL_AFFINITY_SPILL_CROSS_ZONE: Zonal Affinity is enabled. The load
	// balancer distributes new connections to all healthy backend endpoints
	// in the local zone only. If there aren't enough healthy backend
	// endpoints in the local zone, the load balancer distributes new
	// connections to all healthy backend endpoints across all zones.
	Spillover string `json:"spillover,omitempty"`
	// The value of the field must be in [0, 1]. When the ratio of the count
	// of healthy backend endpoints in a zone to the count of backend
	// endpoints in that same zone is equal to or above this threshold, the
	// load balancer distributes new connections to all healthy endpoints in
	// the local zone only. When the ratio of the count of healthy backend
	// endpoints in a zone to the count of backend endpoints in that same
	// zone is below this threshold, the load balancer distributes all new
	// connections to all healthy endpoints across all zones.
	SpilloverRatio  float64  `json:"spilloverRatio,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceReference is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceReference struct {
	BackendService  string   `json:"backendService,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceUsedBy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceUsedBy struct {
	Reference       string   `json:"reference,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// CacheKeyPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CacheKeyPolicy struct {
	// If true, requests to different hosts will be cached separately.
	IncludeHost bool `json:"includeHost,omitempty"`
	// Allows HTTP request headers (by name) to be used in the cache key.
	IncludeHttpHeaders []string `json:"includeHttpHeaders,omitempty"`
	// Allows HTTP cookies (by name) to be used in the cache key. The
	// name=value pair will be used in the cache key Cloud CDN generates.
	IncludeNamedCookies []string `json:"includeNamedCookies,omitempty"`
	// If true, http and https requests will be cached separately.
	IncludeProtocol bool `json:"includeProtocol,omitempty"`
	// If true, include query string parameters in the cache key according
	// to query_string_whitelist and query_string_blacklist. If neither is
	// set, the entire query string will be included. If false, the query
	// string will be excluded from the cache key entirely.
	IncludeQueryString bool `json:"includeQueryString,omitempty"`
	// Names of query string parameters to exclude in cache keys. All other
	// parameters will be included. Either specify query_string_whitelist or
	// query_string_blacklist, not both. '&' and '=' will be percent encoded
	// and not treated as delimiters.
	QueryStringBlacklist []string `json:"queryStringBlacklist,omitempty"`
	// Names of query string parameters to include in cache keys. All other
	// parameters will be excluded. Either specify query_string_whitelist or
	// query_string_blacklist, not both. '&' and '=' will be percent encoded
	// and not treated as delimiters.
	QueryStringWhitelist []string `json:"queryStringWhitelist,omitempty"`
	ForceSendFields      []string `json:"-"`
	NullFields           []string `json:"-"`
}

// CallCredentials is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CallCredentials struct {
	// The type of call credentials to use for GRPC requests to the SDS
	// server. This field can be set to one of the following: - GCE_VM: The
	// local GCE VM service account credentials are used to access the SDS
	// server. - FROM_PLUGIN: Custom authenticator credentials are used to
	// access the SDS server.
	CallCredentialType string `json:"callCredentialType,omitempty"`
	// Custom authenticator credentials. Valid if callCredentialType is
	// FROM_PLUGIN.
	FromPlugin      *MetadataCredentialsFromPlugin `json:"fromPlugin,omitempty"`
	ForceSendFields []string                       `json:"-"`
	NullFields      []string                       `json:"-"`
}

// ChannelCredentials is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ChannelCredentials struct {
	// The call credentials to access the SDS server.
	Certificates *TlsCertificatePaths `json:"certificates,omitempty"`
	// The channel credentials to access the SDS server. This field can be
	// set to one of the following: CERTIFICATES: Use TLS certificates to
	// access the SDS server. GCE_VM: Use local GCE VM credentials to access
	// the SDS server.
	ChannelCredentialType string   `json:"channelCredentialType,omitempty"`
	ForceSendFields       []string `json:"-"`
	NullFields            []string `json:"-"`
}

// CircuitBreakers is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CircuitBreakers struct {
	// The timeout for new network connections to hosts.
	ConnectTimeout *Duration `json:"connectTimeout,omitempty"`
	// The maximum number of connections to the backend service. If not
	// specified, there is no limit. Not supported when the backend service
	// is referenced by a URL map that is bound to target gRPC proxy that
	// has validateForProxyless field set to true.
	MaxConnections int64 `json:"maxConnections,omitempty"`
	// The maximum number of pending requests allowed to the backend
	// service. If not specified, there is no limit. Not supported when the
	// backend service is referenced by a URL map that is bound to target
	// gRPC proxy that has validateForProxyless field set to true.
	MaxPendingRequests int64 `json:"maxPendingRequests,omitempty"`
	// The maximum number of parallel requests that allowed to the backend
	// service. If not specified, there is no limit.
	MaxRequests int64 `json:"maxRequests,omitempty"`
	// Maximum requests for a single connection to the backend service. This
	// parameter is respected by both the HTTP/1.1 and HTTP/2
	// implementations. If not specified, there is no limit. Setting this
	// parameter to 1 will effectively disable keep alive. Not supported
	// when the backend service is referenced by a URL map that is bound to
	// target gRPC proxy that has validateForProxyless field set to true.
	MaxRequestsPerConnection int64 `json:"maxRequestsPerConnection,omitempty"`
	// The maximum number of parallel retries allowed to the backend
	// cluster. If not specified, the default is 1. Not supported when the
	// backend service is referenced by a URL map that is bound to target
	// gRPC proxy that has validateForProxyless field set to true.
	MaxRetries      int64    `json:"maxRetries,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// ClientTlsSettings is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ClientTlsSettings struct {
	// Configures the mechanism to obtain client-side security certificates
	// and identity information. This field is only applicable when mode is
	// set to MUTUAL.
	ClientTlsContext *TlsContext `json:"clientTlsContext,omitempty"`
	// Indicates whether connections to this port should be secured using
	// TLS. The value of this field determines how TLS is enforced. This can
	// be set to one of the following values: DISABLE: Do not setup a TLS
	// connection to the backends. SIMPLE: Originate a TLS connection to the
	// backends. MUTUAL: Secure connections to the backends using mutual TLS
	// by presenting client certificates for authentication.
	Mode string `json:"mode,omitempty"`
	// SNI string to present to the server during TLS handshake. This field
	// is applicable only when mode is SIMPLE or MUTUAL.
	Sni string `json:"sni,omitempty"`
	// A list of alternate names to verify the subject identity in the
	// certificate.If specified, the proxy will verify that the server
	// certificate's subject alt name matches one of the specified values.
	// This field is applicable only when mode is SIMPLE or MUTUAL.
	SubjectAltNames []string `json:"subjectAltNames,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// ConnectionDraining is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ConnectionDraining struct {
	// Configures a duration timeout for existing requests on a removed
	// backend instance. For supported load balancers and protocols, as
	// described in Enabling connection draining.
	DrainingTimeoutSec int64    `json:"drainingTimeoutSec,omitempty"`
	ForceSendFields    []string `json:"-"`
	NullFields         []string `json:"-"`
}

// ConsistentHashLoadBalancerSettings is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ConsistentHashLoadBalancerSettings struct {
	// Hash is based on HTTP Cookie. This field describes a HTTP cookie that
	// will be used as the hash key for the consistent hash load balancer.
	// If the cookie is not present, it will be generated. This field is
	// applicable if the sessionAffinity is set to HTTP_COOKIE. Not
	// supported when the backend service is referenced by a URL map that is
	// bound to target gRPC proxy that has validateForProxyless field set to
	// true.
	HttpCookie *ConsistentHashLoadBalancerSettingsHttpCookie `json:"httpCookie,omitempty"`
	// The hash based on the value of the specified header field. This field
	// is applicable if the sessionAffinity is set to HEADER_FIELD.
	HttpHeaderName string `json:"httpHeaderName,omitempty"`
	// The minimum number of virtual nodes to use for the hash ring.
	// Defaults to 1024. Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool is
	// larger than the ring size, each host will be assigned a single
	// virtual node.
	MinimumRingSize int64    `json:"minimumRingSize,omitempty,string"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// ConsistentHashLoadBalancerSettingsHttpCookie is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ConsistentHashLoadBalancerSettingsHttpCookie struct {
	// Name of the cookie.
	Name string `json:"name,omitempty"`
	// Path to set for the cookie.
	Path string `json:"path,omitempty"`
	// Lifetime of the cookie.
	Ttl             *Duration `json:"ttl,omitempty"`
	ForceSendFields []string  `json:"-"`
	NullFields      []string  `json:"-"`
}

// CorsPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CorsPolicy struct {
	// In response to a preflight request, setting this to true indicates
	// that the actual request can include user credentials. This field
	// translates to the Access-Control-Allow-Credentials header. Default is
	// false.
	AllowCredentials bool `json:"allowCredentials,omitempty"`
	// Specifies the content for the Access-Control-Allow-Headers header.
	AllowHeaders []string `json:"allowHeaders,omitempty"`
	// Specifies the content for the Access-Control-Allow-Methods header.
	AllowMethods []string `json:"allowMethods,omitempty"`
	// Specifies a regular expression that matches allowed origins. For more
	// information, see regular expression syntax . An origin is allowed if
	// it matches either an item in allowOrigins or an item in
	// allowOriginRegexes. Regular expressions can only be used when the
	// loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
	AllowOriginRegexes []string `json:"allowOriginRegexes,omitempty"`
	// Specifies the list of origins that is allowed to do CORS requests. An
	// origin is allowed if it matches either an item in allowOrigins or an
	// item in allowOriginRegexes.
	AllowOrigins []string `json:"allowOrigins,omitempty"`
	// If true, disables the CORS policy. The default value is false, which
	// indicates that the CORS policy is in effect.
	Disabled bool `json:"disabled,omitempty"`
	// Specifies the content for the Access-Control-Expose-Headers header.
	ExposeHeaders []string `json:"exposeHeaders,omitempty"`
	// Specifies how long results of a preflight request can be cached in
	// seconds. This field translates to the Access-Control-Max-Age header.
	MaxAge          int64    `json:"maxAge,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// CustomErrorResponsePolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CustomErrorResponsePolicy struct {
	// Specifies rules for returning error responses. In a given policy, if
	// you specify rules for both a range of error codes as well as rules
	// for specific error codes then rules with specific error codes have a
	// higher priority. For example, assume that you configure a rule for
	// 401 (Un-authorized) code, and another for all 4 series error codes
	// (4XX). If the backend service returns a 401, then the rule for 401
	// will be applied. However if the backend service returns a 403, the
	// rule for 4xx takes effect.
	ErrorResponseRules []*CustomErrorResponsePolicyCustomErrorResponseRule `json:"errorResponseRules,omitempty"`
	// The full or partial URL to the BackendBucket resource that contains
	// the custom error content. Examples are: -
	// https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket - compute/v1/projects/project/global/backendBuckets/myBackendBucket - global/backendBuckets/myBackendBucket If errorService is not specified at lower levels like pathMatcher, pathRule and routeRule, an errorService specified at a higher level in the UrlMap will be used. If UrlMap.defaultCustomErrorResponsePolicy contains one or more errorResponseRules[], it must specify errorService. If load balancer cannot reach the backendBucket, a simple Not Found Error will be returned, with the original response code (or overrideResponseCode if configured). errorService is not supported for internal or regional HTTP/HTTPS load
	// balancers.
	ErrorService    string   `json:"errorService,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// CustomErrorResponsePolicyCustomErrorResponseRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CustomErrorResponsePolicyCustomErrorResponseRule struct {
	// Valid values include: - A number between 400 and 599: For example 401
	// or 503, in which case the load balancer applies the policy if the
	// error code exactly matches this value. - 5xx: Load Balancer will
	// apply the policy if the backend service responds with any response
	// code in the range of 500 to 599. - 4xx: Load Balancer will apply the
	// policy if the backend service responds with any response code in the
	// range of 400 to 499. Values must be unique within matchResponseCodes
	// and across all errorResponseRules of CustomErrorResponsePolicy.
	MatchResponseCodes []string `json:"matchResponseCodes,omitempty"`
	// The HTTP status code returned with the response containing the custom
	// error content. If overrideResponseCode is not supplied, the same
	// response code returned by the original backend bucket or backend
	// service is returned to the client.
	OverrideResponseCode int64 `json:"overrideResponseCode,omitempty"`
	// The full path to a file within backendBucket . For example:
	// /errors/defaultError.html path must start with a leading slash. path
	// cannot have trailing slashes. If the file is not available in
	// backendBucket or the load balancer cannot reach the BackendBucket, a
	// simple Not Found Error is returned to the client. The value must be
	// from 1 to 1024 characters
	Path            string   `json:"path,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// Duration is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Duration struct {
	// Span of time that's a fraction of a second at nanosecond resolution.
	// Durations less than one second are represented with a 0 `seconds`
	// field and a positive `nanos` field. Must be from 0 to 999,999,999
	// inclusive.
	Nanos int64 `json:"nanos,omitempty"`
	// Span of time at a resolution of a second. Must be from 0 to
	// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
	// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
	Seconds         int64    `json:"seconds,omitempty,string"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// ForwardingRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ForwardingRule struct {
	// Version keeps track of the intended compute version for this ForwardingRule.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// The ports, portRange, and allPorts fields are mutually exclusive.
	// Only packets addressed to ports in the specified range will be
	// forwarded to the backends configured with this forwarding rule. The
	// allPorts field has the following limitations: - It requires that the
	// forwarding rule IPProtocol be TCP, UDP, SCTP, or L3_DEFAULT. - It's
	// applicable only to the following products: internal passthrough
	// Network Load Balancers, backend service-based external passthrough
	// Network Load Balancers, and internal and external protocol
	// forwarding. - Set this field to true to allow packets addressed to
	// any port or packets lacking destination port information (for
	// example, UDP fragments after the first fragment) to be forwarded to
	// the backends configured with this forwarding rule. The L3_DEFAULT
	// protocol requires allPorts be set to true.
	AllPorts bool `json:"allPorts,omitempty"`
	// If set to true, clients can access the internal passthrough Network
	// Load Balancers, the regional internal Application Load Balancer, and
	// the regional internal proxy Network Load Balancer from all regions.
	// If false, only allows access from the local region the load balancer
	// is located at. Note that for INTERNAL_MANAGED forwarding rules, this
	// field cannot be changed after the forwarding rule is created.
	AllowGlobalAccess bool `json:"allowGlobalAccess,omitempty"`
	// This is used in PSC consumer ForwardingRule to control whether the
	// PSC endpoint can be accessed from another region.
	AllowPscGlobalAccess bool `json:"allowPscGlobalAccess,omitempty"`
	// This is used in PSC consumer ForwardingRule to control whether the
	// producer is allowed to inject packets into the consumer's network. If
	// set to true, the target service attachment must have tunneling
	// enabled and TunnelingConfig.RoutingMode set to PACKET_INJECTION
	// Non-PSC forwarding rules should not use this field.
	AllowPscPacketInjection bool `json:"allowPscPacketInjection,omitempty"`
	// Identifies the backend service to which the forwarding rule sends
	// traffic. Required for internal and external passthrough Network Load
	// Balancers; must be omitted for all other load balancer types.
	BackendService string `json:"backendService,omitempty"`
	// [Output Only] The URL for the corresponding base forwarding rule. By
	// base forwarding rule, we mean the forwarding rule that has the same
	// IP address, protocol, and port settings with the current forwarding
	// rule, but without sourceIPRanges specified. Always empty if the
	// current forwarding rule does not have sourceIPRanges specified.
	BaseForwardingRule string `json:"baseForwardingRule,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Specifies the canary migration state for the backend buckets attached
	// to this forwarding rule. Possible values are PREPARE,
	// TEST_BY_PERCENTAGE, and TEST_ALL_TRAFFIC. To begin the migration from
	// EXTERNAL to EXTERNAL_MANAGED, the state must be changed to PREPARE.
	// The state must be changed to TEST_ALL_TRAFFIC before the
	// loadBalancingScheme can be changed to EXTERNAL_MANAGED. Optionally,
	// the TEST_BY_PERCENTAGE state can be used to migrate traffic to
	// backend buckets attached to this forwarding rule by percentage using
	// externalManagedBackendBucketMigrationTestingPercentage. Rolling back
	// a migration requires the states to be set in reverse order. So
	// changing the scheme from EXTERNAL_MANAGED to EXTERNAL requires the
	// state to be set to TEST_ALL_TRAFFIC at the same time. Optionally, the
	// TEST_BY_PERCENTAGE state can be used to migrate some traffic back to
	// EXTERNAL or PREPARE can be used to migrate all traffic back to
	// EXTERNAL.
	ExternalManagedBackendBucketMigrationState string `json:"externalManagedBackendBucketMigrationState,omitempty"`
	// Determines the fraction of requests to backend buckets that should be
	// processed by the global external Application Load Balancer. The value
	// of this field must be in the range [0, 100]. This value can only be
	// set if the loadBalancingScheme in the BackendService is set to
	// EXTERNAL (when using the classic Application Load Balancer) and the
	// migration state is TEST_BY_PERCENTAGE.
	ExternalManagedBackendBucketMigrationTestingPercentage float64 `json:"externalManagedBackendBucketMigrationTestingPercentage,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a ForwardingRule. Include the fingerprint in
	// patch request to ensure that you do not overwrite changes that were
	// applied from another concurrent request. To see the latest
	// fingerprint, make a get() request to retrieve a ForwardingRule.
	Fingerprint string `json:"fingerprint,omitempty"`
	// IP address for which this forwarding rule accepts traffic. When a
	// client sends traffic to this IP address, the forwarding rule directs
	// the traffic to the referenced target or backendService. While
	// creating a forwarding rule, specifying an IPAddress is required under
	// the following circumstances: - When the target is set to
	// targetGrpcProxy and validateForProxyless is set to true, the
	// IPAddress should be set to 0.0.0.0. - When the target is a Private
	// Service Connect Google APIs bundle, you must specify an IPAddress.
	// Otherwise, you can optionally specify an IP address that references
	// an existing static (reserved) IP address resource. When omitted,
	// Google Cloud assigns an ephemeral IP address. Use one of the
	// following formats to specify an IP address while creating a
	// forwarding rule: * IP address number, as in `100.1.2.3` * IPv6
	// address range, as in `2600:1234::/96` * Full resource URL, as in
	// https://www.googleapis.com/compute/v1/projects/
	// project_id/regions/region/addresses/address-name * Partial URL or by
	// name, as in: -
	// projects/project_id/regions/region/addresses/address-name -
	// regions/region/addresses/address-name - global/addresses/address-name
	// - address-name The forwarding rule's target or backendService, and in
	// most cases, also the loadBalancingScheme, determine the type of IP
	// address that you can use. For detailed information, see [IP address
	// specifications](https://cloud.google.com/load-balancing/docs/forwardin
	// g-rule-concepts#ip_address_specifications). When reading an
	// IPAddress, the API always returns the IP address number.
	IPAddress string `json:"IPAddress,omitempty"`
	// The IP protocol to which this rule applies. For protocol forwarding,
	// valid options are TCP, UDP, ESP, AH, SCTP, ICMP and L3_DEFAULT. The
	// valid IP protocols are different for different load balancing
	// products as described in [Load balancing
	// features](https://cloud.google.com/load-balancing/docs/features#protoc
	// ols_from_the_load_balancer_to_the_backends).
	IPProtocol string `json:"IPProtocol,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// Resource reference of a PublicDelegatedPrefix. The PDP must be a
	// sub-PDP in EXTERNAL_IPV6_FORWARDING_RULE_CREATION mode. Use one of
	// the following formats to specify a sub-PDP when creating an IPv6
	// NetLB forwarding rule using BYOIP: Full resource URL, as in
	// https://www.googleapis.com/compute/v1/projects/project_id/regions/region /publicDelegatedPrefixes/sub-pdp-name Partial URL, as in: - projects/project_id/regions/region/publicDelegatedPrefixes/sub-pdp-name - regions/region/publicDelegatedPrefixes/sub-pdp-name
	IpCollection string `json:"ipCollection,omitempty"`
	// The IP Version that will be used by this forwarding rule. Valid
	// options are IPV4 or IPV6.
	IpVersion string `json:"ipVersion,omitempty"`
	// Indicates whether or not this load balancer can be used as a
	// collector for packet mirroring. To prevent mirroring loops, instances
	// behind this load balancer will not have their traffic mirrored even
	// if a PacketMirroring rule applies to them. This can only be set to
	// true for load balancers that have their loadBalancingScheme set to
	// INTERNAL.
	IsMirroringCollector bool `json:"isMirroringCollector,omitempty"`
	// [Output Only] Type of the resource. Always compute#forwardingRule for
	// forwarding rule resources.
	Kind string `json:"kind,omitempty"`
	// A fingerprint for the labels being applied to this resource, which is
	// essentially a hash of the labels set used for optimistic locking. The
	// fingerprint is initially generated by Compute Engine and changes
	// after every request to modify or update labels. You must always
	// provide an up-to-date fingerprint hash in order to update or change
	// labels, otherwise the request will fail with error 412
	// conditionNotMet. To see the latest fingerprint, make a get() request
	// to retrieve a ForwardingRule.
	LabelFingerprint string `json:"labelFingerprint,omitempty"`
	// Labels for this resource. These can only be added or modified by the
	// setLabels method. Each label key/value pair must comply with RFC1035.
	// Label values may be empty.
	Labels map[string]string `json:"labels,omitempty"`
	// Specifies the forwarding rule type. For more information about
	// forwarding rules, refer to Forwarding rule concepts.
	LoadBalancingScheme string `json:"loadBalancingScheme,omitempty"`
	// Opaque filter criteria used by load balancer to restrict routing
	// configuration to a limited set of xDS compliant clients. In their xDS
	// requests to load balancer, xDS clients present node metadata. When
	// there is a match, the relevant configuration is made available to
	// those proxies. Otherwise, all the resources (e.g. TargetHttpProxy,
	// UrlMap) referenced by the ForwardingRule are not visible to those
	// proxies. For each metadataFilter in this list, if its
	// filterMatchCriteria is set to MATCH_ANY, at least one of the
	// filterLabels must match the corresponding label provided in the
	// metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of
	// its filterLabels must match with corresponding labels provided in the
	// metadata. If multiple metadataFilters are specified, all of them need
	// to be satisfied in order to be considered a match. metadataFilters
	// specified here will be applifed before those specified in the UrlMap
	// that this ForwardingRule references. metadataFilters only applies to
	// Loadbalancers that have their loadBalancingScheme set to
	// INTERNAL_SELF_MANAGED.
	MetadataFilters []*MetadataFilter `json:"metadataFilters,omitempty"`
	// Name of the resource; provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash. For Private Service Connect
	// forwarding rules that forward traffic to Google APIs, the forwarding
	// rule name must be a 1-20 characters string with lowercase letters and
	// numbers and must start with a letter.
	Name string `json:"name,omitempty"`
	// This field is not used for global external load balancing. For
	// internal passthrough Network Load Balancers, this field identifies
	// the network that the load balanced IP should belong to for this
	// forwarding rule. If the subnetwork is specified, the network of the
	// subnetwork will be used. If neither subnetwork nor this field is
	// specified, the default network will be used. For Private Service
	// Connect forwarding rules that forward traffic to Google APIs, a
	// network must be provided.
	Network string `json:"network,omitempty"`
	// This signifies the networking tier used for configuring this load
	// balancer and can only take the following values: PREMIUM, STANDARD.
	// For regional ForwardingRule, the valid values are PREMIUM and
	// STANDARD. For GlobalForwardingRule, the valid value is PREMIUM. If
	// this field is not specified, it is assumed to be PREMIUM. If
	// IPAddress is specified, this value must be equal to the networkTier
	// of the Address.
	NetworkTier string `json:"networkTier,omitempty"`
	// This is used in PSC consumer ForwardingRule to control whether it
	// should try to auto-generate a DNS zone or not. Non-PSC forwarding
	// rules do not use this field. Once set, this field is not mutable.
	NoAutomateDnsZone bool `json:"noAutomateDnsZone,omitempty"`
	// The ports, portRange, and allPorts fields are mutually exclusive.
	// Only packets addressed to ports in the specified range will be
	// forwarded to the backends configured with this forwarding rule. The
	// portRange field has the following limitations: - It requires that the
	// forwarding rule IPProtocol be TCP, UDP, or SCTP, and - It's
	// applicable only to the following products: external passthrough
	// Network Load Balancers, internal and external proxy Network Load
	// Balancers, internal and external Application Load Balancers, external
	// protocol forwarding, and Classic VPN. - Some products have
	// restrictions on what ports can be used. See port specifications for
	// details. For external forwarding rules, two or more forwarding rules
	// cannot use the same [IPAddress, IPProtocol] pair, and cannot have
	// overlapping portRanges. For internal forwarding rules within the same
	// VPC network, two or more forwarding rules cannot use the same
	// [IPAddress, IPProtocol] pair, and cannot have overlapping portRanges.
	// @pattern: \\d+(?:-\\d+)?
	PortRange string `json:"portRange,omitempty"`
	// The ports, portRange, and allPorts fields are mutually exclusive.
	// Only packets addressed to ports in the specified range will be
	// forwarded to the backends configured with this forwarding rule. The
	// ports field has the following limitations: - It requires that the
	// forwarding rule IPProtocol be TCP, UDP, or SCTP, and - It's
	// applicable only to the following products: internal passthrough
	// Network Load Balancers, backend service-based external passthrough
	// Network Load Balancers, and internal protocol forwarding. - You can
	// specify a list of up to five ports by number, separated by commas.
	// The ports can be contiguous or discontiguous. For external forwarding
	// rules, two or more forwarding rules cannot use the same [IPAddress,
	// IPProtocol] pair if they share at least one port number. For internal
	// forwarding rules within the same VPC network, two or more forwarding
	// rules cannot use the same [IPAddress, IPProtocol] pair if they share
	// at least one port number. @pattern: \\d+(?:-\\d+)?
	Ports []string `json:"ports,omitempty"`
	// [Output Only] The PSC connection id of the PSC forwarding rule.
	PscConnectionId     uint64 `json:"pscConnectionId,omitempty,string"`
	PscConnectionStatus string `json:"pscConnectionStatus,omitempty"`
	// [Output Only] URL of the region where the regional forwarding rule
	// resides. This field is not applicable to global forwarding rules. You
	// must specify this field as part of the HTTP request URL. It is not
	// settable as a field in the request body.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// Service Directory resources to register this forwarding rule with.
	// Currently, only supports a single Service Directory resource.
	ServiceDirectoryRegistrations []*ForwardingRuleServiceDirectoryRegistration `json:"serviceDirectoryRegistrations,omitempty"`
	// An optional prefix to the service name for this forwarding rule. If
	// specified, the prefix is the first label of the fully qualified
	// service name. The label must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the label must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash. This field is only used for
	// internal load balancing.
	ServiceLabel string `json:"serviceLabel,omitempty"`
	// [Output Only] The internal fully qualified service name for this
	// forwarding rule. This field is only used for internal load balancing.
	ServiceName string `json:"serviceName,omitempty"`
	// If not empty, this forwarding rule will only forward the traffic when
	// the source IP address matches one of the IP addresses or CIDR ranges
	// set here. Note that a forwarding rule can only have up to 64 source
	// IP ranges, and this field can only be used with a regional forwarding
	// rule whose scheme is EXTERNAL. Each source_ip_range entry should be
	// either an IP address (for example, 1.2.3.4) or a CIDR range (for
	// example, 1.2.3.0/24).
	SourceIpRanges []string `json:"sourceIpRanges,omitempty"`
	// This field identifies the subnetwork that the load balanced IP should
	// belong to for this forwarding rule, used with internal load balancers
	// and external passthrough Network Load Balancers with IPv6. If the
	// network specified is in auto subnet mode, this field is optional.
	// However, a subnetwork must be specified if the network is in custom
	// subnet mode or when creating external forwarding rule with IPv6.
	Subnetwork string `json:"subnetwork,omitempty"`
	// The URL of the target resource to receive the matched traffic. For
	// regional forwarding rules, this target must be in the same region as
	// the forwarding rule. For global forwarding rules, this target must be
	// a global load balancing resource. The forwarded traffic must be of a
	// type appropriate to the target object. - For load balancers, see the
	// "Target" column in [Port
	// specifications](https://cloud.google.com/load-balancing/docs/forwardin
	// g-rule-concepts#ip_address_specifications). - For Private Service
	// Connect forwarding rules that forward traffic to Google APIs, provide
	// the name of a supported Google API bundle: - vpc-sc - APIs that
	// support VPC Service Controls. - all-apis - All supported Google APIs.
	// - For Private Service Connect forwarding rules that forward traffic
	// to managed services, the target must be a service attachment. The
	// target is not mutable once set as a service attachment.
	Target                   string `json:"target,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// ForwardingRuleReference is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ForwardingRuleReference struct {
	ForwardingRule  string   `json:"forwardingRule,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// ForwardingRuleServiceDirectoryRegistration is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ForwardingRuleServiceDirectoryRegistration struct {
	// Service Directory namespace to register the forwarding rule under.
	Namespace string `json:"namespace,omitempty"`
	// Service Directory service to register the forwarding rule under.
	Service string `json:"service,omitempty"`
	// [Optional] Service Directory region to register this global
	// forwarding rule under. Default to "us-central1". Only used for PSC
	// for Google APIs. All PSC for Google APIs forwarding rules on the same
	// network should use the same Service Directory region.
	ServiceDirectoryRegion string   `json:"serviceDirectoryRegion,omitempty"`
	ForceSendFields        []string `json:"-"`
	NullFields             []string `json:"-"`
}

// GRPCHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type GRPCHealthCheck struct {
	// The gRPC service name for the health check. This field is optional.
	// The value of grpc_service_name has the following meanings by
	// convention: - Empty service_name means the overall status of all
	// services at the backend. - Non-empty service_name means the health of
	// that gRPC service, as defined by the owner of the service. The
	// grpc_service_name can only be ASCII.
	GrpcServiceName string `json:"grpcServiceName,omitempty"`
	// The TCP port number to which the health check prober sends packets.
	// Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Not supported.
	PortName string `json:"portName,omitempty"`
	// Specifies how a port is selected for health checking. Can be one of
	// the following values: USE_FIXED_PORT: Specifies a port number
	// explicitly using the port field in the health check. Supported by
	// backend services for passthrough load balancers and backend services
	// for proxy load balancers. Not supported by target pools. The health
	// check supports all backends supported by the backend service provided
	// the backend can be health checked. For example, GCE_VM_IP network
	// endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance
	// group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT:
	// Provides an indirect method of specifying the health check port by
	// referring to the backend service. Only supported by backend services
	// for proxy load balancers. Not supported by target pools. Not
	// supported by backend services for passthrough load balancers.
	// Supports all backends that can be health checked; for example,
	// GCE_VM_IP_PORT network endpoint groups and instance group backends.
	// For GCE_VM_IP_PORT network endpoint group backends, the health check
	// uses the port number specified for each endpoint in the network
	// endpoint group. For instance group backends, the health check uses
	// the port number determined by looking up the backend service's named
	// port in the instance group's list of named ports.
	PortSpecification string   `json:"portSpecification,omitempty"`
	ForceSendFields   []string `json:"-"`
	NullFields        []string `json:"-"`
}

// GRPCTLSHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type GRPCTLSHealthCheck struct {
	// The gRPC service name for the health check. This field is optional.
	// The value of grpc_service_name has the following meanings by
	// convention: - Empty service_name means the overall status of all
	// services at the backend. - Non-empty service_name means the health of
	// that gRPC service, as defined by the owner of the service. The
	// grpc_service_name can only be ASCII.
	GrpcServiceName string `json:"grpcServiceName,omitempty"`
	// The TCP port number to which the health check prober sends packets.
	// Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Specifies how a port is selected for health checking. Can be one of
	// the following values: USE_FIXED_PORT: Specifies a port number
	// explicitly using the port field in the health check. Supported by
	// backend services for passthrough load balancers and backend services
	// for proxy load balancers. Not supported by target pools. The health
	// check supports all backends supported by the backend service provided
	// the backend can be health checked. For example, GCE_VM_IP network
	// endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance
	// group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT:
	// Provides an indirect method of specifying the health check port by
	// referring to the backend service. Only supported by backend services
	// for proxy load balancers. Not supported by target pools. Not
	// supported by backend services for passthrough load balancers.
	// Supports all backends that can be health checked; for example,
	// GCE_VM_IP_PORT network endpoint groups and instance group backends.
	// For GCE_VM_IP_PORT network endpoint group backends, the health check
	// uses the port number specified for each endpoint in the network
	// endpoint group. For instance group backends, the health check uses
	// the port number determined by looking up the backend service's named
	// port in the instance group's list of named ports.
	PortSpecification string   `json:"portSpecification,omitempty"`
	ForceSendFields   []string `json:"-"`
	NullFields        []string `json:"-"`
}

// GrpcServiceConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type GrpcServiceConfig struct {
	// The call credentials to access the SDS server.
	CallCredentials *CallCredentials `json:"callCredentials,omitempty"`
	// The channel credentials to access the SDS server.
	ChannelCredentials *ChannelCredentials `json:"channelCredentials,omitempty"`
	// The target URI of the SDS server.
	TargetUri       string   `json:"targetUri,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HTTP2HealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HTTP2HealthCheck struct {
	// The value of the host header in the HTTP/2 health check request. If
	// left empty (default value), the host header is set to the destination
	// IP address to which health check packets are sent. The destination IP
	// address depends on the type of load balancer. For details, see:
	// https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
	Host string `json:"host,omitempty"`
	// The TCP port number to which the health check prober sends packets.
	// The default value is 443. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Not supported.
	PortName string `json:"portName,omitempty"`
	// Specifies how a port is selected for health checking. Can be one of
	// the following values: USE_FIXED_PORT: Specifies a port number
	// explicitly using the port field in the health check. Supported by
	// backend services for passthrough load balancers and backend services
	// for proxy load balancers. Not supported by target pools. The health
	// check supports all backends supported by the backend service provided
	// the backend can be health checked. For example, GCE_VM_IP network
	// endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance
	// group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT:
	// Provides an indirect method of specifying the health check port by
	// referring to the backend service. Only supported by backend services
	// for proxy load balancers. Not supported by target pools. Not
	// supported by backend services for passthrough load balancers.
	// Supports all backends that can be health checked; for example,
	// GCE_VM_IP_PORT network endpoint groups and instance group backends.
	// For GCE_VM_IP_PORT network endpoint group backends, the health check
	// uses the port number specified for each endpoint in the network
	// endpoint group. For instance group backends, the health check uses
	// the port number determined by looking up the backend service's named
	// port in the instance group's list of named ports.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The request path of the HTTP/2 health check request. The default
	// value is /. Must comply with RFC3986.
	RequestPath string `json:"requestPath,omitempty"`
	// Creates a content-based HTTP/2 health check. In addition to the
	// required HTTP 200 (OK) status code, you can configure the health
	// check to pass only when the backend sends this specific ASCII
	// response string within the first 1024 bytes of the HTTP response
	// body. For details, see:
	// https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
	Response string `json:"response,omitempty"`
	// Weight report mode. used for weighted Load Balancing.
	WeightReportMode string   `json:"weightReportMode,omitempty"`
	ForceSendFields  []string `json:"-"`
	NullFields       []string `json:"-"`
}

// HTTPHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HTTPHealthCheck struct {
	// The value of the host header in the HTTP health check request. If
	// left empty (default value), the host header is set to the destination
	// IP address to which health check packets are sent. The destination IP
	// address depends on the type of load balancer. For details, see:
	// https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
	Host string `json:"host,omitempty"`
	// The TCP port number to which the health check prober sends packets.
	// The default value is 80. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Not supported.
	PortName string `json:"portName,omitempty"`
	// Specifies how a port is selected for health checking. Can be one of
	// the following values: USE_FIXED_PORT: Specifies a port number
	// explicitly using the port field in the health check. Supported by
	// backend services for passthrough load balancers and backend services
	// for proxy load balancers. Also supported in legacy HTTP health checks
	// for target pools. The health check supports all backends supported by
	// the backend service provided the backend can be health checked. For
	// example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network
	// endpoint groups, and instance group backends. USE_NAMED_PORT: Not
	// supported. USE_SERVING_PORT: Provides an indirect method of
	// specifying the health check port by referring to the backend service.
	// Only supported by backend services for proxy load balancers. Not
	// supported by target pools. Not supported by backend services for
	// pass-through load balancers. Supports all backends that can be health
	// checked; for example, GCE_VM_IP_PORT network endpoint groups and
	// instance group backends. For GCE_VM_IP_PORT network endpoint group
	// backends, the health check uses the port number specified for each
	// endpoint in the network endpoint group. For instance group backends,
	// the health check uses the port number determined by looking up the
	// backend service's named port in the instance group's list of named
	// ports.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The request path of the HTTP health check request. The default value
	// is /. Must comply with RFC3986.
	RequestPath string `json:"requestPath,omitempty"`
	// Creates a content-based HTTP health check. In addition to the
	// required HTTP 200 (OK) status code, you can configure the health
	// check to pass only when the backend sends this specific ASCII
	// response string within the first 1024 bytes of the HTTP response
	// body. For details, see:
	// https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
	Response string `json:"response,omitempty"`
	// Weight report mode. used for weighted Load Balancing.
	WeightReportMode string   `json:"weightReportMode,omitempty"`
	ForceSendFields  []string `json:"-"`
	NullFields       []string `json:"-"`
}

// HTTPSHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HTTPSHealthCheck struct {
	// The value of the host header in the HTTPS health check request. If
	// left empty (default value), the host header is set to the destination
	// IP address to which health check packets are sent. The destination IP
	// address depends on the type of load balancer. For details, see:
	// https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
	Host string `json:"host,omitempty"`
	// The TCP port number to which the health check prober sends packets.
	// The default value is 443. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Not supported.
	PortName string `json:"portName,omitempty"`
	// Specifies how a port is selected for health checking. Can be one of
	// the following values: USE_FIXED_PORT: Specifies a port number
	// explicitly using the port field in the health check. Supported by
	// backend services for passthrough load balancers and backend services
	// for proxy load balancers. Not supported by target pools. The health
	// check supports all backends supported by the backend service provided
	// the backend can be health checked. For example, GCE_VM_IP network
	// endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance
	// group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT:
	// Provides an indirect method of specifying the health check port by
	// referring to the backend service. Only supported by backend services
	// for proxy load balancers. Not supported by target pools. Not
	// supported by backend services for passthrough load balancers.
	// Supports all backends that can be health checked; for example,
	// GCE_VM_IP_PORT network endpoint groups and instance group backends.
	// For GCE_VM_IP_PORT network endpoint group backends, the health check
	// uses the port number specified for each endpoint in the network
	// endpoint group. For instance group backends, the health check uses
	// the port number determined by looking up the backend service's named
	// port in the instance group's list of named ports.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The request path of the HTTPS health check request. The default value
	// is /. Must comply with RFC3986.
	RequestPath string `json:"requestPath,omitempty"`
	// Creates a content-based HTTPS health check. In addition to the
	// required HTTP 200 (OK) status code, you can configure the health
	// check to pass only when the backend sends this specific ASCII
	// response string within the first 1024 bytes of the HTTP response
	// body. For details, see:
	// https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
	Response string `json:"response,omitempty"`
	// Weight report mode. used for weighted Load Balancing.
	WeightReportMode string   `json:"weightReportMode,omitempty"`
	ForceSendFields  []string `json:"-"`
	NullFields       []string `json:"-"`
}

// HealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HealthCheck struct {
	// Version keeps track of the intended compute version for this HealthCheck.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// How often (in seconds) to send a health check. The default value is 5
	// seconds.
	CheckIntervalSec int64 `json:"checkIntervalSec,omitempty"`
	// [Output Only] Creation timestamp in 3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description        string              `json:"description,omitempty"`
	GrpcHealthCheck    *GRPCHealthCheck    `json:"grpcHealthCheck,omitempty"`
	GrpcTlsHealthCheck *GRPCTLSHealthCheck `json:"grpcTlsHealthCheck,omitempty"`
	// A so-far unhealthy instance will be marked healthy after this many
	// consecutive successes. The default value is 2.
	HealthyThreshold int64             `json:"healthyThreshold,omitempty"`
	Http2HealthCheck *HTTP2HealthCheck `json:"http2HealthCheck,omitempty"`
	HttpHealthCheck  *HTTPHealthCheck  `json:"httpHealthCheck,omitempty"`
	HttpsHealthCheck *HTTPSHealthCheck `json:"httpsHealthCheck,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// Type of the resource.
	Kind string `json:"kind,omitempty"`
	// Configure logging on this health check.
	LogConfig *HealthCheckLogConfig `json:"logConfig,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. For example, a name that is 1-63 characters long, matches
	// the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`, and otherwise
	// complies with RFC1035. This regular expression describes a name where
	// the first character is a lowercase letter, and all following
	// characters are a dash, lowercase letter, or digit, except the last
	// character, which isn't a dash.
	Name string `json:"name,omitempty"`
	// [Output Only] Region where the health check resides. Not applicable
	// to global health checks.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// The list of cloud regions from which health checks are performed. If
	// any regions are specified, then exactly 3 regions should be
	// specified. The region names must be valid names of Google Cloud
	// regions. This can only be set for global health check. If this list
	// is non-empty, then there are restrictions on what other health check
	// fields are supported and what other resources can use this health
	// check: - SSL, HTTP2, and GRPC protocols are not supported. - The TCP
	// request field is not supported. - The proxyHeader field for HTTP,
	// HTTPS, and TCP is not supported. - The checkIntervalSec field must be
	// at least 30. - The health check cannot be used with BackendService
	// nor with managed instance group auto-healing.
	SourceRegions  []string        `json:"sourceRegions,omitempty"`
	SslHealthCheck *SSLHealthCheck `json:"sslHealthCheck,omitempty"`
	TcpHealthCheck *TCPHealthCheck `json:"tcpHealthCheck,omitempty"`
	// How long (in seconds) to wait before claiming failure. The default
	// value is 5 seconds. It is invalid for timeoutSec to have greater
	// value than checkIntervalSec.
	TimeoutSec int64 `json:"timeoutSec,omitempty"`
	// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS,
	// HTTP2 or GRPC. Exactly one of the protocol-specific health check
	// fields must be specified, which must match type field.
	Type           string          `json:"type,omitempty"`
	UdpHealthCheck *UDPHealthCheck `json:"udpHealthCheck,omitempty"`
	// A so-far healthy instance will be marked unhealthy after this many
	// consecutive failures. The default value is 2.
	UnhealthyThreshold       int64 `json:"unhealthyThreshold,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// HealthCheckLogConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HealthCheckLogConfig struct {
	// Indicates whether or not to export logs. This is false by default,
	// which means no health check logging will be done.
	Enable          bool     `json:"enable,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HealthCheckReference is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HealthCheckReference struct {
	HealthCheck     string   `json:"healthCheck,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HealthCheckServiceReference is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HealthCheckServiceReference struct {
	HealthCheckService string   `json:"healthCheckService,omitempty"`
	ForceSendFields    []string `json:"-"`
	NullFields         []string `json:"-"`
}

// HealthStatusForNetworkEndpoint is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HealthStatusForNetworkEndpoint struct {
	// Version keeps track of the intended compute version for this HealthStatusForNetworkEndpoint.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// URL of the backend service associated with the health state of the
	// network endpoint.
	BackendService *BackendServiceReference `json:"backendService,omitempty"`
	// URL of the forwarding rule associated with the health state of the
	// network endpoint.
	ForwardingRule *ForwardingRuleReference `json:"forwardingRule,omitempty"`
	// URL of the health check associated with the health state of the
	// network endpoint.
	HealthCheck *HealthCheckReference `json:"healthCheck,omitempty"`
	// URL of the health check service associated with the health state of
	// the network endpoint.
	HealthCheckService *HealthCheckServiceReference `json:"healthCheckService,omitempty"`
	// Health state of the network endpoint determined based on the health
	// checks configured.
	HealthState string `json:"healthState,omitempty"`
	// Health state of the ipv6 network endpoint determined based on the
	// health checks configured.
	Ipv6HealthState string   `json:"ipv6HealthState,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HostRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HostRule struct {
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// The list of host patterns to match. They must be valid hostnames with
	// optional port numbers in the format host:port. * matches any string
	// of ([a-z0-9-.]*). In that case, * must be the first character, and if
	// followed by anything, the immediate following character must be
	// either - or .. * based matching is not supported when the URL map is
	// bound to a target gRPC proxy that has the validateForProxyless field
	// set to true.
	Hosts []string `json:"hosts,omitempty"`
	// The name of the PathMatcher to use to match the path portion of the
	// URL if the hostRule matches the URL's host portion.
	PathMatcher     string   `json:"pathMatcher,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpFaultAbort is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpFaultAbort struct {
	// The HTTP status code used to abort the request. The value must be
	// from 200 to 599 inclusive. For gRPC protocol, the gRPC status code is
	// mapped to HTTP status code according to this mapping table. HTTP
	// status 200 is mapped to gRPC status UNKNOWN. Injecting an OK status
	// is currently not supported by Traffic Director.
	HttpStatus int64 `json:"httpStatus,omitempty"`
	// The percentage of traffic for connections, operations, or requests
	// that is aborted as part of fault injection. The value must be from
	// 0.0 to 100.0 inclusive.
	Percentage      float64  `json:"percentage,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpFaultDelay is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpFaultDelay struct {
	// Specifies the value of the fixed delay interval.
	FixedDelay *Duration `json:"fixedDelay,omitempty"`
	// The percentage of traffic for connections, operations, or requests
	// for which a delay is introduced as part of fault injection. The value
	// must be from 0.0 to 100.0 inclusive.
	Percentage      float64  `json:"percentage,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpFaultInjection is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpFaultInjection struct {
	// The specification for how client requests are aborted as part of
	// fault injection.
	Abort *HttpFaultAbort `json:"abort,omitempty"`
	// The specification for how client requests are delayed as part of
	// fault injection, before being sent to a backend service.
	Delay           *HttpFaultDelay `json:"delay,omitempty"`
	ForceSendFields []string        `json:"-"`
	NullFields      []string        `json:"-"`
}

// HttpFilterConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpFilterConfig struct {
	// The configuration needed to enable the networkservices.HttpFilter
	// resource. The configuration must be YAML formatted and only contain
	// fields defined in the protobuf identified in configTypeUrl
	Config string `json:"config,omitempty"`
	// The fully qualified versioned proto3 type url of the protobuf that
	// the filter expects for its contextual settings, for example:
	// type.googleapis.com/google.protobuf.Struct
	ConfigTypeUrl string `json:"configTypeUrl,omitempty"`
	// Name of the networkservices.HttpFilter resource this configuration
	// belongs to. This name must be known to the xDS client. Example:
	// envoy.wasm
	FilterName      string   `json:"filterName,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpHeaderAction is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpHeaderAction struct {
	// Headers to add to a matching request before forwarding the request to
	// the backendService.
	RequestHeadersToAdd []*HttpHeaderOption `json:"requestHeadersToAdd,omitempty"`
	// A list of header names for headers that need to be removed from the
	// request before forwarding the request to the backendService.
	RequestHeadersToRemove []string `json:"requestHeadersToRemove,omitempty"`
	// Headers to add the response before sending the response back to the
	// client.
	ResponseHeadersToAdd []*HttpHeaderOption `json:"responseHeadersToAdd,omitempty"`
	// A list of header names for headers that need to be removed from the
	// response before sending the response back to the client.
	ResponseHeadersToRemove []string `json:"responseHeadersToRemove,omitempty"`
	ForceSendFields         []string `json:"-"`
	NullFields              []string `json:"-"`
}

// HttpHeaderMatch is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpHeaderMatch struct {
	// The value should exactly match contents of exactMatch. Only one of
	// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
	// rangeMatch must be set.
	ExactMatch string `json:"exactMatch,omitempty"`
	// The name of the HTTP header to match. For matching against the HTTP
	// request's authority, use a headerMatch with the header name
	// ":authority". For matching a request's method, use the headerName
	// ":method". When the URL map is bound to a target gRPC proxy that has
	// the validateForProxyless field set to true, only non-binary
	// user-specified custom metadata and the `content-type` header are
	// supported. The following transport-level headers cannot be used in
	// header matching rules: `:authority`, `:method`, `:path`, `:scheme`,
	// `user-agent`, `accept-encoding`, `content-encoding`,
	// `grpc-accept-encoding`, `grpc-encoding`,
	// `grpc-previous-rpc-attempts`, `grpc-tags-bin`, `grpc-timeout` and
	// `grpc-trace-bin`.
	HeaderName string `json:"headerName,omitempty"`
	// If set to false, the headerMatch is considered a match if the
	// preceding match criteria are met. If set to true, the headerMatch is
	// considered a match if the preceding match criteria are NOT met. The
	// default setting is false.
	InvertMatch bool `json:"invertMatch,omitempty"`
	// The value of the header must start with the contents of prefixMatch.
	// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
	// presentMatch or rangeMatch must be set.
	PrefixMatch string `json:"prefixMatch,omitempty"`
	// A header with the contents of headerName must exist. The match takes
	// place whether or not the request's header has a value. Only one of
	// exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
	// rangeMatch must be set.
	PresentMatch bool `json:"presentMatch,omitempty"`
	// The header value must be an integer and its value must be in the
	// range specified in rangeMatch. If the header does not contain an
	// integer, number or is empty, the match fails. For example for a range
	// [-5, 0] - -3 will match. - 0 will not match. - 0.25 will not match. -
	// -3someString will not match. Only one of exactMatch, prefixMatch,
	// suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
	// rangeMatch is not supported for load balancers that have
	// loadBalancingScheme set to EXTERNAL.
	RangeMatch *Int64RangeMatch `json:"rangeMatch,omitempty"`
	// The value of the header must match the regular expression specified
	// in regexMatch. For more information about regular expression syntax,
	// see Syntax. For matching against a port specified in the HTTP
	// request, use a headerMatch with headerName set to PORT and a regular
	// expression that satisfies the RFC2616 Host header's port specifier.
	// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
	// presentMatch or rangeMatch must be set. Regular expressions can only
	// be used when the loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
	RegexMatch string `json:"regexMatch,omitempty"`
	// The value of the header must end with the contents of suffixMatch.
	// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
	// presentMatch or rangeMatch must be set.
	SuffixMatch     string   `json:"suffixMatch,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpHeaderOption is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpHeaderOption struct {
	// The name of the header.
	HeaderName string `json:"headerName,omitempty"`
	// The value of the header to add.
	HeaderValue string `json:"headerValue,omitempty"`
	// If false, headerValue is appended to any values that already exist
	// for the header. If true, headerValue is set for the header,
	// discarding any values that were set for that header. The default
	// value is false.
	Replace         bool     `json:"replace,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpQueryParameterMatch is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpQueryParameterMatch struct {
	// The queryParameterMatch matches if the value of the parameter exactly
	// matches the contents of exactMatch. Only one of presentMatch,
	// exactMatch, or regexMatch must be set.
	ExactMatch string `json:"exactMatch,omitempty"`
	// The name of the query parameter to match. The query parameter must
	// exist in the request, in the absence of which the request match
	// fails.
	Name string `json:"name,omitempty"`
	// Specifies that the queryParameterMatch matches if the request
	// contains the query parameter, irrespective of whether the parameter
	// has a value or not. Only one of presentMatch, exactMatch, or
	// regexMatch must be set.
	PresentMatch bool `json:"presentMatch,omitempty"`
	// The queryParameterMatch matches if the value of the parameter matches
	// the regular expression specified by regexMatch. For more information
	// about regular expression syntax, see Syntax. Only one of
	// presentMatch, exactMatch, or regexMatch must be set. Regular
	// expressions can only be used when the loadBalancingScheme is set to
	// INTERNAL_SELF_MANAGED.
	RegexMatch      string   `json:"regexMatch,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpRedirectAction is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpRedirectAction struct {
	// The host that is used in the redirect response instead of the one
	// that was supplied in the request. The value must be from 1 to 255
	// characters.
	HostRedirect string `json:"hostRedirect,omitempty"`
	// If set to true, the URL scheme in the redirected request is set to
	// HTTPS. If set to false, the URL scheme of the redirected request
	// remains the same as that of the request. This must only be set for
	// URL maps used in TargetHttpProxys. Setting this true for
	// TargetHttpsProxy is not permitted. The default is set to false.
	HttpsRedirect bool `json:"httpsRedirect,omitempty"`
	// The path that is used in the redirect response instead of the one
	// that was supplied in the request. pathRedirect cannot be supplied
	// together with prefixRedirect. Supply one alone or neither. If neither
	// is supplied, the path of the original request is used for the
	// redirect. The value must be from 1 to 1024 characters.
	PathRedirect string `json:"pathRedirect,omitempty"`
	// The prefix that replaces the prefixMatch specified in the
	// HttpRouteRuleMatch, retaining the remaining portion of the URL before
	// redirecting the request. prefixRedirect cannot be supplied together
	// with pathRedirect. Supply one alone or neither. If neither is
	// supplied, the path of the original request is used for the redirect.
	// The value must be from 1 to 1024 characters.
	PrefixRedirect string `json:"prefixRedirect,omitempty"`
	// The HTTP Status code to use for this RedirectAction. Supported values
	// are: - MOVED_PERMANENTLY_DEFAULT, which is the default value and
	// corresponds to 301. - FOUND, which corresponds to 302. - SEE_OTHER
	// which corresponds to 303. - TEMPORARY_REDIRECT, which corresponds to
	// 307. In this case, the request method is retained. -
	// PERMANENT_REDIRECT, which corresponds to 308. In this case, the
	// request method is retained.
	RedirectResponseCode string `json:"redirectResponseCode,omitempty"`
	// If set to true, any accompanying query portion of the original URL is
	// removed before redirecting the request. If set to false, the query
	// portion of the original URL is retained. The default is set to false.
	StripQuery      bool     `json:"stripQuery,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpRetryPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpRetryPolicy struct {
	// Specifies the allowed number retries. This number must be > 0. If not
	// specified, defaults to 1.
	NumRetries int64 `json:"numRetries,omitempty"`
	// Specifies a non-zero timeout per retry attempt. If not specified,
	// will use the timeout set in the HttpRouteAction field. If timeout in
	// the HttpRouteAction field is not set, this field uses the largest
	// timeout among all backend services associated with the route. Not
	// supported when the URL map is bound to a target gRPC proxy that has
	// the validateForProxyless field set to true.
	PerTryTimeout *Duration `json:"perTryTimeout,omitempty"`
	// Specifies one or more conditions when this retry policy applies.
	// Valid values are: - 5xx: retry is attempted if the instance or
	// endpoint responds with any 5xx response code, or if the instance or
	// endpoint does not respond at all. For example, disconnects, reset,
	// read timeout, connection failure, and refused streams. -
	// gateway-error: Similar to 5xx, but only applies to response codes
	// 502, 503 or 504. - connect-failure: a retry is attempted on failures
	// connecting to the instance or endpoint. For example, connection
	// timeouts. - retriable-4xx: a retry is attempted if the instance or
	// endpoint responds with a 4xx response code. The only error that you
	// can retry is error code 409. - refused-stream: a retry is attempted
	// if the instance or endpoint resets the stream with a REFUSED_STREAM
	// error code. This reset type indicates that it is safe to retry. -
	// cancelled: a retry is attempted if the gRPC status code in the
	// response header is set to cancelled. - deadline-exceeded: a retry is
	// attempted if the gRPC status code in the response header is set to
	// deadline-exceeded. - internal: a retry is attempted if the gRPC
	// status code in the response header is set to internal. -
	// resource-exhausted: a retry is attempted if the gRPC status code in
	// the response header is set to resource-exhausted. - unavailable: a
	// retry is attempted if the gRPC status code in the response header is
	// set to unavailable. Only the following codes are supported when the
	// URL map is bound to target gRPC proxy that has validateForProxyless
	// field set to true. - cancelled - deadline-exceeded - internal -
	// resource-exhausted - unavailable
	RetryConditions []string `json:"retryConditions,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpRouteAction is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpRouteAction struct {
	// The specification for allowing client-side cross-origin requests. For
	// more information about the W3C recommendation for cross-origin
	// resource sharing (CORS), see Fetch API Living Standard. Not supported
	// when the URL map is bound to a target gRPC proxy.
	CorsPolicy *CorsPolicy `json:"corsPolicy,omitempty"`
	// The specification for fault injection introduced into traffic to test
	// the resiliency of clients to backend service failure. As part of
	// fault injection, when clients send requests to a backend service,
	// delays can be introduced by a load balancer on a percentage of
	// requests before sending those requests to the backend service.
	// Similarly requests from clients can be aborted by the load balancer
	// for a percentage of requests. timeout and retry_policy is ignored by
	// clients that are configured with a fault_injection_policy if: 1. The
	// traffic is generated by fault injection AND 2. The fault injection is
	// not a delay fault injection. Fault injection is not supported with
	// the classic Application Load Balancer . To see which load balancers
	// support fault injection, see Load balancing: Routing and traffic
	// management features.
	FaultInjectionPolicy *HttpFaultInjection `json:"faultInjectionPolicy,omitempty"`
	// Specifies the maximum duration (timeout) for streams on the selected
	// route. Unlike the timeout field where the timeout duration starts
	// from the time the request has been fully processed (known as
	// *end-of-stream*), the duration in this field is computed from the
	// beginning of the stream until the response has been processed,
	// including all retries. A stream that does not complete in this
	// duration is closed. If not specified, this field uses the maximum
	// maxStreamDuration value among all backend services associated with
	// the route. This field is only allowed if the Url map is used with
	// backend services with loadBalancingScheme set to
	// INTERNAL_SELF_MANAGED.
	MaxStreamDuration *Duration `json:"maxStreamDuration,omitempty"`
	// Specifies the policy on how requests intended for the route's
	// backends are shadowed to a separate mirrored backend service. The
	// load balancer does not wait for responses from the shadow service.
	// Before sending traffic to the shadow service, the host / authority
	// header is suffixed with -shadow. Not supported when the URL map is
	// bound to a target gRPC proxy that has the validateForProxyless field
	// set to true.
	RequestMirrorPolicy *RequestMirrorPolicy `json:"requestMirrorPolicy,omitempty"`
	// Specifies the retry policy associated with this route.
	RetryPolicy *HttpRetryPolicy `json:"retryPolicy,omitempty"`
	// Specifies the timeout for the selected route. Timeout is computed
	// from the time the request has been fully processed (known as
	// *end-of-stream*) up until the response has been processed. Timeout
	// includes all retries. If not specified, this field uses the largest
	// timeout among all backend services associated with the route. Not
	// supported when the URL map is bound to a target gRPC proxy that has
	// validateForProxyless field set to true.
	Timeout *Duration `json:"timeout,omitempty"`
	// The spec to modify the URL of the request, before forwarding the
	// request to the matched service. urlRewrite is the only action
	// supported in UrlMaps for classic Application Load Balancers. Not
	// supported when the URL map is bound to a target gRPC proxy that has
	// the validateForProxyless field set to true.
	UrlRewrite *UrlRewrite `json:"urlRewrite,omitempty"`
	// A list of weighted backend services to send traffic to when a route
	// match occurs. The weights determine the fraction of traffic that
	// flows to their corresponding backend service. If all traffic needs to
	// go to a single backend service, there must be one
	// weightedBackendService with weight set to a non-zero number. After a
	// backend service is identified and before forwarding the request to
	// the backend service, advanced routing actions such as URL rewrites
	// and header transformations are applied depending on additional
	// settings specified in this HttpRouteAction.
	WeightedBackendServices []*WeightedBackendService `json:"weightedBackendServices,omitempty"`
	ForceSendFields         []string                  `json:"-"`
	NullFields              []string                  `json:"-"`
}

// HttpRouteRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpRouteRule struct {
	// customErrorResponsePolicy specifies how the Load Balancer returns
	// error responses when BackendServiceor BackendBucket responds with an
	// error. If a policy for an error code is not configured for the
	// RouteRule, a policy for the error code configured in
	// pathMatcher.defaultCustomErrorResponsePolicy is applied. If one is
	// not specified in pathMatcher.defaultCustomErrorResponsePolicy, the
	// policy configured in UrlMap.defaultCustomErrorResponsePolicy takes
	// effect. For example, consider a UrlMap with the following
	// configuration: - UrlMap.defaultCustomErrorResponsePolicy are
	// configured with policies for 5xx and 4xx errors - A RouteRule for
	// /coming_soon/ is configured for the error code 404. If the request is
	// for www.myotherdomain.com and a 404 is encountered, the policy under
	// UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404
	// response is encountered for the request
	// www.example.com/current_events/, the pathMatcher's policy takes
	// effect. If however, the request for www.example.com/coming_soon/
	// encounters a 404, the policy in RouteRule.customErrorResponsePolicy
	// takes effect. If any of the requests in this example encounter a 500
	// error code, the policy at UrlMap.defaultCustomErrorResponsePolicy
	// takes effect. When used in conjunction with
	// routeRules.routeAction.retryPolicy, retries take precedence. Only
	// once all retries are exhausted, the customErrorResponsePolicy is
	// applied. While attempting a retry, if load balancer is successful in
	// reaching the service, the customErrorResponsePolicy is ignored and
	// the response from the service is returned to the client.
	// customErrorResponsePolicy is supported only for global external
	// Application Load Balancers.
	CustomErrorResponsePolicy *CustomErrorResponsePolicy `json:"customErrorResponsePolicy,omitempty"`
	// The short description conveying the intent of this routeRule. The
	// description can have a maximum length of 1024 characters.
	Description string `json:"description,omitempty"`
	// Specifies changes to request and response headers that need to take
	// effect for the selected backendService. The headerAction value
	// specified here is applied before the matching
	// pathMatchers[].headerAction and after
	// pathMatchers[].routeRules[].routeAction.weightedBackendService.backend
	// ServiceWeightAction[].headerAction HeaderAction is not supported for
	// load balancers that have their loadBalancingScheme set to EXTERNAL.
	// Not supported when the URL map is bound to a target gRPC proxy that
	// has validateForProxyless field set to true.
	HeaderAction *HttpHeaderAction `json:"headerAction,omitempty"`
	// Outbound route specific configuration for networkservices.HttpFilter
	// resources enabled by Traffic Director. httpFilterConfigs only applies
	// for load balancers with loadBalancingScheme set to
	// INTERNAL_SELF_MANAGED. See ForwardingRule for more details. Not
	// supported when the URL map is bound to a target gRPC proxy that has
	// validateForProxyless field set to true.
	HttpFilterConfigs []*HttpFilterConfig `json:"httpFilterConfigs,omitempty"`
	// Outbound route specific metadata supplied to
	// networkservices.HttpFilter resources enabled by Traffic Director.
	// httpFilterMetadata only applies for load balancers with
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED. See ForwardingRule
	// for more details. The only configTypeUrl supported is
	// type.googleapis.com/google.protobuf.Struct Not supported when the URL
	// map is bound to a target gRPC proxy that has validateForProxyless
	// field set to true.
	HttpFilterMetadata []*HttpFilterConfig `json:"httpFilterMetadata,omitempty"`
	// The list of criteria for matching attributes of a request to this
	// routeRule. This list has OR semantics: the request matches this
	// routeRule when any of the matchRules are satisfied. However
	// predicates within a given matchRule have AND semantics. All
	// predicates within a matchRule must match for the request to match the
	// rule.
	MatchRules []*HttpRouteRuleMatch `json:"matchRules,omitempty"`
	// For routeRules within a given pathMatcher, priority determines the
	// order in which a load balancer interprets routeRules. RouteRules are
	// evaluated in order of priority, from the lowest to highest number.
	// The priority of a rule decreases as its number increases (1, 2, 3,
	// N+1). The first rule that matches the request is applied. You cannot
	// configure two or more routeRules with the same priority. Priority for
	// each rule must be set to a number from 0 to 2147483647 inclusive.
	// Priority numbers can have gaps, which enable you to add or remove
	// rules in the future without affecting the rest of the rules. For
	// example, 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority
	// numbers to which you could add rules numbered from 6 to 8, 10 to 11,
	// and 13 to 15 in the future without any impact on existing rules.
	Priority int64 `json:"priority,omitempty"`
	// In response to a matching matchRule, the load balancer performs
	// advanced routing actions, such as URL rewrites and header
	// transformations, before forwarding the request to the selected
	// backend. If routeAction specifies any weightedBackendServices,
	// service must not be set. Conversely if service is set, routeAction
	// cannot contain any weightedBackendServices. Only one of urlRedirect,
	// service or routeAction.weightedBackendService must be set. URL maps
	// for classic Application Load Balancers only support the urlRewrite
	// action within a route rule's routeAction.
	RouteAction *HttpRouteAction `json:"routeAction,omitempty"`
	// The full or partial URL of the backend service resource to which
	// traffic is directed if this rule is matched. If routeAction is also
	// specified, advanced routing actions, such as URL rewrites, take
	// effect before sending the request to the backend. However, if service
	// is specified, routeAction cannot contain any weightedBackendServices.
	// Conversely, if routeAction specifies any weightedBackendServices,
	// service must not be specified. Only one of urlRedirect, service or
	// routeAction.weightedBackendService must be set.
	Service string `json:"service,omitempty"`
	// When this rule is matched, the request is redirected to a URL
	// specified by urlRedirect. If urlRedirect is specified, service or
	// routeAction must not be set. Not supported when the URL map is bound
	// to a target gRPC proxy.
	UrlRedirect     *HttpRedirectAction `json:"urlRedirect,omitempty"`
	ForceSendFields []string            `json:"-"`
	NullFields      []string            `json:"-"`
}

// HttpRouteRuleMatch is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpRouteRuleMatch struct {
	// For satisfying the matchRule condition, the path of the request must
	// exactly match the value specified in fullPathMatch after removing any
	// query parameters and anchor that may be part of the original URL.
	// fullPathMatch must be from 1 to 1024 characters. Only one of
	// prefixMatch, fullPathMatch or regexMatch must be specified.
	FullPathMatch string `json:"fullPathMatch,omitempty"`
	// Specifies a list of header match criteria, all of which must match
	// corresponding headers in the request.
	HeaderMatches []*HttpHeaderMatch `json:"headerMatches,omitempty"`
	// Specifies that prefixMatch and fullPathMatch matches are case
	// sensitive. The default value is false. ignoreCase must not be used
	// with regexMatch. Not supported when the URL map is bound to a target
	// gRPC proxy.
	IgnoreCase bool `json:"ignoreCase,omitempty"`
	// Opaque filter criteria used by the load balancer to restrict routing
	// configuration to a limited set of xDS compliant clients. In their xDS
	// requests to the load balancer, xDS clients present node metadata.
	// When there is a match, the relevant routing configuration is made
	// available to those proxies. For each metadataFilter in this list, if
	// its filterMatchCriteria is set to MATCH_ANY, at least one of the
	// filterLabels must match the corresponding label provided in the
	// metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of
	// its filterLabels must match with corresponding labels provided in the
	// metadata. If multiple metadata filters are specified, all of them
	// need to be satisfied in order to be considered a match.
	// metadataFilters specified here is applied after those specified in
	// ForwardingRule that refers to the UrlMap this HttpRouteRuleMatch
	// belongs to. metadataFilters only applies to load balancers that have
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED. Not supported when
	// the URL map is bound to a target gRPC proxy that has
	// validateForProxyless field set to true.
	MetadataFilters []*MetadataFilter `json:"metadataFilters,omitempty"`
	// If specified, the route is a pattern match expression that must match
	// the :path header once the query string is removed. A pattern match
	// allows you to match - The value must be between 1 and 1024 characters
	// - The pattern must start with a leading slash ("/") - There may be no
	// more than 5 operators in pattern Precisely one of prefix_match,
	// full_path_match, regex_match or path_template_match must be set.
	PathTemplateMatch string `json:"pathTemplateMatch,omitempty"`
	// For satisfying the matchRule condition, the request's path must begin
	// with the specified prefixMatch. prefixMatch must begin with a /. The
	// value must be from 1 to 1024 characters. Only one of prefixMatch,
	// fullPathMatch or regexMatch must be specified.
	PrefixMatch string `json:"prefixMatch,omitempty"`
	// Specifies a list of query parameter match criteria, all of which must
	// match corresponding query parameters in the request. Not supported
	// when the URL map is bound to a target gRPC proxy.
	QueryParameterMatches []*HttpQueryParameterMatch `json:"queryParameterMatches,omitempty"`
	// For satisfying the matchRule condition, the path of the request must
	// satisfy the regular expression specified in regexMatch after removing
	// any query parameters and anchor supplied with the original URL. For
	// more information about regular expression syntax, see Syntax. Only
	// one of prefixMatch, fullPathMatch or regexMatch must be specified.
	// Regular expressions can only be used when the loadBalancingScheme is
	// set to INTERNAL_SELF_MANAGED.
	RegexMatch      string   `json:"regexMatch,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// Int64RangeMatch is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Int64RangeMatch struct {
	// The end of the range (exclusive) in signed long integer format.
	RangeEnd int64 `json:"rangeEnd,omitempty,string"`
	// The start of the range (inclusive) in signed long integer format.
	RangeStart      int64    `json:"rangeStart,omitempty,string"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// Jwt is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Jwt struct {
	// A JWT containing any of these audiences will be accepted. The service
	// name will be accepted if audiences is empty. Examples:
	// bookstore_android.apps.googleusercontent.com,
	// bookstore_web.apps.googleusercontent.com
	Audiences []string `json:"audiences,omitempty"`
	// Identifies the issuer that issued the JWT, which is usually a URL or
	// an email address. Examples: https://securetoken.google.com,
	// 1234567-compute@developer.gserviceaccount.com
	Issuer string `json:"issuer,omitempty"`
	// The provider's public key set to validate the signature of the JWT.
	JwksPublicKeys string `json:"jwksPublicKeys,omitempty"`
	// jwt_headers and jwt_params define where to extract the JWT from an
	// HTTP request. If no explicit location is specified, the following
	// default locations are tried in order: 1. The Authorization header
	// using the Bearer schema. See `here `_. Example: Authorization: Bearer
	// . 2. `access_token` query parameter. See `this `_ Multiple JWTs can
	// be verified for a request. Each JWT has to be extracted from the
	// locations its issuer specified or from the default locations. This
	// field is set if JWT is sent in a request header. This field specifies
	// the header name. For example, if `header=x-goog-iap-jwt-assertion`,
	// the header format will be x-goog-iap-jwt-assertion: .
	JwtHeaders []*JwtHeader `json:"jwtHeaders,omitempty"`
	// This field is set if JWT is sent in a query parameter. This field
	// specifies the query parameter name. For example, if jwt_params[0] is
	// jwt_token, the JWT format in the query parameter is /path?jwt_token=.
	JwtParams       []string `json:"jwtParams,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// JwtHeader is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type JwtHeader struct {
	// The HTTP header name.
	Name string `json:"name,omitempty"`
	// The value prefix. The value format is "value_prefix" For example, for
	// "Authorization: Bearer ", value_prefix="Bearer " with a space at the
	// end.
	ValuePrefix     string   `json:"valuePrefix,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// MetadataCredentialsFromPlugin is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type MetadataCredentialsFromPlugin struct {
	// Plugin name.
	Name string `json:"name,omitempty"`
	// A text proto that conforms to a Struct type definition interpreted by
	// the plugin.
	StructConfig    string   `json:"structConfig,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// MetadataFilter is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type MetadataFilter struct {
	// The list of label value pairs that must match labels in the provided
	// metadata based on filterMatchCriteria This list must not be empty and
	// can have at the most 64 entries.
	FilterLabels []*MetadataFilterLabelMatch `json:"filterLabels,omitempty"`
	// Specifies how individual filter label matches within the list of
	// filterLabels and contributes toward the overall metadataFilter match.
	// Supported values are: - MATCH_ANY: at least one of the filterLabels
	// must have a matching label in the provided metadata. - MATCH_ALL: all
	// filterLabels must have matching labels in the provided metadata.
	FilterMatchCriteria string   `json:"filterMatchCriteria,omitempty"`
	ForceSendFields     []string `json:"-"`
	NullFields          []string `json:"-"`
}

// MetadataFilterLabelMatch is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type MetadataFilterLabelMatch struct {
	// Name of metadata label. The name can have a maximum length of 1024
	// characters and must be at least 1 character long.
	Name string `json:"name,omitempty"`
	// The value of the label must match the specified value. value can have
	// a maximum length of 1024 characters.
	Value           string   `json:"value,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// MutualTls is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type MutualTls struct {
	// Specifies if the server TLS is configured to be strict or permissive.
	// This field can be set to one of the following: STRICT: Client
	// certificate must be presented, connection is in TLS. PERMISSIVE:
	// Client certificate can be omitted, connection can be either plaintext
	// or TLS.
	Mode            string   `json:"mode,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpoint is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpoint struct {
	// Version keeps track of the intended compute version for this NetworkEndpoint.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// Metadata defined as annotations on the network endpoint.
	Annotations map[string]string `json:"annotations,omitempty"`
	// Represents the port number to which PSC consumer sends packets. Only
	// valid for network endpoint groups created with GCE_VM_IP_PORTMAP
	// endpoint type.
	ClientDestinationPort int64 `json:"clientDestinationPort,omitempty"`
	// Represents the port number to which PSC consumer sends packets. Only
	// valid for network endpoint groups created with
	// CLIENT_PORT_PER_ENDPOINT mapping mode.
	ClientPort int64 `json:"clientPort,omitempty"`
	// Optional fully qualified domain name of network endpoint. This can
	// only be specified when NetworkEndpointGroup.network_endpoint_type is
	// NON_GCP_FQDN_PORT.
	Fqdn string `json:"fqdn,omitempty"`
	// The name or a URL of VM instance of this network endpoint. This field
	// is required for network endpoints of type GCE_VM_IP and
	// GCE_VM_IP_PORT. The instance must be in the same zone of network
	// endpoint group (for zonal NEGs) or in the zone within the region of
	// the NEG (for regional NEGs). If the ipAddress is specified, it must
	// belongs to the VM instance. The name must be 1-63 characters long,
	// and comply with RFC1035 or be a valid URL pointing to an existing
	// instance.
	Instance string `json:"instance,omitempty"`
	// Optional IPv4 address of network endpoint. The IP address must belong
	// to a VM in Compute Engine (either the primary IP or as part of an
	// aliased IP range). If the IP address is not specified, then the
	// primary IP address for the VM instance in the network that the
	// network endpoint group belongs to will be used. This field is
	// redundant and need not be set for network endpoints of type
	// GCE_VM_IP. If set, it must be set to the primary internal IP address
	// of the attached VM instance that matches the subnetwork of the NEG.
	// The primary internal IP address from any NIC of a multi-NIC VM
	// instance can be added to a NEG as long as it matches the NEG
	// subnetwork.
	IpAddress string `json:"ipAddress,omitempty"`
	// Optional IPv6 address of network endpoint.
	Ipv6Address string `json:"ipv6Address,omitempty"`
	// Optional port number of network endpoint. If not specified, the
	// defaultPort for the network endpoint group will be used. This field
	// can not be set for network endpoints of type GCE_VM_IP.
	Port int64 `json:"port,omitempty"`
	// The name of the zone where the instance hosting the network endpoint
	// is located (valid only for regional GCE_VM_IP_PORT NEGs). It should
	// comply with RFC1035. The zone must belong to the region of the
	// Network Endpoint Group.
	Zone            string   `json:"zone,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroup is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroup struct {
	// Version keeps track of the intended compute version for this NetworkEndpointGroup.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// Metadata defined as annotations on the network endpoint group.
	Annotations map[string]string `json:"annotations,omitempty"`
	// Only valid when networkEndpointType is SERVERLESS. Only one of
	// cloudRun, appEngine or cloudFunction may be set.
	AppEngine *NetworkEndpointGroupAppEngine `json:"appEngine,omitempty"`
	// Only valid when networkEndpointType is GCE_VM_IP_PORT and the NEG is
	// regional.
	ClientPortMappingMode string `json:"clientPortMappingMode,omitempty"`
	// Only valid when networkEndpointType is SERVERLESS. Only one of
	// cloudRun, appEngine or cloudFunction may be set.
	CloudFunction *NetworkEndpointGroupCloudFunction `json:"cloudFunction,omitempty"`
	// Only valid when networkEndpointType is SERVERLESS. Only one of
	// cloudRun, appEngine or cloudFunction may be set.
	CloudRun *NetworkEndpointGroupCloudRun `json:"cloudRun,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// The default port used if the port number is not specified in the
	// network endpoint. If the network endpoint type is either GCE_VM_IP,
	// SERVERLESS or PRIVATE_SERVICE_CONNECT, this field must not be
	// specified.
	DefaultPort int64 `json:"defaultPort,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of the resource. Always
	// compute#networkEndpointGroup for network endpoint group.
	Kind string `json:"kind,omitempty"`
	// This field is only valid when the network endpoint group is used for
	// load balancing. [Deprecated] This field is deprecated.
	LoadBalancer *NetworkEndpointGroupLbNetworkEndpointGroup `json:"loadBalancer,omitempty"`
	// Name of the resource; provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// The URL of the network to which all network endpoints in the NEG
	// belong. Uses default project network if unspecified.
	Network string `json:"network,omitempty"`
	// Type of network endpoints in this network endpoint group. Can be one
	// of GCE_VM_IP, GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT,
	// INTERNET_FQDN_PORT, INTERNET_IP_PORT, SERVERLESS,
	// PRIVATE_SERVICE_CONNECT, GCE_VM_IP_PORTMAP.
	NetworkEndpointType string                       `json:"networkEndpointType,omitempty"`
	PscData             *NetworkEndpointGroupPscData `json:"pscData,omitempty"`
	// The target service url used to set up private service connection to a
	// Google API or a PSC Producer Service Attachment. An example value is:
	// asia-northeast3-cloudkms.googleapis.com
	PscTargetService string `json:"pscTargetService,omitempty"`
	// [Output Only] The URL of the region where the network endpoint group
	// is located.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// Only valid when networkEndpointType is SERVERLESS. Only one of
	// cloudRun, appEngine, cloudFunction or serverlessDeployment may be
	// set.
	ServerlessDeployment *NetworkEndpointGroupServerlessDeployment `json:"serverlessDeployment,omitempty"`
	// [Output only] Number of network endpoints in the network endpoint
	// group.
	Size int64 `json:"size,omitempty"`
	// Optional URL of the subnetwork to which all network endpoints in the
	// NEG belong.
	Subnetwork string `json:"subnetwork,omitempty"`
	// Specify the type of this network endpoint group. Only LOAD_BALANCING
	// is valid for now.
	Type string `json:"type,omitempty"`
	// [Output Only] The URL of the zone where the network endpoint group is
	// located.
	Zone                     string `json:"zone,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// NetworkEndpointGroupAppEngine is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupAppEngine struct {
	// Optional serving service. The service name is case-sensitive and must
	// be 1-63 characters long. Example value: default, my-service.
	Service string `json:"service,omitempty"`
	// An URL mask is one of the main components of the Cloud Function. A
	// template to parse service and version fields from a request URL. URL
	// mask allows for routing to multiple App Engine services without
	// having to create multiple Network Endpoint Groups and backend
	// services. For example, the request URLs
	// foo1-dot-appname.appspot.com/v1 and foo1-dot-appname.appspot.com/v2
	// can be backed by the same Serverless NEG with URL mask
	// <service>-dot-appname.appspot.com/<version>. The URL mask will parse
	// them to { service = "foo1", version = "v1" } and { service = "foo1",
	// version = "v2" } respectively.
	UrlMask string `json:"urlMask,omitempty"`
	// Optional serving version. The version name is case-sensitive and must
	// be 1-100 characters long. Example value: v1, v2.
	Version         string   `json:"version,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupCloudFunction is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupCloudFunction struct {
	// A user-defined name of the Cloud Function. The function name is
	// case-sensitive and must be 1-63 characters long. Example value:
	// func1.
	Function string `json:"function,omitempty"`
	// An URL mask is one of the main components of the Cloud Function. A
	// template to parse function field from a request URL. URL mask allows
	// for routing to multiple Cloud Functions without having to create
	// multiple Network Endpoint Groups and backend services. For example,
	// request URLs mydomain.com/function1 and mydomain.com/function2 can be
	// backed by the same Serverless NEG with URL mask /<function>. The URL
	// mask will parse them to { function = "function1" } and { function =
	// "function2" } respectively.
	UrlMask         string   `json:"urlMask,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupCloudRun is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupCloudRun struct {
	// Cloud Run service is the main resource of Cloud Run. The service must
	// be 1-63 characters long, and comply with RFC1035. Example value:
	// "run-service".
	Service string `json:"service,omitempty"`
	// Optional Cloud Run tag represents the "named-revision" to provide
	// additional fine-grained traffic routing information. The tag must be
	// 1-63 characters long, and comply with RFC1035. Example value:
	// "revision-0010".
	Tag string `json:"tag,omitempty"`
	// An URL mask is one of the main components of the Cloud Function. A
	// template to parse <service> and <tag> fields from a request URL. URL
	// mask allows for routing to multiple Run services without having to
	// create multiple network endpoint groups and backend services. For
	// example, request URLs foo1.domain.com/bar1 and foo1.domain.com/bar2
	// can be backed by the same Serverless Network Endpoint Group (NEG)
	// with URL mask <tag>.domain.com/<service>. The URL mask will parse
	// them to { service="bar1", tag="foo1" } and { service="bar2",
	// tag="foo2" } respectively.
	UrlMask         string   `json:"urlMask,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupLbNetworkEndpointGroup is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupLbNetworkEndpointGroup struct {
	// The default port used if the port number is not specified in the
	// network endpoint. If the network endpoint type is either GCE_VM_IP,
	// SERVERLESS or PRIVATE_SERVICE_CONNECT, this field must not be
	// specified. [Deprecated] This field is deprecated.
	DefaultPort int64 `json:"defaultPort,omitempty"`
	// The URL of the network to which all network endpoints in the NEG
	// belong. Uses default project network if unspecified. [Deprecated]
	// This field is deprecated.
	Network string `json:"network,omitempty"`
	// Optional URL of the subnetwork to which all network endpoints in the
	// NEG belong. [Deprecated] This field is deprecated.
	Subnetwork string `json:"subnetwork,omitempty"`
	// [Output Only] The URL of the zone where the network endpoint group is
	// located. [Deprecated] This field is deprecated.
	Zone            string   `json:"zone,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupPscData is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupPscData struct {
	// [Output Only] Address allocated from given subnetwork for PSC. This
	// IP address acts as a VIP for a PSC NEG, allowing it to act as an
	// endpoint in L7 PSC-XLB.
	ConsumerPscAddress string `json:"consumerPscAddress,omitempty"`
	// The psc producer port is used to connect PSC NEG with specific port
	// on the PSC Producer side; should only be used for the
	// PRIVATE_SERVICE_CONNECT NEG type
	ProducerPort int64 `json:"producerPort,omitempty"`
	// [Output Only] The PSC connection id of the PSC Network Endpoint Group
	// Consumer.
	PscConnectionId uint64 `json:"pscConnectionId,omitempty,string"`
	// [Output Only] The connection status of the PSC Forwarding Rule.
	PscConnectionStatus string   `json:"pscConnectionStatus,omitempty"`
	ForceSendFields     []string `json:"-"`
	NullFields          []string `json:"-"`
}

// NetworkEndpointGroupServerlessDeployment is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupServerlessDeployment struct {
	// The platform of the backend target(s) of this NEG. The only supported
	// value is API Gateway: apigateway.googleapis.com.
	Platform string `json:"platform,omitempty"`
	// The user-defined name of the workload/instance. This value must be
	// provided explicitly or in the urlMask. The resource identified by
	// this value is platform-specific and is as follows: 1. API Gateway:
	// The gateway ID 2. App Engine: The service name 3. Cloud Functions:
	// The function name 4. Cloud Run: The service name
	Resource string `json:"resource,omitempty"`
	// An URL mask is one of the main components of the Cloud Function. A
	// template to parse platform-specific fields from a request URL. URL
	// mask allows for routing to multiple resources on the same serverless
	// platform without having to create multiple Network Endpoint Groups
	// and backend resources. The fields parsed by this template are
	// platform-specific and are as follows: 1. API Gateway: The gateway ID
	// 2. App Engine: The service and version 3. Cloud Functions: The
	// function name 4. Cloud Run: The service and tag
	UrlMask string `json:"urlMask,omitempty"`
	// The optional resource version. The version identified by this value
	// is platform-specific and is follows: 1. API Gateway: Unused 2. App
	// Engine: The service version 3. Cloud Functions: Unused 4. Cloud Run:
	// The service tag
	Version         string   `json:"version,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupsAttachEndpointsRequest is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupsAttachEndpointsRequest struct {
	// Version keeps track of the intended compute version for this NetworkEndpointGroupsAttachEndpointsRequest.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// The list of network endpoints to be attached.
	NetworkEndpoints []*NetworkEndpoint `json:"networkEndpoints,omitempty"`
	ForceSendFields  []string           `json:"-"`
	NullFields       []string           `json:"-"`
}

// NetworkEndpointGroupsDetachEndpointsRequest is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupsDetachEndpointsRequest struct {
	// Version keeps track of the intended compute version for this NetworkEndpointGroupsDetachEndpointsRequest.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// The list of network endpoints to be detached.
	NetworkEndpoints []*NetworkEndpoint `json:"networkEndpoints,omitempty"`
	ForceSendFields  []string           `json:"-"`
	NullFields       []string           `json:"-"`
}

// NetworkEndpointGroupsListEndpointsRequest is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupsListEndpointsRequest struct {
	// Version keeps track of the intended compute version for this NetworkEndpointGroupsListEndpointsRequest.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// Optional list of endpoints to query. This is a more efficient but
	// also limited version of filter parameter. Endpoints in the filter
	// must have ip_address and port fields populated, other fields are not
	// supported.
	EndpointFilters []*NetworkEndpointGroupsListEndpointsRequestNetworkEndpointFilter `json:"endpointFilters,omitempty"`
	// Optional query parameter for showing the health status of each
	// network endpoint. Valid options are SKIP or SHOW. If you don't
	// specify this parameter, the health status of network endpoints will
	// not be provided.
	HealthStatus    string   `json:"healthStatus,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupsListEndpointsRequestNetworkEndpointFilter is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupsListEndpointsRequestNetworkEndpointFilter struct {
	NetworkEndpoint *NetworkEndpoint `json:"networkEndpoint,omitempty"`
	ForceSendFields []string         `json:"-"`
	NullFields      []string         `json:"-"`
}

// NetworkEndpointWithHealthStatus is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointWithHealthStatus struct {
	// Version keeps track of the intended compute version for this NetworkEndpointWithHealthStatus.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// [Output only] The health status of network endpoint;
	Healths []*HealthStatusForNetworkEndpoint `json:"healths,omitempty"`
	// [Output only] The network endpoint;
	NetworkEndpoint *NetworkEndpoint `json:"networkEndpoint,omitempty"`
	ForceSendFields []string         `json:"-"`
	NullFields      []string         `json:"-"`
}

// OriginAuthenticationMethod is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type OriginAuthenticationMethod struct {
	Jwt             *Jwt     `json:"jwt,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// OutlierDetection is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type OutlierDetection struct {
	// The base time that a backend endpoint is ejected for. Defaults to
	// 30000ms or 30s. After a backend endpoint is returned back to the load
	// balancing pool, it can be ejected again in another ejection analysis.
	// Thus, the total ejection time is equal to the base ejection time
	// multiplied by the number of times the backend endpoint has been
	// ejected. Defaults to 30000ms or 30s.
	BaseEjectionTime *Duration `json:"baseEjectionTime,omitempty"`
	// Number of consecutive errors before a backend endpoint is ejected
	// from the load balancing pool. When the backend endpoint is accessed
	// over HTTP, a 5xx return code qualifies as an error. Defaults to 5.
	ConsecutiveErrors int64 `json:"consecutiveErrors,omitempty"`
	// The number of consecutive gateway failures (502, 503, 504 status or
	// connection errors that are mapped to one of those status codes)
	// before a consecutive gateway failure ejection occurs. Defaults to 3.
	ConsecutiveGatewayFailure int64 `json:"consecutiveGatewayFailure,omitempty"`
	// The percentage chance that a backend endpoint will be ejected when an
	// outlier status is detected through consecutive 5xx. This setting can
	// be used to disable ejection or to ramp it up slowly. Defaults to 0.
	EnforcingConsecutiveErrors int64 `json:"enforcingConsecutiveErrors,omitempty"`
	// The percentage chance that a backend endpoint will be ejected when an
	// outlier status is detected through consecutive gateway failures. This
	// setting can be used to disable ejection or to ramp it up slowly.
	// Defaults to 100.
	EnforcingConsecutiveGatewayFailure int64 `json:"enforcingConsecutiveGatewayFailure,omitempty"`
	// The percentage chance that a backend endpoint will be ejected when an
	// outlier status is detected through success rate statistics. This
	// setting can be used to disable ejection or to ramp it up slowly.
	// Defaults to 100. Not supported when the backend service uses
	// Serverless NEG.
	EnforcingSuccessRate int64 `json:"enforcingSuccessRate,omitempty"`
	// Time interval between ejection analysis sweeps. This can result in
	// both new ejections and backend endpoints being returned to service.
	// The interval is equal to the number of seconds as defined in
	// outlierDetection.interval.seconds plus the number of nanoseconds as
	// defined in outlierDetection.interval.nanos. Defaults to 1 second.
	Interval *Duration `json:"interval,omitempty"`
	// Maximum percentage of backend endpoints in the load balancing pool
	// for the backend service that can be ejected if the ejection
	// conditions are met. Defaults to 50%.
	MaxEjectionPercent int64 `json:"maxEjectionPercent,omitempty"`
	// The number of backend endpoints in the load balancing pool that must
	// have enough request volume to detect success rate outliers. If the
	// number of backend endpoints is fewer than this setting, outlier
	// detection via success rate statistics is not performed for any
	// backend endpoint in the load balancing pool. Defaults to 5. Not
	// supported when the backend service uses Serverless NEG.
	SuccessRateMinimumHosts int64 `json:"successRateMinimumHosts,omitempty"`
	// The minimum number of total requests that must be collected in one
	// interval (as defined by the interval duration above) to include this
	// backend endpoint in success rate based outlier detection. If the
	// volume is lower than this setting, outlier detection via success rate
	// statistics is not performed for that backend endpoint. Defaults to
	// 100. Not supported when the backend service uses Serverless NEG.
	SuccessRateRequestVolume int64 `json:"successRateRequestVolume,omitempty"`
	// This factor is used to determine the ejection threshold for success
	// rate outlier ejection. The ejection threshold is the difference
	// between the mean success rate, and the product of this factor and the
	// standard deviation of the mean success rate: mean - (stdev *
	// successRateStdevFactor). This factor is divided by a thousand to get
	// a double. That is, if the desired factor is 1.9, the runtime value
	// should be 1900. Defaults to 1900. Not supported when the backend
	// service uses Serverless NEG.
	SuccessRateStdevFactor int64    `json:"successRateStdevFactor,omitempty"`
	ForceSendFields        []string `json:"-"`
	NullFields             []string `json:"-"`
}

// PathMatcher is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PathMatcher struct {
	// defaultCustomErrorResponsePolicy specifies how the Load Balancer
	// returns error responses when BackendServiceor BackendBucket responds
	// with an error. This policy takes effect at the PathMatcher level and
	// applies only when no policy has been defined for the error code at
	// lower levels like RouteRule and PathRule within this PathMatcher. If
	// an error code does not have a policy defined in
	// defaultCustomErrorResponsePolicy, then a policy defined for the error
	// code in UrlMap.defaultCustomErrorResponsePolicy takes effect. For
	// example, consider a UrlMap with the following configuration: -
	// UrlMap.defaultCustomErrorResponsePolicy is configured with policies
	// for 5xx and 4xx errors - A RouteRule for /coming_soon/ is configured
	// for the error code 404. If the request is for www.myotherdomain.com
	// and a 404 is encountered, the policy under
	// UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404
	// response is encountered for the request
	// www.example.com/current_events/, the pathMatcher's policy takes
	// effect. If however, the request for www.example.com/coming_soon/
	// encounters a 404, the policy in RouteRule.customErrorResponsePolicy
	// takes effect. If any of the requests in this example encounter a 500
	// error code, the policy at UrlMap.defaultCustomErrorResponsePolicy
	// takes effect. When used in conjunction with
	// pathMatcher.defaultRouteAction.retryPolicy, retries take precedence.
	// Only once all retries are exhausted, the
	// defaultCustomErrorResponsePolicy is applied. While attempting a
	// retry, if load balancer is successful in reaching the service, the
	// defaultCustomErrorResponsePolicy is ignored and the response from the
	// service is returned to the client. defaultCustomErrorResponsePolicy
	// is supported only for global external Application Load Balancers.
	DefaultCustomErrorResponsePolicy *CustomErrorResponsePolicy `json:"defaultCustomErrorResponsePolicy,omitempty"`
	// defaultRouteAction takes effect when none of the pathRules or
	// routeRules match. The load balancer performs advanced routing
	// actions, such as URL rewrites and header transformations, before
	// forwarding the request to the selected backend. If defaultRouteAction
	// specifies any weightedBackendServices, defaultService must not be
	// set. Conversely if defaultService is set, defaultRouteAction cannot
	// contain any weightedBackendServices. If defaultRouteAction is
	// specified, don't set defaultUrlRedirect. If
	// defaultRouteAction.weightedBackendServices is specified, don't set
	// defaultService. URL maps for classic Application Load Balancers only
	// support the urlRewrite action within a path matcher's
	// defaultRouteAction.
	DefaultRouteAction *HttpRouteAction `json:"defaultRouteAction,omitempty"`
	// The full or partial URL to the BackendService resource. This URL is
	// used if none of the pathRules or routeRules defined by this
	// PathMatcher are matched. For example, the following are all valid
	// URLs to a BackendService resource: -
	// https://www.googleapis.com/compute/v1/projects/project
	// /global/backendServices/backendService -
	// compute/v1/projects/project/global/backendServices/backendService -
	// global/backendServices/backendService If defaultRouteAction is also
	// specified, advanced routing actions, such as URL rewrites, take
	// effect before sending the request to the backend. However, if
	// defaultService is specified, defaultRouteAction cannot contain any
	// weightedBackendServices. Conversely, if defaultRouteAction specifies
	// any weightedBackendServices, defaultService must not be specified. If
	// defaultService is specified, then set either defaultUrlRedirect or
	// defaultRouteAction.weightedBackendService. Don't set both.
	// Authorization requires one or more of the following Google IAM
	// permissions on the specified resource default_service: -
	// compute.backendBuckets.use - compute.backendServices.use
	DefaultService string `json:"defaultService,omitempty"`
	// When none of the specified pathRules or routeRules match, the request
	// is redirected to a URL specified by defaultUrlRedirect. If
	// defaultUrlRedirect is specified, then set either defaultService or
	// defaultRouteAction. Don't set both. Not supported when the URL map is
	// bound to a target gRPC proxy.
	DefaultUrlRedirect *HttpRedirectAction `json:"defaultUrlRedirect,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Specifies changes to request and response headers that need to take
	// effect for the selected backend service. HeaderAction specified here
	// are applied after the matching HttpRouteRule HeaderAction and before
	// the HeaderAction in the UrlMap HeaderAction is not supported for load
	// balancers that have their loadBalancingScheme set to EXTERNAL. Not
	// supported when the URL map is bound to a target gRPC proxy that has
	// validateForProxyless field set to true.
	HeaderAction *HttpHeaderAction `json:"headerAction,omitempty"`
	// The name to which this PathMatcher is referred by the HostRule.
	Name string `json:"name,omitempty"`
	// The list of path rules. Use this list instead of routeRules when
	// routing based on simple path matching is all that's required. The
	// order by which path rules are specified does not matter. Matches are
	// always done on the longest-path-first basis. For example: a pathRule
	// with a path /a/b/c/* will match before /a/b/* irrespective of the
	// order in which those paths appear in this list. Within a given
	// pathMatcher, only one of pathRules or routeRules must be set.
	PathRules []*PathRule `json:"pathRules,omitempty"`
	// The list of HTTP route rules. Use this list instead of pathRules when
	// advanced route matching and routing actions are desired. routeRules
	// are evaluated in order of priority, from the lowest to highest
	// number. Within a given pathMatcher, you can set only one of pathRules
	// or routeRules.
	RouteRules      []*HttpRouteRule `json:"routeRules,omitempty"`
	ForceSendFields []string         `json:"-"`
	NullFields      []string         `json:"-"`
}

// PathRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PathRule struct {
	// customErrorResponsePolicy specifies how the Load Balancer returns
	// error responses when BackendServiceor BackendBucket responds with an
	// error. If a policy for an error code is not configured for the
	// PathRule, a policy for the error code configured in
	// pathMatcher.defaultCustomErrorResponsePolicy is applied. If one is
	// not specified in pathMatcher.defaultCustomErrorResponsePolicy, the
	// policy configured in UrlMap.defaultCustomErrorResponsePolicy takes
	// effect. For example, consider a UrlMap with the following
	// configuration: - UrlMap.defaultCustomErrorResponsePolicy are
	// configured with policies for 5xx and 4xx errors - A PathRule for
	// /coming_soon/ is configured for the error code 404. If the request is
	// for www.myotherdomain.com and a 404 is encountered, the policy under
	// UrlMap.defaultCustomErrorResponsePolicy takes effect. If a 404
	// response is encountered for the request
	// www.example.com/current_events/, the pathMatcher's policy takes
	// effect. If however, the request for www.example.com/coming_soon/
	// encounters a 404, the policy in PathRule.customErrorResponsePolicy
	// takes effect. If any of the requests in this example encounter a 500
	// error code, the policy at UrlMap.defaultCustomErrorResponsePolicy
	// takes effect. customErrorResponsePolicy is supported only for global
	// external Application Load Balancers.
	CustomErrorResponsePolicy *CustomErrorResponsePolicy `json:"customErrorResponsePolicy,omitempty"`
	// The list of path patterns to match. Each must start with / and the
	// only place a * is allowed is at the end following a /. The string fed
	// to the path matcher does not include any text after the first ? or #,
	// and those chars are not allowed here.
	Paths []string `json:"paths,omitempty"`
	// In response to a matching path, the load balancer performs advanced
	// routing actions, such as URL rewrites and header transformations,
	// before forwarding the request to the selected backend. If routeAction
	// specifies any weightedBackendServices, service must not be set.
	// Conversely if service is set, routeAction cannot contain any
	// weightedBackendServices. Only one of routeAction or urlRedirect must
	// be set. URL maps for classic Application Load Balancers only support
	// the urlRewrite action within a path rule's routeAction.
	RouteAction *HttpRouteAction `json:"routeAction,omitempty"`
	// The full or partial URL of the backend service resource to which
	// traffic is directed if this rule is matched. If routeAction is also
	// specified, advanced routing actions, such as URL rewrites, take
	// effect before sending the request to the backend. However, if service
	// is specified, routeAction cannot contain any weightedBackendServices.
	// Conversely, if routeAction specifies any weightedBackendServices,
	// service must not be specified. Only one of urlRedirect, service or
	// routeAction.weightedBackendService must be set.
	Service string `json:"service,omitempty"`
	// When a path pattern is matched, the request is redirected to a URL
	// specified by urlRedirect. If urlRedirect is specified, service or
	// routeAction must not be set. Not supported when the URL map is bound
	// to a target gRPC proxy.
	UrlRedirect     *HttpRedirectAction `json:"urlRedirect,omitempty"`
	ForceSendFields []string            `json:"-"`
	NullFields      []string            `json:"-"`
}

// PeerAuthenticationMethod is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PeerAuthenticationMethod struct {
	// Set if mTLS is used for peer authentication.
	Mtls            *MutualTls `json:"mtls,omitempty"`
	ForceSendFields []string   `json:"-"`
	NullFields      []string   `json:"-"`
}

// Permission is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Permission struct {
	// Extra custom constraints. The constraints are ANDed together.
	Constraints []*PermissionConstraint `json:"constraints,omitempty"`
	// Used in Ingress or Egress Gateway cases to specify hosts that the
	// policy applies to. Exact match, prefix match, and suffix match are
	// supported.
	Hosts []string `json:"hosts,omitempty"`
	// HTTP method.
	Methods []string `json:"methods,omitempty"`
	// Negate of hosts. Specifies exclusions.
	NotHosts []string `json:"notHosts,omitempty"`
	// Negate of methods. Specifies exclusions.
	NotMethods []string `json:"notMethods,omitempty"`
	// Negate of paths. Specifies exclusions.
	NotPaths []string `json:"notPaths,omitempty"`
	// Negate of ports. Specifies exclusions.
	NotPorts []string `json:"notPorts,omitempty"`
	// HTTP request paths or gRPC methods. Exact match, prefix match, and
	// suffix match are supported.
	Paths []string `json:"paths,omitempty"`
	// Port names or numbers.
	Ports           []string `json:"ports,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// PermissionConstraint is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PermissionConstraint struct {
	// Key of the constraint.
	Key string `json:"key,omitempty"`
	// A list of allowed values.
	Values          []string `json:"values,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// Principal is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Principal struct {
	// An expression to specify custom condition.
	Condition string `json:"condition,omitempty"`
	// The groups the principal belongs to. Exact match, prefix match, and
	// suffix match are supported.
	Groups []string `json:"groups,omitempty"`
	// IPv4 or IPv6 address or range (In CIDR format)
	Ips []string `json:"ips,omitempty"`
	// The namespaces. Exact match, prefix match, and suffix match are
	// supported.
	Namespaces []string `json:"namespaces,omitempty"`
	// Negate of groups. Specifies exclusions.
	NotGroups []string `json:"notGroups,omitempty"`
	// Negate of IPs. Specifies exclusions.
	NotIps []string `json:"notIps,omitempty"`
	// Negate of namespaces. Specifies exclusions.
	NotNamespaces []string `json:"notNamespaces,omitempty"`
	// Negate of users. Specifies exclusions.
	NotUsers []string `json:"notUsers,omitempty"`
	// A map of Istio attribute to expected values. Exact match, prefix
	// match, and suffix match are supported for values. For example,
	// `request.headers[version]: "v1". The properties are ANDed together.
	Properties map[string]string `json:"properties,omitempty"`
	// The user names/IDs or service accounts. Exact match, prefix match,
	// and suffix match are supported.
	Users           []string `json:"users,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// RbacPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type RbacPolicy struct {
	// Name of the RbacPolicy.
	Name string `json:"name,omitempty"`
	// The list of permissions.
	Permissions []*Permission `json:"permissions,omitempty"`
	// The list of principals.
	Principals      []*Principal `json:"principals,omitempty"`
	ForceSendFields []string     `json:"-"`
	NullFields      []string     `json:"-"`
}

// RequestMirrorPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type RequestMirrorPolicy struct {
	// The full or partial URL to the BackendService resource being mirrored
	// to. The backend service configured for a mirroring policy must
	// reference backends that are of the same type as the original backend
	// service matched in the URL map. Serverless NEG backends are not
	// currently supported as a mirrored backend service.
	BackendService  string   `json:"backendService,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// SSLHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SSLHealthCheck struct {
	// The TCP port number to which the health check prober sends packets.
	// The default value is 443. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Not supported.
	PortName string `json:"portName,omitempty"`
	// Specifies how a port is selected for health checking. Can be one of
	// the following values: USE_FIXED_PORT: Specifies a port number
	// explicitly using the port field in the health check. Supported by
	// backend services for passthrough load balancers and backend services
	// for proxy load balancers. Not supported by target pools. The health
	// check supports all backends supported by the backend service provided
	// the backend can be health checked. For example, GCE_VM_IP network
	// endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance
	// group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT:
	// Provides an indirect method of specifying the health check port by
	// referring to the backend service. Only supported by backend services
	// for proxy load balancers. Not supported by target pools. Not
	// supported by backend services for passthrough load balancers.
	// Supports all backends that can be health checked; for example,
	// GCE_VM_IP_PORT network endpoint groups and instance group backends.
	// For GCE_VM_IP_PORT network endpoint group backends, the health check
	// uses the port number specified for each endpoint in the network
	// endpoint group. For instance group backends, the health check uses
	// the port number determined by looking up the backend service's named
	// port in the instance group's list of named ports.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// Instructs the health check prober to send this exact ASCII string, up
	// to 1024 bytes in length, after establishing the TCP connection and
	// SSL handshake.
	Request string `json:"request,omitempty"`
	// Creates a content-based SSL health check. In addition to establishing
	// a TCP connection and the TLS handshake, you can configure the health
	// check to pass only when the backend sends this exact response ASCII
	// string, up to 1024 bytes in length. For details, see:
	// https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// SdsConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SdsConfig struct {
	// The configuration to access the SDS server over GRPC.
	GrpcServiceConfig *GrpcServiceConfig `json:"grpcServiceConfig,omitempty"`
	ForceSendFields   []string           `json:"-"`
	NullFields        []string           `json:"-"`
}

// SecuritySettings is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SecuritySettings struct {
	// [Deprecated] Use clientTlsPolicy instead.
	Authentication string `json:"authentication,omitempty"`
	// [Deprecated] Authentication policy defines what authentication
	// methods can be accepted on backends, and if authenticated, which
	// method/certificate will set the request principal. request principal.
	AuthenticationPolicy *AuthenticationPolicy `json:"authenticationPolicy,omitempty"`
	// [Deprecated] Authorization config defines the Role Based Access
	// Control (RBAC) config. Authorization config defines the Role Based
	// Access Control (RBAC) config.
	AuthorizationConfig *AuthorizationConfig `json:"authorizationConfig,omitempty"`
	// The configuration needed to generate a signature for access to
	// private storage buckets that support AWS's Signature Version 4 for
	// authentication. Allowed only for INTERNET_IP_PORT and
	// INTERNET_FQDN_PORT NEG backends.
	AwsV4Authentication *AWSV4Signature `json:"awsV4Authentication,omitempty"`
	// Optional. A URL referring to a networksecurity.ClientTlsPolicy
	// resource that describes how clients should authenticate with this
	// service's backends. clientTlsPolicy only applies to a global
	// BackendService with the loadBalancingScheme set to
	// INTERNAL_SELF_MANAGED. If left blank, communications are not
	// encrypted.
	ClientTlsPolicy string `json:"clientTlsPolicy,omitempty"`
	// [Deprecated] TLS Settings for the backend service.
	ClientTlsSettings *ClientTlsSettings `json:"clientTlsSettings,omitempty"`
	// Optional. A list of Subject Alternative Names (SANs) that the client
	// verifies during a mutual TLS handshake with an server/endpoint for
	// this BackendService. When the server presents its X.509 certificate
	// to the client, the client inspects the certificate's subjectAltName
	// field. If the field contains one of the specified values, the
	// communication continues. Otherwise, it fails. This additional check
	// enables the client to verify that the server is authorized to run the
	// requested service. Note that the contents of the server certificate's
	// subjectAltName field are configured by the Public Key Infrastructure
	// which provisions server identities. Only applies to a global
	// BackendService with loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Only applies when BackendService has an attached clientTlsPolicy with
	// clientCertificate (mTLS mode).
	SubjectAltNames []string `json:"subjectAltNames,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// SignedUrlKey is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SignedUrlKey struct {
	// Version keeps track of the intended compute version for this SignedUrlKey.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// Name of the key. The name must be 1-63 characters long, and comply
	// with RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	KeyName string `json:"keyName,omitempty"`
	// 128-bit key value used for signing the URL. The key value must be a
	// valid RFC 4648 Section 5 base64url encoded string.
	KeyValue        string   `json:"keyValue,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// SslCertificate is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SslCertificate struct {
	// Version keeps track of the intended compute version for this SslCertificate.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// A value read into memory from a certificate file. The certificate
	// file must be in PEM format. The certificate chain must be no greater
	// than 5 certs long. The chain must include at least one intermediate
	// cert.
	Certificate string `json:"certificate,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// [Output Only] Expire time of the certificate. RFC3339
	ExpireTime string `json:"expireTime,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of the resource. Always compute#sslCertificate for
	// SSL certificates.
	Kind string `json:"kind,omitempty"`
	// Configuration and status of a managed SSL certificate.
	Managed *SslCertificateManagedSslCertificate `json:"managed,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// A value read into memory from a write-only private key file. The
	// private key file must be in PEM format. For security, only insert
	// requests include this field.
	PrivateKey string `json:"privateKey,omitempty"`
	// [Output Only] URL of the region where the regional SSL Certificate
	// resides. This field is not applicable to global SSL Certificate.
	Region string `json:"region,omitempty"`
	// [Output only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// Configuration and status of a self-managed SSL certificate.
	SelfManaged *SslCertificateSelfManagedSslCertificate `json:"selfManaged,omitempty"`
	// [Output Only] Domains associated with the certificate via Subject
	// Alternative Name.
	SubjectAlternativeNames []string `json:"subjectAlternativeNames,omitempty"`
	// (Optional) Specifies the type of SSL certificate, either
	// "SELF_MANAGED" or "MANAGED". If not specified, the certificate is
	// self-managed and the fields certificate and private_key are used.
	Type                     string `json:"type,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// SslCertificateManagedSslCertificate is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SslCertificateManagedSslCertificate struct {
	// [Output only] Detailed statuses of the domains specified for managed
	// certificate resource.
	DomainStatus map[string]string `json:"domainStatus,omitempty"`
	// The domains for which a managed SSL certificate will be generated.
	// Each Google-managed SSL certificate supports up to the [maximum
	// number of domains per Google-managed SSL
	// certificate](/load-balancing/docs/quotas#ssl_certificates).
	Domains []string `json:"domains,omitempty"`
	// [Output only] Status of the managed certificate resource.
	Status          string   `json:"status,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// SslCertificateSelfManagedSslCertificate is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SslCertificateSelfManagedSslCertificate struct {
	// A local certificate file. The certificate must be in PEM format. The
	// certificate chain must be no greater than 5 certs long. The chain
	// must include at least one intermediate cert.
	Certificate string `json:"certificate,omitempty"`
	// A write-only private key in PEM format. Only insert requests will
	// include this field.
	PrivateKey      string   `json:"privateKey,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// Subsetting is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Subsetting struct {
	Policy string `json:"policy,omitempty"`
	// The number of backends per backend group assigned to each proxy
	// instance or each service mesh client. An input parameter to the
	// `CONSISTENT_HASH_SUBSETTING` algorithm. Can only be set if `policy`
	// is set to `CONSISTENT_HASH_SUBSETTING`. Can only be set if load
	// balancing scheme is `INTERNAL_MANAGED` or `INTERNAL_SELF_MANAGED`.
	// `subset_size` is optional for Internal HTTP(S) load balancing and
	// required for Traffic Director. If you do not provide this value,
	// Cloud Load Balancing will calculate it dynamically to optimize the
	// number of proxies/clients visible to each backend and vice versa.
	// Must be greater than 0. If `subset_size` is larger than the number of
	// backends/endpoints, then subsetting is disabled.
	SubsetSize      int64    `json:"subsetSize,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// TCPHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TCPHealthCheck struct {
	// The TCP port number to which the health check prober sends packets.
	// The default value is 80. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Not supported.
	PortName string `json:"portName,omitempty"`
	// Specifies how a port is selected for health checking. Can be one of
	// the following values: USE_FIXED_PORT: Specifies a port number
	// explicitly using the port field in the health check. Supported by
	// backend services for passthrough load balancers and backend services
	// for proxy load balancers. Not supported by target pools. The health
	// check supports all backends supported by the backend service provided
	// the backend can be health checked. For example, GCE_VM_IP network
	// endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance
	// group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT:
	// Provides an indirect method of specifying the health check port by
	// referring to the backend service. Only supported by backend services
	// for proxy load balancers. Not supported by target pools. Not
	// supported by backend services for passthrough load balancers.
	// Supports all backends that can be health checked; for example,
	// GCE_VM_IP_PORT network endpoint groups and instance group backends.
	// For GCE_VM_IP_PORT network endpoint group backends, the health check
	// uses the port number specified for each endpoint in the network
	// endpoint group. For instance group backends, the health check uses
	// the port number determined by looking up the backend service's named
	// port in the instance group's list of named ports.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// Instructs the health check prober to send this exact ASCII string, up
	// to 1024 bytes in length, after establishing the TCP connection.
	Request string `json:"request,omitempty"`
	// Creates a content-based TCP health check. In addition to establishing
	// a TCP connection, you can configure the health check to pass only
	// when the backend sends this exact response ASCII string, up to 1024
	// bytes in length. For details, see:
	// https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// TargetHttpProxy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TargetHttpProxy struct {
	// Version keeps track of the intended compute version for this TargetHttpProxy.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a TargetHttpProxy. An up-to-date fingerprint
	// must be provided in order to patch/update the TargetHttpProxy;
	// otherwise, the request will fail with error 412 conditionNotMet. To
	// see the latest fingerprint, make a get() request to retrieve the
	// TargetHttpProxy.
	Fingerprint string `json:"fingerprint,omitempty"`
	// URLs to networkservices.HttpFilter resources enabled for xDS clients
	// using this configuration. For example,
	// https://networkservices.googleapis.com/v1alpha1/projects/project/locations/ locationhttpFilters/httpFilter Only filters that handle outbound connection and stream events may be specified. These filters work in conjunction with a default set of HTTP filters that may already be configured by Traffic Director. Traffic Director will determine the final location of these filters within xDS configuration based on the name of the HTTP filter. If Traffic Director positions multiple filters at the same location, those filters will be in the same order as specified in this list. httpFilters only applies for loadbalancers with loadBalancingScheme set to INTERNAL_SELF_MANAGED. See ForwardingRule for more
	// details.
	HttpFilters []string `json:"httpFilters,omitempty"`
	// Specifies how long to keep a connection open, after completing a
	// response, while there is no matching traffic (in seconds). If an HTTP
	// keep-alive is not specified, a default value (610 seconds) will be
	// used. For global external Application Load Balancers, the minimum
	// allowed value is 5 seconds and the maximum allowed value is 1200
	// seconds. For classic Application Load Balancers, this option is not
	// supported.
	HttpKeepAliveTimeoutSec int64 `json:"httpKeepAliveTimeoutSec,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of resource. Always compute#targetHttpProxy for
	// target HTTP proxies.
	Kind string `json:"kind,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// This field only applies when the forwarding rule that references this
	// target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// When this field is set to true, Envoy proxies set up inbound traffic
	// interception and bind to the IP address and port specified in the
	// forwarding rule. This is generally useful when using Traffic Director
	// to configure Envoy as a gateway or middle proxy (in other words, not
	// a sidecar proxy). The Envoy proxy listens for inbound requests and
	// handles requests when it receives them. The default is false.
	ProxyBind bool `json:"proxyBind,omitempty"`
	// [Output Only] URL of the region where the regional Target HTTP Proxy
	// resides. This field is not applicable to global Target HTTP Proxies.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// URL to the UrlMap resource that defines the mapping from URL to the
	// BackendService.
	UrlMap                   string `json:"urlMap,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// TargetHttpsProxy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TargetHttpsProxy struct {
	// Version keeps track of the intended compute version for this TargetHttpsProxy.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// [Deprecated] Use serverTlsPolicy instead.
	Authentication string `json:"authentication,omitempty"`
	// [Deprecated] Use authorizationPolicy instead.
	Authorization string `json:"authorization,omitempty"`
	// Optional. A URL referring to a networksecurity.AuthorizationPolicy
	// resource that describes how the proxy should authorize inbound
	// traffic. If left blank, access will not be restricted by an
	// authorization policy. Refer to the AuthorizationPolicy resource for
	// additional details. authorizationPolicy only applies to a global
	// TargetHttpsProxy attached to globalForwardingRules with the
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED. Note: This field
	// currently has no impact.
	AuthorizationPolicy string `json:"authorizationPolicy,omitempty"`
	// URL of a certificate map that identifies a certificate map associated
	// with the given target proxy. This field can only be set for global
	// target proxies. If set, sslCertificates will be ignored. Accepted
	// format is //certificatemanager.googleapis.com/projects/{project
	// }/locations/{location}/certificateMaps/{resourceName}.
	CertificateMap string `json:"certificateMap,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a TargetHttpsProxy. An up-to-date fingerprint
	// must be provided in order to patch the TargetHttpsProxy; otherwise,
	// the request will fail with error 412 conditionNotMet. To see the
	// latest fingerprint, make a get() request to retrieve the
	// TargetHttpsProxy.
	Fingerprint string `json:"fingerprint,omitempty"`
	// URLs to networkservices.HttpFilter resources enabled for xDS clients
	// using this configuration. For example,
	// https://networkservices.googleapis.com/beta/projects/project/locations/ location/httpFilters/httpFilter Only filters that handle outbound connection and stream events may be specified. These filters work in conjunction with a default set of HTTP filters that may already be configured by Traffic Director. Traffic Director will determine the final location of these filters within xDS configuration based on the name of the HTTP filter. If Traffic Director positions multiple filters at the same location, those filters will be in the same order as specified in this list. httpFilters only applies for loadbalancers with loadBalancingScheme set to INTERNAL_SELF_MANAGED. See ForwardingRule for more
	// details.
	HttpFilters []string `json:"httpFilters,omitempty"`
	// Specifies how long to keep a connection open, after completing a
	// response, while there is no matching traffic (in seconds). If an HTTP
	// keep-alive is not specified, a default value (610 seconds) will be
	// used. For global external Application Load Balancers, the minimum
	// allowed value is 5 seconds and the maximum allowed value is 1200
	// seconds. For classic Application Load Balancers, this option is not
	// supported.
	HttpKeepAliveTimeoutSec int64 `json:"httpKeepAliveTimeoutSec,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of resource. Always compute#targetHttpsProxy for
	// target HTTPS proxies.
	Kind string `json:"kind,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// This field only applies when the forwarding rule that references this
	// target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// When this field is set to true, Envoy proxies set up inbound traffic
	// interception and bind to the IP address and port specified in the
	// forwarding rule. This is generally useful when using Traffic Director
	// to configure Envoy as a gateway or middle proxy (in other words, not
	// a sidecar proxy). The Envoy proxy listens for inbound requests and
	// handles requests when it receives them. The default is false.
	ProxyBind bool `json:"proxyBind,omitempty"`
	// Specifies the QUIC override policy for this TargetHttpsProxy
	// resource. This setting determines whether the load balancer attempts
	// to negotiate QUIC with clients. You can specify NONE, ENABLE, or
	// DISABLE. - When quic-override is set to NONE, Google manages whether
	// QUIC is used. - When quic-override is set to ENABLE, the load
	// balancer uses QUIC when possible. - When quic-override is set to
	// DISABLE, the load balancer doesn't use QUIC. - If the quic-override
	// flag is not specified, NONE is implied.
	QuicOverride string `json:"quicOverride,omitempty"`
	// [Output Only] URL of the region where the regional TargetHttpsProxy
	// resides. This field is not applicable to global TargetHttpsProxies.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// Optional. A URL referring to a networksecurity.ServerTlsPolicy
	// resource that describes how the proxy should authenticate inbound
	// traffic. serverTlsPolicy only applies to a global TargetHttpsProxy
	// attached to globalForwardingRules with the loadBalancingScheme set to
	// INTERNAL_SELF_MANAGED or EXTERNAL or EXTERNAL_MANAGED. For details
	// which ServerTlsPolicy resources are accepted with
	// INTERNAL_SELF_MANAGED and which with EXTERNAL, EXTERNAL_MANAGED
	// loadBalancingScheme consult ServerTlsPolicy documentation. If left
	// blank, communications are not encrypted.
	ServerTlsPolicy string `json:"serverTlsPolicy,omitempty"`
	// URLs to SslCertificate resources that are used to authenticate
	// connections between users and the load balancer. At least one SSL
	// certificate must be specified. Currently, you may specify up to 15
	// SSL certificates. sslCertificates do not apply when the load
	// balancing scheme is set to INTERNAL_SELF_MANAGED.
	SslCertificates []string `json:"sslCertificates,omitempty"`
	// URL of SslPolicy resource that will be associated with the
	// TargetHttpsProxy resource. If not set, the TargetHttpsProxy resource
	// has no SSL policy configured.
	SslPolicy string `json:"sslPolicy,omitempty"`
	//  Specifies whether TLS 1.3 0-RTT Data ("Early Data") should be
	// accepted for this service. Early Data allows a TLS resumption
	// handshake to include the initial application payload (a HTTP request)
	// alongside the handshake, reducing the effective round trips to
	// "zero". This applies to TLS 1.3 connections over TCP (HTTP/2) as well
	// as over UDP (QUIC/h3). This can improve application performance,
	// especially on networks where interruptions may be common, such as on
	// mobile. Requests with Early Data will have the "Early-Data" HTTP
	// header set on the request, with a value of "1", to allow the backend
	// to determine whether Early Data was included. Note: TLS Early Data
	// may allow requests to be replayed, as the data is sent to the backend
	// before the handshake has fully completed. Applications that allow
	// idempotent HTTP methods to make non-idempotent changes, such as a GET
	// request updating a database, should not accept Early Data on those
	// requests, and reject requests with the "Early-Data: 1" HTTP header by
	// returning a HTTP 425 (Too Early) status code, in order to remain RFC
	// compliant. The default value is DISABLED.
	TlsEarlyData string `json:"tlsEarlyData,omitempty"`
	// A fully-qualified or valid partial URL to the UrlMap resource that
	// defines the mapping from URL to the BackendService. For example, the
	// following are all valid URLs for specifying a URL map: -
	// https://www.googleapis.compute/v1/projects/project/global/urlMaps/
	// url-map - projects/project/global/urlMaps/url-map -
	// global/urlMaps/url-map
	UrlMap                   string `json:"urlMap,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// TlsCertificateContext is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TlsCertificateContext struct {
	// Specifies the certificate and private key paths. This field is
	// applicable only if tlsCertificateSource is set to USE_PATH.
	CertificatePaths *TlsCertificatePaths `json:"certificatePaths,omitempty"`
	// Defines how TLS certificates are obtained.
	CertificateSource string `json:"certificateSource,omitempty"`
	// Specifies the config to retrieve certificates through SDS. This field
	// is applicable only if tlsCertificateSource is set to USE_SDS.
	SdsConfig       *SdsConfig `json:"sdsConfig,omitempty"`
	ForceSendFields []string   `json:"-"`
	NullFields      []string   `json:"-"`
}

// TlsCertificatePaths is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TlsCertificatePaths struct {
	// The path to the file holding the client or server TLS certificate to
	// use.
	CertificatePath string `json:"certificatePath,omitempty"`
	// The path to the file holding the client or server private key.
	PrivateKeyPath  string   `json:"privateKeyPath,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// TlsContext is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TlsContext struct {
	// Defines the mechanism to obtain the client or server certificate.
	CertificateContext *TlsCertificateContext `json:"certificateContext,omitempty"`
	// Defines the mechanism to obtain the Certificate Authority certificate
	// to validate the client/server certificate. If omitted, the proxy will
	// not validate the server or client certificate.
	ValidationContext *TlsValidationContext `json:"validationContext,omitempty"`
	ForceSendFields   []string              `json:"-"`
	NullFields        []string              `json:"-"`
}

// TlsValidationContext is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TlsValidationContext struct {
	// The path to the file holding the CA certificate to validate the
	// client or server certificate.
	CertificatePath string `json:"certificatePath,omitempty"`
	// Specifies the config to retrieve certificates through SDS. This field
	// is applicable only if tlsCertificateSource is set to USE_SDS.
	SdsConfig *SdsConfig `json:"sdsConfig,omitempty"`
	// Defines how TLS certificates are obtained.
	ValidationSource string   `json:"validationSource,omitempty"`
	ForceSendFields  []string `json:"-"`
	NullFields       []string `json:"-"`
}

// UDPHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UDPHealthCheck struct {
	// The UDP port number to which the health check prober sends packets.
	// Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Not supported.
	PortName string `json:"portName,omitempty"`
	// Raw data of request to send in payload of UDP packet. It is an error
	// if this is empty. The request data can only be ASCII.
	Request string `json:"request,omitempty"`
	// The bytes to match against the beginning of the response data. It is
	// an error if this is empty. The response data can only be ASCII.
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// UrlMap is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlMap struct {
	// Version keeps track of the intended compute version for this UrlMap.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// defaultCustomErrorResponsePolicy specifies how the Load Balancer
	// returns error responses when BackendServiceor BackendBucket responds
	// with an error. This policy takes effect at the load balancer level
	// and applies only when no policy has been defined for the error code
	// at lower levels like PathMatcher, RouteRule and PathRule within this
	// UrlMap. For example, consider a UrlMap with the following
	// configuration: - defaultCustomErrorResponsePolicy containing policies
	// for responding to 5xx and 4xx errors - A PathMatcher configured for
	// *.example.com has defaultCustomErrorResponsePolicy for 4xx. If a
	// request for http://www.example.com/ encounters a 404, the policy in
	// pathMatcher.defaultCustomErrorResponsePolicy will be enforced. When
	// the request for http://www.example.com/ encounters a 502, the policy
	// in UrlMap.defaultCustomErrorResponsePolicy will be enforced. When a
	// request that does not match any host in *.example.com such as
	// http://www.myotherexample.com/, encounters a 404,
	// UrlMap.defaultCustomErrorResponsePolicy takes effect. When used in
	// conjunction with defaultRouteAction.retryPolicy, retries take
	// precedence. Only once all retries are exhausted, the
	// defaultCustomErrorResponsePolicy is applied. While attempting a
	// retry, if load balancer is successful in reaching the service, the
	// defaultCustomErrorResponsePolicy is ignored and the response from the
	// service is returned to the client. defaultCustomErrorResponsePolicy
	// is supported only for global external Application Load Balancers.
	DefaultCustomErrorResponsePolicy *CustomErrorResponsePolicy `json:"defaultCustomErrorResponsePolicy,omitempty"`
	// defaultRouteAction takes effect when none of the hostRules match. The
	// load balancer performs advanced routing actions, such as URL rewrites
	// and header transformations, before forwarding the request to the
	// selected backend. If defaultRouteAction specifies any
	// weightedBackendServices, defaultService must not be set. Conversely
	// if defaultService is set, defaultRouteAction cannot contain any
	// weightedBackendServices. Only one of defaultRouteAction or
	// defaultUrlRedirect must be set. URL maps for classic Application Load
	// Balancers only support the urlRewrite action within
	// defaultRouteAction. defaultRouteAction has no effect when the URL map
	// is bound to a target gRPC proxy that has the validateForProxyless
	// field set to true.
	DefaultRouteAction *HttpRouteAction `json:"defaultRouteAction,omitempty"`
	// The full or partial URL of the defaultService resource to which
	// traffic is directed if none of the hostRules match. If
	// defaultRouteAction is also specified, advanced routing actions, such
	// as URL rewrites, take effect before sending the request to the
	// backend. However, if defaultService is specified, defaultRouteAction
	// cannot contain any weightedBackendServices. Conversely, if
	// routeAction specifies any weightedBackendServices, service must not
	// be specified. If defaultService is specified, then set either
	// defaultUrlRedirect , or defaultRouteAction.weightedBackendService
	// Don't set both. defaultService has no effect when the URL map is
	// bound to a target gRPC proxy that has the validateForProxyless field
	// set to true.
	DefaultService string `json:"defaultService,omitempty"`
	// When none of the specified hostRules match, the request is redirected
	// to a URL specified by defaultUrlRedirect. If defaultUrlRedirect is
	// specified, defaultService or defaultRouteAction must not be set. Not
	// supported when the URL map is bound to a target gRPC proxy.
	DefaultUrlRedirect *HttpRedirectAction `json:"defaultUrlRedirect,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field is
	// ignored when inserting a UrlMap. An up-to-date fingerprint must be
	// provided in order to update the UrlMap, otherwise the request will
	// fail with error 412 conditionNotMet. To see the latest fingerprint,
	// make a get() request to retrieve a UrlMap.
	Fingerprint string `json:"fingerprint,omitempty"`
	// Specifies changes to request and response headers that need to take
	// effect for the selected backendService. The headerAction specified
	// here take effect after headerAction specified under pathMatcher.
	// headerAction is not supported for load balancers that have their
	// loadBalancingScheme set to EXTERNAL. Not supported when the URL map
	// is bound to a target gRPC proxy that has validateForProxyless field
	// set to true.
	HeaderAction *HttpHeaderAction `json:"headerAction,omitempty"`
	// The list of host rules to use against the URL.
	HostRules []*HostRule `json:"hostRules,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of the resource. Always compute#urlMaps for url
	// maps.
	Kind string `json:"kind,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// The list of named PathMatchers to use against the URL.
	PathMatchers []*PathMatcher `json:"pathMatchers,omitempty"`
	// [Output Only] URL of the region where the regional URL map resides.
	// This field is not applicable to global URL maps. You must specify
	// this field as part of the HTTP request URL. It is not settable as a
	// field in the request body.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// The list of expected URL mapping tests. Request to update the UrlMap
	// succeeds only if all test cases pass. You can specify a maximum of
	// 100 tests per UrlMap. Not supported when the URL map is bound to a
	// target gRPC proxy that has validateForProxyless field set to true.
	Tests                    []*UrlMapTest `json:"tests,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// UrlMapTest is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlMapTest struct {
	// The weight to use for the supplied host and path when using advanced
	// routing rules that involve traffic splitting.
	BackendServiceWeight int64 `json:"backendServiceWeight,omitempty"`
	// Description of this test case.
	Description string `json:"description,omitempty"`
	// The expected output URL evaluated by the load balancer containing the
	// scheme, host, path and query parameters. For rules that forward
	// requests to backends, the test passes only when expectedOutputUrl
	// matches the request forwarded by the load balancer to backends. For
	// rules with urlRewrite, the test verifies that the forwarded request
	// matches hostRewrite and pathPrefixRewrite in the urlRewrite action.
	// When service is specified, expectedOutputUrl`s scheme is ignored. For
	// rules with urlRedirect, the test passes only if expectedOutputUrl
	// matches the URL in the load balancer's redirect response. If
	// urlRedirect specifies https_redirect, the test passes only if the
	// scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect
	// specifies strip_query, the test passes only if expectedOutputUrl does
	// not contain any query parameters. expectedOutputUrl is optional when
	// service is specified.
	ExpectedOutputUrl string `json:"expectedOutputUrl,omitempty"`
	// For rules with urlRedirect, the test passes only if
	// expectedRedirectResponseCode matches the HTTP status code in load
	// balancer's redirect response. expectedRedirectResponseCode cannot be
	// set when service is set.
	ExpectedRedirectResponseCode int64 `json:"expectedRedirectResponseCode,omitempty"`
	// The expected URL that should be redirected to for the host and path
	// being tested. [Deprecated] This field is deprecated. Use
	// expected_output_url instead.
	ExpectedUrlRedirect string `json:"expectedUrlRedirect,omitempty"`
	// HTTP headers for this request. If headers contains a host header,
	// then host must also match the header value.
	Headers []*UrlMapTestHeader `json:"headers,omitempty"`
	// Host portion of the URL. If headers contains a host header, then host
	// must also match the header value.
	Host string `json:"host,omitempty"`
	// Path portion of the URL.
	Path string `json:"path,omitempty"`
	// Expected BackendService or BackendBucket resource the given URL
	// should be mapped to. The service field cannot be set if
	// expectedRedirectResponseCode is set.
	Service         string   `json:"service,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// UrlMapTestHeader is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlMapTestHeader struct {
	// Header name.
	Name string `json:"name,omitempty"`
	// Header value.
	Value           string   `json:"value,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// UrlRewrite is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlRewrite struct {
	// Before forwarding the request to the selected service, the request's
	// host header is replaced with contents of hostRewrite. The value must
	// be from 1 to 255 characters.
	HostRewrite string `json:"hostRewrite,omitempty"`
	// Before forwarding the request to the selected backend service, the
	// matching portion of the request's path is replaced by
	// pathPrefixRewrite. The value must be from 1 to 1024 characters.
	PathPrefixRewrite string `json:"pathPrefixRewrite,omitempty"`
	//  If specified, the pattern rewrites the URL path (based on the :path
	// header) using the HTTP template syntax. A corresponding
	// path_template_match must be specified. Any template variables must
	// exist in the path_template_match field. - -At least one variable must
	// be specified in the path_template_match field - You can omit
	// variables from the rewritten URL - The * and ** operators cannot be
	// matched unless they have a corresponding variable name - e.g.
	// {format=*} or {var=**}. For example, a path_template_match of
	// /static/{format=**} could be rewritten as /static/content/{format} to
	// prefix /content to the URL. Variables can also be re-ordered in a
	// rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as
	// /content/{format}/{country}/{suffix}. At least one non-empty
	// routeRules[].matchRules[].path_template_match is required. Only one
	// of path_prefix_rewrite or path_template_rewrite may be specified.
	PathTemplateRewrite string   `json:"pathTemplateRewrite,omitempty"`
	ForceSendFields     []string `json:"-"`
	NullFields          []string `json:"-"`
}

// WeightedBackendService is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type WeightedBackendService struct {
	// The full or partial URL to the default BackendService resource.
	// Before forwarding the request to backendService, the load balancer
	// applies any relevant headerActions specified as part of this
	// backendServiceWeight.
	BackendService string `json:"backendService,omitempty"`
	// Specifies changes to request and response headers that need to take
	// effect for the selected backendService. headerAction specified here
	// take effect before headerAction in the enclosing HttpRouteRule,
	// PathMatcher and UrlMap. headerAction is not supported for load
	// balancers that have their loadBalancingScheme set to EXTERNAL. Not
	// supported when the URL map is bound to a target gRPC proxy that has
	// validateForProxyless field set to true.
	HeaderAction *HttpHeaderAction `json:"headerAction,omitempty"`
	// Specifies the fraction of traffic sent to a backend service, computed
	// as weight / (sum of all weightedBackendService weights in
	// routeAction) . The selection of a backend service is determined only
	// for new traffic. Once a user's request has been directed to a backend
	// service, subsequent requests are sent to the same backend service as
	// determined by the backend service's session affinity policy. Don't
	// configure session affinity if you're using weighted traffic
	// splitting. If you do, the weighted traffic splitting configuration
	// takes precedence. The value must be from 0 to 1000.
	Weight          int64    `json:"weight,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

func CreateAddress(gceCloud *gce.Cloud, key *meta.Key, address *Address, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("Address", "create", key.Region, key.Zone, string(address.Version))

	switch address.Version {
	case meta.VersionAlpha:
		alpha, err := address.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Creating alpha region Address")
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaAddresses().Insert(ctx, key, alpha))
		default:
			alphaLogger.Info("Creating alpha Address")
			return mc.Observe(gceCloud.Compute().AlphaGlobalAddresses().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := address.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Creating beta region Address")
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaAddresses().Insert(ctx, key, beta))
		default:
			betaLogger.Info("Creating beta Address")
			return mc.Observe(gceCloud.Compute().BetaGlobalAddresses().Insert(ctx, key, beta))
		}
	default:
		ga, err := address.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Creating ga region Address")
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().Addresses().Insert(ctx, key, ga))
		default:
			gaLogger.Info("Creating ga Address")
			return mc.Observe(gceCloud.Compute().GlobalAddresses().Insert(ctx, key, ga))
		}
	}
}

func DeleteAddress(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) error {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("Address", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting alpha region Address")
			return mc.Observe(gceCloud.Compute().AlphaAddresses().Delete(ctx, key))
		default:
			logger.Info("Deleting alpha Address")
			return mc.Observe(gceCloud.Compute().AlphaGlobalAddresses().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting beta region Address")
			return mc.Observe(gceCloud.Compute().BetaAddresses().Delete(ctx, key))
		default:
			logger.Info("Deleting beta Address")
			return mc.Observe(gceCloud.Compute().BetaGlobalAddresses().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting ga region Address")
			return mc.Observe(gceCloud.Compute().Addresses().Delete(ctx, key))
		default:
			logger.Info("Deleting ga Address")
			return mc.Observe(gceCloud.Compute().GlobalAddresses().Delete(ctx, key))
		}
	}
}

func GetAddress(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) (*Address, error) {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("Address", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting alpha region Address")
			gceObj, err = gceCloud.Compute().AlphaAddresses().Get(ctx, key)
		default:
			logger.Info("Getting alpha Address")
			gceObj, err = gceCloud.Compute().AlphaGlobalAddresses().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting beta region Address")
			gceObj, err = gceCloud.Compute().BetaAddresses().Get(ctx, key)
		default:
			logger.Info("Getting beta Address")
			gceObj, err = gceCloud.Compute().BetaGlobalAddresses().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting ga region Address")
			gceObj, err = gceCloud.Compute().Addresses().Get(ctx, key)
		default:
			logger.Info("Getting ga Address")
			gceObj, err = gceCloud.Compute().GlobalAddresses().Get(ctx, key)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}
	compositeType, err := toAddress(gceObj)
	if err != nil {
		return nil, err
	}
	if key.Type() == meta.Regional {
		compositeType.Scope = meta.Regional
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListAddresses(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) ([]*Address, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("Address", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing alpha region Address")
			gceObjs, err = gceCloud.Compute().AlphaAddresses().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing alpha Address")
			gceObjs, err = gceCloud.Compute().AlphaGlobalAddresses().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing beta region Address")
			gceObjs, err = gceCloud.Compute().BetaAddresses().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing beta Address")
			gceObjs, err = gceCloud.Compute().BetaGlobalAddresses().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing ga region Address")
			gceObjs, err = gceCloud.Compute().Addresses().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing ga Address")
			gceObjs, err = gceCloud.Compute().GlobalAddresses().List(ctx, filter.None)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}

	compositeObjs, err := toAddressList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toAddressList converts a list of compute alpha, beta or GA
// Address into a list of our composite type.
func toAddressList(objs interface{}) ([]*Address, error) {
	result := []*Address{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toAddress is for package internal use only (not type-safe).
func toAddress(obj interface{}) (*Address, error) {
	x := &Address{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToAddress convert to a composite type.
func AlphaToAddress(obj *computealpha.Address) (*Address, error) {
	x := &Address{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToAddress convert to a composite type.
func BetaToAddress(obj *computebeta.Address) (*Address, error) {
	x := &Address{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToAddress convert to a composite type.
func GAToAddress(obj *compute.Address) (*Address, error) {
	x := &Address{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (address *Address) ToAlpha() (*computealpha.Address, error) {
	alpha := &computealpha.Address{}
	err := copyViaJSON(alpha, address)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", address, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (address *Address) ToBeta() (*computebeta.Address, error) {
	beta := &computebeta.Address{}
	err := copyViaJSON(beta, address)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", address, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (address *Address) ToGA() (*compute.Address, error) {
	ga := &compute.Address{}
	err := copyViaJSON(ga, address)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", address, err)
	}

	return ga, nil
}

func CreateBackendService(gceCloud *gce.Cloud, key *meta.Key, backendService *BackendService, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "create", key.Region, key.Zone, string(backendService.Version))

	switch backendService.Version {
	case meta.VersionAlpha:
		alpha, err := backendService.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Creating alpha region BackendService")
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionBackendServices().Insert(ctx, key, alpha))
		default:
			alphaLogger.Info("Creating alpha BackendService")
			return mc.Observe(gceCloud.Compute().AlphaBackendServices().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := backendService.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Creating beta region BackendService")
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionBackendServices().Insert(ctx, key, beta))
		default:
			betaLogger.Info("Creating beta BackendService")
			return mc.Observe(gceCloud.Compute().BetaBackendServices().Insert(ctx, key, beta))
		}
	default:
		ga, err := backendService.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Creating ga region BackendService")
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionBackendServices().Insert(ctx, key, ga))
		default:
			gaLogger.Info("Creating ga BackendService")
			return mc.Observe(gceCloud.Compute().BackendServices().Insert(ctx, key, ga))
		}
	}
}

func UpdateBackendService(gceCloud *gce.Cloud, key *meta.Key, backendService *BackendService, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "update", key.Region, key.Zone, string(backendService.Version))
	switch backendService.Version {
	case meta.VersionAlpha:
		alpha, err := backendService.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Updating alpha region BackendService")
			return mc.Observe(gceCloud.Compute().AlphaRegionBackendServices().Update(ctx, key, alpha))
		default:
			alphaLogger.Info("Updating alpha BackendService")
			return mc.Observe(gceCloud.Compute().AlphaBackendServices().Update(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := backendService.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Updating beta region BackendService")
			return mc.Observe(gceCloud.Compute().BetaRegionBackendServices().Update(ctx, key, beta))
		default:
			betaLogger.Info("Updating beta BackendService")
			return mc.Observe(gceCloud.Compute().BetaBackendServices().Update(ctx, key, beta))
		}
	default:
		ga, err := backendService.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Updating ga region BackendService")
			return mc.Observe(gceCloud.Compute().RegionBackendServices().Update(ctx, key, ga))
		default:
			gaLogger.Info("Updating ga BackendService")
			return mc.Observe(gceCloud.Compute().BackendServices().Update(ctx, key, ga))
		}
	}
}

func DeleteBackendService(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) error {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting alpha region BackendService")
			return mc.Observe(gceCloud.Compute().AlphaRegionBackendServices().Delete(ctx, key))
		default:
			logger.Info("Deleting alpha BackendService")
			return mc.Observe(gceCloud.Compute().AlphaBackendServices().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting beta region BackendService")
			return mc.Observe(gceCloud.Compute().BetaRegionBackendServices().Delete(ctx, key))
		default:
			logger.Info("Deleting beta BackendService")
			return mc.Observe(gceCloud.Compute().BetaBackendServices().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting ga region BackendService")
			return mc.Observe(gceCloud.Compute().RegionBackendServices().Delete(ctx, key))
		default:
			logger.Info("Deleting ga BackendService")
			return mc.Observe(gceCloud.Compute().BackendServices().Delete(ctx, key))
		}
	}
}

func GetBackendService(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) (*BackendService, error) {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting alpha region BackendService")
			gceObj, err = gceCloud.Compute().AlphaRegionBackendServices().Get(ctx, key)
		default:
			logger.Info("Getting alpha BackendService")
			gceObj, err = gceCloud.Compute().AlphaBackendServices().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting beta region BackendService")
			gceObj, err = gceCloud.Compute().BetaRegionBackendServices().Get(ctx, key)
		default:
			logger.Info("Getting beta BackendService")
			gceObj, err = gceCloud.Compute().BetaBackendServices().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting ga region BackendService")
			gceObj, err = gceCloud.Compute().RegionBackendServices().Get(ctx, key)
		default:
			logger.Info("Getting ga BackendService")
			gceObj, err = gceCloud.Compute().BackendServices().Get(ctx, key)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}
	compositeType, err := toBackendService(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListBackendServices(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) ([]*BackendService, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing alpha region BackendService")
			gceObjs, err = gceCloud.Compute().AlphaRegionBackendServices().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing alpha BackendService")
			gceObjs, err = gceCloud.Compute().AlphaBackendServices().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing beta region BackendService")
			gceObjs, err = gceCloud.Compute().BetaRegionBackendServices().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing beta BackendService")
			gceObjs, err = gceCloud.Compute().BetaBackendServices().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing ga region BackendService")
			gceObjs, err = gceCloud.Compute().RegionBackendServices().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing ga BackendService")
			gceObjs, err = gceCloud.Compute().BackendServices().List(ctx, filter.None)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}

	compositeObjs, err := toBackendServiceList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toBackendServiceList converts a list of compute alpha, beta or GA
// BackendService into a list of our composite type.
func toBackendServiceList(objs interface{}) ([]*BackendService, error) {
	result := []*BackendService{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toBackendService is for package internal use only (not type-safe).
func toBackendService(obj interface{}) (*BackendService, error) {
	x := &BackendService{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToBackendService convert to a composite type.
func AlphaToBackendService(obj *computealpha.BackendService) (*BackendService, error) {
	x := &BackendService{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToBackendService convert to a composite type.
func BetaToBackendService(obj *computebeta.BackendService) (*BackendService, error) {
	x := &BackendService{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToBackendService convert to a composite type.
func GAToBackendService(obj *compute.BackendService) (*BackendService, error) {
	x := &BackendService{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (backendService *BackendService) ToAlpha() (*computealpha.BackendService, error) {
	alpha := &computealpha.BackendService{}
	err := copyViaJSON(alpha, backendService)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", backendService, err)
	}
	// Set force send fields. This is a temporary hack.
	if alpha.CdnPolicy != nil {
		if alpha.CdnPolicy.CacheKeyPolicy != nil {
			alpha.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
		}
		alpha.CdnPolicy.ForceSendFields = append(backendService.CdnPolicy.ForceSendFields, []string{"NegativeCaching", "RequestCoalescing", "SignedUrlCacheMaxAgeSec", "ServeWhileStale"}...)
	}
	if alpha.Iap != nil {
		alpha.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}
	if alpha.LogConfig != nil {
		alpha.LogConfig.ForceSendFields = []string{"Enable"}
		if alpha.LogConfig.Enable {
			alpha.LogConfig.ForceSendFields = []string{"Enable", "SampleRate"}
		}
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (backendService *BackendService) ToBeta() (*computebeta.BackendService, error) {
	beta := &computebeta.BackendService{}
	err := copyViaJSON(beta, backendService)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", backendService, err)
	}
	// Set force send fields. This is a temporary hack.
	if beta.CdnPolicy != nil {
		if beta.CdnPolicy.CacheKeyPolicy != nil {
			beta.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
		}
		beta.CdnPolicy.ForceSendFields = append(backendService.CdnPolicy.ForceSendFields, []string{"NegativeCaching", "RequestCoalescing", "SignedUrlCacheMaxAgeSec", "ServeWhileStale"}...)
	}
	if beta.Iap != nil {
		beta.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}
	if beta.LogConfig != nil {
		beta.LogConfig.ForceSendFields = []string{"Enable"}
		if beta.LogConfig.Enable {
			beta.LogConfig.ForceSendFields = []string{"Enable", "SampleRate"}
		}
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (backendService *BackendService) ToGA() (*compute.BackendService, error) {
	ga := &compute.BackendService{}
	err := copyViaJSON(ga, backendService)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", backendService, err)
	}
	// Set force send fields. This is a temporary hack.
	if ga.CdnPolicy != nil {
		if ga.CdnPolicy.CacheKeyPolicy != nil {
			ga.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
		}
		ga.CdnPolicy.ForceSendFields = append(backendService.CdnPolicy.ForceSendFields, []string{"NegativeCaching", "RequestCoalescing", "SignedUrlCacheMaxAgeSec", "ServeWhileStale"}...)
	}
	if ga.Iap != nil {
		ga.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}
	if ga.LogConfig != nil {
		ga.LogConfig.ForceSendFields = []string{"Enable"}
		if ga.LogConfig.Enable {
			ga.LogConfig.ForceSendFields = []string{"Enable", "SampleRate"}
		}
	}

	return ga, nil
}

func CreateForwardingRule(gceCloud *gce.Cloud, key *meta.Key, forwardingRule *ForwardingRule, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("ForwardingRule", "create", key.Region, key.Zone, string(forwardingRule.Version))

	switch forwardingRule.Version {
	case meta.VersionAlpha:
		alpha, err := forwardingRule.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Creating alpha region ForwardingRule")
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaForwardingRules().Insert(ctx, key, alpha))
		default:
			alphaLogger.Info("Creating alpha ForwardingRule")
			return mc.Observe(gceCloud.Compute().AlphaGlobalForwardingRules().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := forwardingRule.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Creating beta region ForwardingRule")
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaForwardingRules().Insert(ctx, key, beta))
		default:
			betaLogger.Info("Creating beta ForwardingRule")
			return mc.Observe(gceCloud.Compute().BetaGlobalForwardingRules().Insert(ctx, key, beta))
		}
	default:
		ga, err := forwardingRule.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Creating ga region ForwardingRule")
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().ForwardingRules().Insert(ctx, key, ga))
		default:
			gaLogger.Info("Creating ga ForwardingRule")
			return mc.Observe(gceCloud.Compute().GlobalForwardingRules().Insert(ctx, key, ga))
		}
	}
}

func PatchForwardingRule(gceCloud *gce.Cloud, key *meta.Key, forwardingRule *ForwardingRule, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("ForwardingRule", "patch", key.Region, key.Zone, string(forwardingRule.Version))
	switch forwardingRule.Version {
	case meta.VersionAlpha:
		alpha, err := forwardingRule.ToAlpha()
		if err != nil {
			return err
		}
		alpha.ForceSendFields = append(alpha.ForceSendFields, "AllowGlobalAccess")
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Updating alpha region ForwardingRule")
			return mc.Observe(gceCloud.Compute().AlphaForwardingRules().Patch(ctx, key, alpha))
		default:
			alphaLogger.Info("Updating alpha ForwardingRule")
			return mc.Observe(gceCloud.Compute().AlphaGlobalForwardingRules().Patch(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := forwardingRule.ToBeta()
		if err != nil {
			return err
		}
		beta.ForceSendFields = append(beta.ForceSendFields, "AllowGlobalAccess")
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Updating beta region ForwardingRule")
			return mc.Observe(gceCloud.Compute().BetaForwardingRules().Patch(ctx, key, beta))
		default:
			betaLogger.Info("Updating beta ForwardingRule")
			return mc.Observe(gceCloud.Compute().BetaGlobalForwardingRules().Patch(ctx, key, beta))
		}
	default:
		ga, err := forwardingRule.ToGA()
		if err != nil {
			return err
		}
		ga.ForceSendFields = append(ga.ForceSendFields, "AllowGlobalAccess")
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Updating ga region ForwardingRule")
			return mc.Observe(gceCloud.Compute().ForwardingRules().Patch(ctx, key, ga))
		default:
			gaLogger.Info("Updating ga ForwardingRule")
			return mc.Observe(gceCloud.Compute().GlobalForwardingRules().Patch(ctx, key, ga))
		}
	}
}

func DeleteForwardingRule(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) error {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("ForwardingRule", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting alpha region ForwardingRule")
			return mc.Observe(gceCloud.Compute().AlphaForwardingRules().Delete(ctx, key))
		default:
			logger.Info("Deleting alpha ForwardingRule")
			return mc.Observe(gceCloud.Compute().AlphaGlobalForwardingRules().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting beta region ForwardingRule")
			return mc.Observe(gceCloud.Compute().BetaForwardingRules().Delete(ctx, key))
		default:
			logger.Info("Deleting beta ForwardingRule")
			return mc.Observe(gceCloud.Compute().BetaGlobalForwardingRules().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting ga region ForwardingRule")
			return mc.Observe(gceCloud.Compute().ForwardingRules().Delete(ctx, key))
		default:
			logger.Info("Deleting ga ForwardingRule")
			return mc.Observe(gceCloud.Compute().GlobalForwardingRules().Delete(ctx, key))
		}
	}
}

func GetForwardingRule(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) (*ForwardingRule, error) {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("ForwardingRule", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting alpha region ForwardingRule")
			gceObj, err = gceCloud.Compute().AlphaForwardingRules().Get(ctx, key)
		default:
			logger.Info("Getting alpha ForwardingRule")
			gceObj, err = gceCloud.Compute().AlphaGlobalForwardingRules().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting beta region ForwardingRule")
			gceObj, err = gceCloud.Compute().BetaForwardingRules().Get(ctx, key)
		default:
			logger.Info("Getting beta ForwardingRule")
			gceObj, err = gceCloud.Compute().BetaGlobalForwardingRules().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting ga region ForwardingRule")
			gceObj, err = gceCloud.Compute().ForwardingRules().Get(ctx, key)
		default:
			logger.Info("Getting ga ForwardingRule")
			gceObj, err = gceCloud.Compute().GlobalForwardingRules().Get(ctx, key)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}
	compositeType, err := toForwardingRule(gceObj)
	if err != nil {
		return nil, err
	}
	if key.Type() == meta.Regional {
		compositeType.Scope = meta.Regional
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListForwardingRules(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) ([]*ForwardingRule, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("ForwardingRule", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing alpha region ForwardingRule")
			gceObjs, err = gceCloud.Compute().AlphaForwardingRules().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing alpha ForwardingRule")
			gceObjs, err = gceCloud.Compute().AlphaGlobalForwardingRules().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing beta region ForwardingRule")
			gceObjs, err = gceCloud.Compute().BetaForwardingRules().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing beta ForwardingRule")
			gceObjs, err = gceCloud.Compute().BetaGlobalForwardingRules().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing ga region ForwardingRule")
			gceObjs, err = gceCloud.Compute().ForwardingRules().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing ga ForwardingRule")
			gceObjs, err = gceCloud.Compute().GlobalForwardingRules().List(ctx, filter.None)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}

	compositeObjs, err := toForwardingRuleList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toForwardingRuleList converts a list of compute alpha, beta or GA
// ForwardingRule into a list of our composite type.
func toForwardingRuleList(objs interface{}) ([]*ForwardingRule, error) {
	result := []*ForwardingRule{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toForwardingRule is for package internal use only (not type-safe).
func toForwardingRule(obj interface{}) (*ForwardingRule, error) {
	x := &ForwardingRule{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToForwardingRule convert to a composite type.
func AlphaToForwardingRule(obj *computealpha.ForwardingRule) (*ForwardingRule, error) {
	x := &ForwardingRule{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToForwardingRule convert to a composite type.
func BetaToForwardingRule(obj *computebeta.ForwardingRule) (*ForwardingRule, error) {
	x := &ForwardingRule{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToForwardingRule convert to a composite type.
func GAToForwardingRule(obj *compute.ForwardingRule) (*ForwardingRule, error) {
	x := &ForwardingRule{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) ToAlpha() (*computealpha.ForwardingRule, error) {
	alpha := &computealpha.ForwardingRule{}
	err := copyViaJSON(alpha, forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", forwardingRule, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) ToBeta() (*computebeta.ForwardingRule, error) {
	beta := &computebeta.ForwardingRule{}
	err := copyViaJSON(beta, forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", forwardingRule, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) ToGA() (*compute.ForwardingRule, error) {
	ga := &compute.ForwardingRule{}
	err := copyViaJSON(ga, forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", forwardingRule, err)
	}

	return ga, nil
}

func CreateHealthCheck(gceCloud *gce.Cloud, key *meta.Key, healthCheck *HealthCheck, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "create", key.Region, key.Zone, string(healthCheck.Version))

	switch healthCheck.Version {
	case meta.VersionAlpha:
		alpha, err := healthCheck.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Creating alpha region HealthCheck")
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionHealthChecks().Insert(ctx, key, alpha))
		default:
			alphaLogger.Info("Creating alpha HealthCheck")
			return mc.Observe(gceCloud.Compute().AlphaHealthChecks().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := healthCheck.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Creating beta region HealthCheck")
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionHealthChecks().Insert(ctx, key, beta))
		default:
			betaLogger.Info("Creating beta HealthCheck")
			return mc.Observe(gceCloud.Compute().BetaHealthChecks().Insert(ctx, key, beta))
		}
	default:
		ga, err := healthCheck.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Creating ga region HealthCheck")
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionHealthChecks().Insert(ctx, key, ga))
		default:
			gaLogger.Info("Creating ga HealthCheck")
			return mc.Observe(gceCloud.Compute().HealthChecks().Insert(ctx, key, ga))
		}
	}
}

func UpdateHealthCheck(gceCloud *gce.Cloud, key *meta.Key, healthCheck *HealthCheck, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "update", key.Region, key.Zone, string(healthCheck.Version))
	switch healthCheck.Version {
	case meta.VersionAlpha:
		alpha, err := healthCheck.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Updating alpha region HealthCheck")
			return mc.Observe(gceCloud.Compute().AlphaRegionHealthChecks().Update(ctx, key, alpha))
		default:
			alphaLogger.Info("Updating alpha HealthCheck")
			return mc.Observe(gceCloud.Compute().AlphaHealthChecks().Update(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := healthCheck.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Updating beta region HealthCheck")
			return mc.Observe(gceCloud.Compute().BetaRegionHealthChecks().Update(ctx, key, beta))
		default:
			betaLogger.Info("Updating beta HealthCheck")
			return mc.Observe(gceCloud.Compute().BetaHealthChecks().Update(ctx, key, beta))
		}
	default:
		ga, err := healthCheck.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Updating ga region HealthCheck")
			return mc.Observe(gceCloud.Compute().RegionHealthChecks().Update(ctx, key, ga))
		default:
			gaLogger.Info("Updating ga HealthCheck")
			return mc.Observe(gceCloud.Compute().HealthChecks().Update(ctx, key, ga))
		}
	}
}

func DeleteHealthCheck(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) error {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting alpha region HealthCheck")
			return mc.Observe(gceCloud.Compute().AlphaRegionHealthChecks().Delete(ctx, key))
		default:
			logger.Info("Deleting alpha HealthCheck")
			return mc.Observe(gceCloud.Compute().AlphaHealthChecks().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting beta region HealthCheck")
			return mc.Observe(gceCloud.Compute().BetaRegionHealthChecks().Delete(ctx, key))
		default:
			logger.Info("Deleting beta HealthCheck")
			return mc.Observe(gceCloud.Compute().BetaHealthChecks().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting ga region HealthCheck")
			return mc.Observe(gceCloud.Compute().RegionHealthChecks().Delete(ctx, key))
		default:
			logger.Info("Deleting ga HealthCheck")
			return mc.Observe(gceCloud.Compute().HealthChecks().Delete(ctx, key))
		}
	}
}

func GetHealthCheck(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) (*HealthCheck, error) {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting alpha region HealthCheck")
			gceObj, err = gceCloud.Compute().AlphaRegionHealthChecks().Get(ctx, key)
		default:
			logger.Info("Getting alpha HealthCheck")
			gceObj, err = gceCloud.Compute().AlphaHealthChecks().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting beta region HealthCheck")
			gceObj, err = gceCloud.Compute().BetaRegionHealthChecks().Get(ctx, key)
		default:
			logger.Info("Getting beta HealthCheck")
			gceObj, err = gceCloud.Compute().BetaHealthChecks().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting ga region HealthCheck")
			gceObj, err = gceCloud.Compute().RegionHealthChecks().Get(ctx, key)
		default:
			logger.Info("Getting ga HealthCheck")
			gceObj, err = gceCloud.Compute().HealthChecks().Get(ctx, key)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}
	compositeType, err := toHealthCheck(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListHealthChecks(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) ([]*HealthCheck, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing alpha region HealthCheck")
			gceObjs, err = gceCloud.Compute().AlphaRegionHealthChecks().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing alpha HealthCheck")
			gceObjs, err = gceCloud.Compute().AlphaHealthChecks().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing beta region HealthCheck")
			gceObjs, err = gceCloud.Compute().BetaRegionHealthChecks().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing beta HealthCheck")
			gceObjs, err = gceCloud.Compute().BetaHealthChecks().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing ga region HealthCheck")
			gceObjs, err = gceCloud.Compute().RegionHealthChecks().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing ga HealthCheck")
			gceObjs, err = gceCloud.Compute().HealthChecks().List(ctx, filter.None)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}

	compositeObjs, err := toHealthCheckList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toHealthCheckList converts a list of compute alpha, beta or GA
// HealthCheck into a list of our composite type.
func toHealthCheckList(objs interface{}) ([]*HealthCheck, error) {
	result := []*HealthCheck{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toHealthCheck is for package internal use only (not type-safe).
func toHealthCheck(obj interface{}) (*HealthCheck, error) {
	x := &HealthCheck{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToHealthCheck convert to a composite type.
func AlphaToHealthCheck(obj *computealpha.HealthCheck) (*HealthCheck, error) {
	x := &HealthCheck{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToHealthCheck convert to a composite type.
func BetaToHealthCheck(obj *computebeta.HealthCheck) (*HealthCheck, error) {
	x := &HealthCheck{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToHealthCheck convert to a composite type.
func GAToHealthCheck(obj *compute.HealthCheck) (*HealthCheck, error) {
	x := &HealthCheck{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (healthCheck *HealthCheck) ToAlpha() (*computealpha.HealthCheck, error) {
	alpha := &computealpha.HealthCheck{}
	err := copyViaJSON(alpha, healthCheck)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", healthCheck, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (healthCheck *HealthCheck) ToBeta() (*computebeta.HealthCheck, error) {
	beta := &computebeta.HealthCheck{}
	err := copyViaJSON(beta, healthCheck)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", healthCheck, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (healthCheck *HealthCheck) ToGA() (*compute.HealthCheck, error) {
	ga := &compute.HealthCheck{}
	err := copyViaJSON(ga, healthCheck)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", healthCheck, err)
	}

	return ga, nil
}

// toHealthStatusForNetworkEndpointList converts a list of compute alpha, beta or GA
// HealthStatusForNetworkEndpoint into a list of our composite type.
func toHealthStatusForNetworkEndpointList(objs interface{}) ([]*HealthStatusForNetworkEndpoint, error) {
	result := []*HealthStatusForNetworkEndpoint{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toHealthStatusForNetworkEndpoint is for package internal use only (not type-safe).
func toHealthStatusForNetworkEndpoint(obj interface{}) (*HealthStatusForNetworkEndpoint, error) {
	x := &HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToHealthStatusForNetworkEndpoint convert to a composite type.
func AlphaToHealthStatusForNetworkEndpoint(obj *computealpha.HealthStatusForNetworkEndpoint) (*HealthStatusForNetworkEndpoint, error) {
	x := &HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToHealthStatusForNetworkEndpoint convert to a composite type.
func BetaToHealthStatusForNetworkEndpoint(obj *computebeta.HealthStatusForNetworkEndpoint) (*HealthStatusForNetworkEndpoint, error) {
	x := &HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToHealthStatusForNetworkEndpoint convert to a composite type.
func GAToHealthStatusForNetworkEndpoint(obj *compute.HealthStatusForNetworkEndpoint) (*HealthStatusForNetworkEndpoint, error) {
	x := &HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (healthStatusForNetworkEndpoint *HealthStatusForNetworkEndpoint) ToAlpha() (*computealpha.HealthStatusForNetworkEndpoint, error) {
	alpha := &computealpha.HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(alpha, healthStatusForNetworkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", healthStatusForNetworkEndpoint, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (healthStatusForNetworkEndpoint *HealthStatusForNetworkEndpoint) ToBeta() (*computebeta.HealthStatusForNetworkEndpoint, error) {
	beta := &computebeta.HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(beta, healthStatusForNetworkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", healthStatusForNetworkEndpoint, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (healthStatusForNetworkEndpoint *HealthStatusForNetworkEndpoint) ToGA() (*compute.HealthStatusForNetworkEndpoint, error) {
	ga := &compute.HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(ga, healthStatusForNetworkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", healthStatusForNetworkEndpoint, err)
	}

	return ga, nil
}

// toNetworkEndpointList converts a list of compute alpha, beta or GA
// NetworkEndpoint into a list of our composite type.
func toNetworkEndpointList(objs interface{}) ([]*NetworkEndpoint, error) {
	result := []*NetworkEndpoint{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpoint is for package internal use only (not type-safe).
func toNetworkEndpoint(obj interface{}) (*NetworkEndpoint, error) {
	x := &NetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpoint convert to a composite type.
func AlphaToNetworkEndpoint(obj *computealpha.NetworkEndpoint) (*NetworkEndpoint, error) {
	x := &NetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpoint convert to a composite type.
func BetaToNetworkEndpoint(obj *computebeta.NetworkEndpoint) (*NetworkEndpoint, error) {
	x := &NetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpoint convert to a composite type.
func GAToNetworkEndpoint(obj *compute.NetworkEndpoint) (*NetworkEndpoint, error) {
	x := &NetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpoint *NetworkEndpoint) ToAlpha() (*computealpha.NetworkEndpoint, error) {
	alpha := &computealpha.NetworkEndpoint{}
	err := copyViaJSON(alpha, networkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpoint, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpoint *NetworkEndpoint) ToBeta() (*computebeta.NetworkEndpoint, error) {
	beta := &computebeta.NetworkEndpoint{}
	err := copyViaJSON(beta, networkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpoint, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpoint *NetworkEndpoint) ToGA() (*compute.NetworkEndpoint, error) {
	ga := &compute.NetworkEndpoint{}
	err := copyViaJSON(ga, networkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpoint, err)
	}

	return ga, nil
}

func CreateNetworkEndpointGroup(gceCloud *gce.Cloud, key *meta.Key, networkEndpointGroup *NetworkEndpointGroup, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "create", key.Region, key.Zone, string(networkEndpointGroup.Version))
	switch key.Type() {
	case meta.Zonal:
	default:
		return fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}

	switch networkEndpointGroup.Version {
	case meta.VersionAlpha:
		alpha, err := networkEndpointGroup.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		alphaLogger.Info("Creating alpha zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().AlphaNetworkEndpointGroups().Insert(ctx, key, alpha))
	case meta.VersionBeta:
		beta, err := networkEndpointGroup.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		betaLogger.Info("Creating beta zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().BetaNetworkEndpointGroups().Insert(ctx, key, beta))
	default:
		ga, err := networkEndpointGroup.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		gaLogger.Info("Creating ga zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().NetworkEndpointGroups().Insert(ctx, key, ga))
	}
}

func DeleteNetworkEndpointGroup(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) error {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "delete", key.Region, key.Zone, string(version))
	switch key.Type() {
	case meta.Zonal:
	default:
		return fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}

	switch version {
	case meta.VersionAlpha:
		logger.Info("Deleting alpha zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().AlphaNetworkEndpointGroups().Delete(ctx, key))
	case meta.VersionBeta:
		logger.Info("Deleting beta zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().BetaNetworkEndpointGroups().Delete(ctx, key))
	default:
		logger.Info("Deleting ga zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().NetworkEndpointGroups().Delete(ctx, key))
	}
}

func GetNetworkEndpointGroup(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) (*NetworkEndpointGroup, error) {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch key.Type() {
	case meta.Zonal:
	default:
		return nil, fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}
	switch version {
	case meta.VersionAlpha:
		logger.Info("Getting alpha zonal NetworkEndpointGroup")
		gceObj, err = gceCloud.Compute().AlphaNetworkEndpointGroups().Get(ctx, key)
	case meta.VersionBeta:
		logger.Info("Getting beta zonal NetworkEndpointGroup")
		gceObj, err = gceCloud.Compute().BetaNetworkEndpointGroups().Get(ctx, key)

	default:
		logger.Info("Getting ga zonal NetworkEndpointGroup")
		gceObj, err = gceCloud.Compute().NetworkEndpointGroups().Get(ctx, key)
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}
	compositeType, err := toNetworkEndpointGroup(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Scope = meta.Zonal
	compositeType.Version = version
	return compositeType, nil
}

func ListNetworkEndpointGroups(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) ([]*NetworkEndpointGroup, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch key.Type() {
	case meta.Zonal:
	default:
		return nil, fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}
	switch version {
	case meta.VersionAlpha:
		logger.Info("Listing alpha zoneNetworkEndpointGroup")
		gceObjs, err = gceCloud.Compute().AlphaNetworkEndpointGroups().List(ctx, key.Zone, filter.None)
	case meta.VersionBeta:
		logger.Info("Listing beta zoneNetworkEndpointGroup")
		gceObjs, err = gceCloud.Compute().BetaNetworkEndpointGroups().List(ctx, key.Zone, filter.None)
	default:
		logger.Info("Listing ga zoneNetworkEndpointGroup")
		gceObjs, err = gceCloud.Compute().NetworkEndpointGroups().List(ctx, key.Zone, filter.None)
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}

	compositeObjs, err := toNetworkEndpointGroupList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

func AttachNetworkEndpoints(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, req *NetworkEndpointGroupsAttachEndpointsRequest, logger klog.Logger) error {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "attach", key.Region, key.Zone, string(version))

	switch key.Type() {
	case meta.Zonal:
	default:
		return fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}

	switch version {
	case meta.VersionAlpha:
		alphareq, err := req.ToAlpha()
		if err != nil {
			return err
		}
		logger.Info("Attaching to alpha zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().AlphaNetworkEndpointGroups().AttachNetworkEndpoints(ctx, key, alphareq))
	case meta.VersionBeta:
		betareq, err := req.ToBeta()
		if err != nil {
			return err
		}
		logger.Info("Attaching to beta zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().BetaNetworkEndpointGroups().AttachNetworkEndpoints(ctx, key, betareq))
	default:
		gareq, err := req.ToGA()
		if err != nil {
			return err
		}
		logger.Info("Attaching to ga zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().NetworkEndpointGroups().AttachNetworkEndpoints(ctx, key, gareq))
	}
}

func DetachNetworkEndpoints(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, req *NetworkEndpointGroupsDetachEndpointsRequest, logger klog.Logger) error {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "detach", key.Region, key.Zone, string(version))

	switch key.Type() {
	case meta.Zonal:
	default:
		return fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}

	switch version {
	case meta.VersionAlpha:
		alphareq, err := req.ToAlpha()
		if err != nil {
			return err
		}
		logger.Info("Detaching from alpha zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().AlphaNetworkEndpointGroups().DetachNetworkEndpoints(ctx, key, alphareq))
	case meta.VersionBeta:
		betareq, err := req.ToBeta()
		if err != nil {
			return err
		}
		logger.Info("Detaching from beta zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().BetaNetworkEndpointGroups().DetachNetworkEndpoints(ctx, key, betareq))
	default:
		gareq, err := req.ToGA()
		if err != nil {
			return err
		}
		logger.Info("Detaching from ga zonal NetworkEndpointGroup")
		return mc.Observe(gceCloud.Compute().NetworkEndpointGroups().DetachNetworkEndpoints(ctx, key, gareq))
	}
}

func ListNetworkEndpoints(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, req *NetworkEndpointGroupsListEndpointsRequest, logger klog.Logger) ([]*NetworkEndpointWithHealthStatus, error) {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error

	switch key.Type() {
	case meta.Zonal:
	default:
		return nil, fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}

	switch version {
	case meta.VersionAlpha:
		alphareq, reqerr := req.ToAlpha()
		if reqerr != nil {
			return nil, reqerr
		}
		logger.Info("Listing alpha zonal NetworkEndpointGroup")
		gceObjs, err = gceCloud.Compute().AlphaNetworkEndpointGroups().ListNetworkEndpoints(ctx, key, alphareq, filter.None)
	case meta.VersionBeta:
		betareq, reqerr := req.ToBeta()
		if reqerr != nil {
			return nil, reqerr
		}
		logger.Info("Listing beta zonal NetworkEndpointGroup")
		gceObjs, err = gceCloud.Compute().BetaNetworkEndpointGroups().ListNetworkEndpoints(ctx, key, betareq, filter.None)
	default:
		gareq, reqerr := req.ToGA()
		if reqerr != nil {
			return nil, reqerr
		}
		logger.Info("Listing ga zonal NetworkEndpointGroup")
		gceObjs, err = gceCloud.Compute().NetworkEndpointGroups().ListNetworkEndpoints(ctx, key, gareq, filter.None)
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}

	compositeObjs, err := toNetworkEndpointWithHealthStatusList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

func AggregatedListNetworkEndpointGroup(gceCloud *gce.Cloud, version meta.Version, logger klog.Logger) (map[*meta.Key]*NetworkEndpointGroup, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "aggregateList", "", "", string(version))

	compositeMap := make(map[*meta.Key]*NetworkEndpointGroup)
	var gceObjs interface{}

	switch version {
	case meta.VersionAlpha:
		logger.Info("Aggregate List of alpha zonal NetworkEndpointGroup")
		alphaMap, err := gceCloud.Compute().AlphaNetworkEndpointGroups().AggregatedList(ctx, filter.None)
		err = mc.Observe(err)
		if err != nil {
			return nil, err
		}
		// Convert from map to list
		alphaList := []*computealpha.NetworkEndpointGroup{}
		for _, val := range alphaMap {
			alphaList = append(alphaList, val...)
		}
		gceObjs = alphaList
	case meta.VersionBeta:
		logger.Info("Aggregate List of beta zonal NetworkEndpointGroup")
		betaMap, err := gceCloud.Compute().BetaNetworkEndpointGroups().AggregatedList(ctx, filter.None)
		err = mc.Observe(err)
		if err != nil {
			return nil, err
		}
		// Convert from map to list
		betaList := []*computebeta.NetworkEndpointGroup{}
		for _, val := range betaMap {
			betaList = append(betaList, val...)
		}
		gceObjs = betaList
	default:
		logger.Info("Aggregate List of ga zonal NetworkEndpointGroup")
		gaMap, err := gceCloud.Compute().NetworkEndpointGroups().AggregatedList(ctx, filter.None)
		err = mc.Observe(err)
		if err != nil {
			return nil, err
		}
		// Convert from map to list
		gaList := []*compute.NetworkEndpointGroup{}
		for _, val := range gaMap {
			gaList = append(gaList, val...)
		}
		gceObjs = gaList
	}
	compositeObjs, err := toNetworkEndpointGroupList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
		resourceID, err := cloudprovider.ParseResourceURL(obj.SelfLink)
		if err != nil || resourceID == nil || resourceID.Key == nil {
			logger.Error(err, "Failed to parse obj's SelfLink", "selfLink", obj.SelfLink, "obj", obj)
			continue
		}
		compositeMap[resourceID.Key] = obj
	}

	return compositeMap, nil
}

// toNetworkEndpointGroupList converts a list of compute alpha, beta or GA
// NetworkEndpointGroup into a list of our composite type.
func toNetworkEndpointGroupList(objs interface{}) ([]*NetworkEndpointGroup, error) {
	result := []*NetworkEndpointGroup{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpointGroup is for package internal use only (not type-safe).
func toNetworkEndpointGroup(obj interface{}) (*NetworkEndpointGroup, error) {
	x := &NetworkEndpointGroup{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpointGroup convert to a composite type.
func AlphaToNetworkEndpointGroup(obj *computealpha.NetworkEndpointGroup) (*NetworkEndpointGroup, error) {
	x := &NetworkEndpointGroup{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpointGroup convert to a composite type.
func BetaToNetworkEndpointGroup(obj *computebeta.NetworkEndpointGroup) (*NetworkEndpointGroup, error) {
	x := &NetworkEndpointGroup{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpointGroup convert to a composite type.
func GAToNetworkEndpointGroup(obj *compute.NetworkEndpointGroup) (*NetworkEndpointGroup, error) {
	x := &NetworkEndpointGroup{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpointGroup *NetworkEndpointGroup) ToAlpha() (*computealpha.NetworkEndpointGroup, error) {
	alpha := &computealpha.NetworkEndpointGroup{}
	err := copyViaJSON(alpha, networkEndpointGroup)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpointGroup, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpointGroup *NetworkEndpointGroup) ToBeta() (*computebeta.NetworkEndpointGroup, error) {
	beta := &computebeta.NetworkEndpointGroup{}
	err := copyViaJSON(beta, networkEndpointGroup)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpointGroup, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpointGroup *NetworkEndpointGroup) ToGA() (*compute.NetworkEndpointGroup, error) {
	ga := &compute.NetworkEndpointGroup{}
	err := copyViaJSON(ga, networkEndpointGroup)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpointGroup, err)
	}

	return ga, nil
}

// toNetworkEndpointGroupsAttachEndpointsRequestList converts a list of compute alpha, beta or GA
// NetworkEndpointGroupsAttachEndpointsRequest into a list of our composite type.
func toNetworkEndpointGroupsAttachEndpointsRequestList(objs interface{}) ([]*NetworkEndpointGroupsAttachEndpointsRequest, error) {
	result := []*NetworkEndpointGroupsAttachEndpointsRequest{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpointGroupsAttachEndpointsRequest is for package internal use only (not type-safe).
func toNetworkEndpointGroupsAttachEndpointsRequest(obj interface{}) (*NetworkEndpointGroupsAttachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpointGroupsAttachEndpointsRequest convert to a composite type.
func AlphaToNetworkEndpointGroupsAttachEndpointsRequest(obj *computealpha.NetworkEndpointGroupsAttachEndpointsRequest) (*NetworkEndpointGroupsAttachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpointGroupsAttachEndpointsRequest convert to a composite type.
func BetaToNetworkEndpointGroupsAttachEndpointsRequest(obj *computebeta.NetworkEndpointGroupsAttachEndpointsRequest) (*NetworkEndpointGroupsAttachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpointGroupsAttachEndpointsRequest convert to a composite type.
func GAToNetworkEndpointGroupsAttachEndpointsRequest(obj *compute.NetworkEndpointGroupsAttachEndpointsRequest) (*NetworkEndpointGroupsAttachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpointGroupsAttachEndpointsRequest *NetworkEndpointGroupsAttachEndpointsRequest) ToAlpha() (*computealpha.NetworkEndpointGroupsAttachEndpointsRequest, error) {
	alpha := &computealpha.NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(alpha, networkEndpointGroupsAttachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpointGroupsAttachEndpointsRequest, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpointGroupsAttachEndpointsRequest *NetworkEndpointGroupsAttachEndpointsRequest) ToBeta() (*computebeta.NetworkEndpointGroupsAttachEndpointsRequest, error) {
	beta := &computebeta.NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(beta, networkEndpointGroupsAttachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpointGroupsAttachEndpointsRequest, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpointGroupsAttachEndpointsRequest *NetworkEndpointGroupsAttachEndpointsRequest) ToGA() (*compute.NetworkEndpointGroupsAttachEndpointsRequest, error) {
	ga := &compute.NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(ga, networkEndpointGroupsAttachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpointGroupsAttachEndpointsRequest, err)
	}

	return ga, nil
}

// toNetworkEndpointGroupsDetachEndpointsRequestList converts a list of compute alpha, beta or GA
// NetworkEndpointGroupsDetachEndpointsRequest into a list of our composite type.
func toNetworkEndpointGroupsDetachEndpointsRequestList(objs interface{}) ([]*NetworkEndpointGroupsDetachEndpointsRequest, error) {
	result := []*NetworkEndpointGroupsDetachEndpointsRequest{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpointGroupsDetachEndpointsRequest is for package internal use only (not type-safe).
func toNetworkEndpointGroupsDetachEndpointsRequest(obj interface{}) (*NetworkEndpointGroupsDetachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpointGroupsDetachEndpointsRequest convert to a composite type.
func AlphaToNetworkEndpointGroupsDetachEndpointsRequest(obj *computealpha.NetworkEndpointGroupsDetachEndpointsRequest) (*NetworkEndpointGroupsDetachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpointGroupsDetachEndpointsRequest convert to a composite type.
func BetaToNetworkEndpointGroupsDetachEndpointsRequest(obj *computebeta.NetworkEndpointGroupsDetachEndpointsRequest) (*NetworkEndpointGroupsDetachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpointGroupsDetachEndpointsRequest convert to a composite type.
func GAToNetworkEndpointGroupsDetachEndpointsRequest(obj *compute.NetworkEndpointGroupsDetachEndpointsRequest) (*NetworkEndpointGroupsDetachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpointGroupsDetachEndpointsRequest *NetworkEndpointGroupsDetachEndpointsRequest) ToAlpha() (*computealpha.NetworkEndpointGroupsDetachEndpointsRequest, error) {
	alpha := &computealpha.NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(alpha, networkEndpointGroupsDetachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpointGroupsDetachEndpointsRequest, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpointGroupsDetachEndpointsRequest *NetworkEndpointGroupsDetachEndpointsRequest) ToBeta() (*computebeta.NetworkEndpointGroupsDetachEndpointsRequest, error) {
	beta := &computebeta.NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(beta, networkEndpointGroupsDetachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpointGroupsDetachEndpointsRequest, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpointGroupsDetachEndpointsRequest *NetworkEndpointGroupsDetachEndpointsRequest) ToGA() (*compute.NetworkEndpointGroupsDetachEndpointsRequest, error) {
	ga := &compute.NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(ga, networkEndpointGroupsDetachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpointGroupsDetachEndpointsRequest, err)
	}

	return ga, nil
}

// toNetworkEndpointGroupsListEndpointsRequestList converts a list of compute alpha, beta or GA
// NetworkEndpointGroupsListEndpointsRequest into a list of our composite type.
func toNetworkEndpointGroupsListEndpointsRequestList(objs interface{}) ([]*NetworkEndpointGroupsListEndpointsRequest, error) {
	result := []*NetworkEndpointGroupsListEndpointsRequest{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpointGroupsListEndpointsRequest is for package internal use only (not type-safe).
func toNetworkEndpointGroupsListEndpointsRequest(obj interface{}) (*NetworkEndpointGroupsListEndpointsRequest, error) {
	x := &NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpointGroupsListEndpointsRequest convert to a composite type.
func AlphaToNetworkEndpointGroupsListEndpointsRequest(obj *computealpha.NetworkEndpointGroupsListEndpointsRequest) (*NetworkEndpointGroupsListEndpointsRequest, error) {
	x := &NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpointGroupsListEndpointsRequest convert to a composite type.
func BetaToNetworkEndpointGroupsListEndpointsRequest(obj *computebeta.NetworkEndpointGroupsListEndpointsRequest) (*NetworkEndpointGroupsListEndpointsRequest, error) {
	x := &NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpointGroupsListEndpointsRequest convert to a composite type.
func GAToNetworkEndpointGroupsListEndpointsRequest(obj *compute.NetworkEndpointGroupsListEndpointsRequest) (*NetworkEndpointGroupsListEndpointsRequest, error) {
	x := &NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpointGroupsListEndpointsRequest *NetworkEndpointGroupsListEndpointsRequest) ToAlpha() (*computealpha.NetworkEndpointGroupsListEndpointsRequest, error) {
	alpha := &computealpha.NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(alpha, networkEndpointGroupsListEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpointGroupsListEndpointsRequest, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpointGroupsListEndpointsRequest *NetworkEndpointGroupsListEndpointsRequest) ToBeta() (*computebeta.NetworkEndpointGroupsListEndpointsRequest, error) {
	beta := &computebeta.NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(beta, networkEndpointGroupsListEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpointGroupsListEndpointsRequest, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpointGroupsListEndpointsRequest *NetworkEndpointGroupsListEndpointsRequest) ToGA() (*compute.NetworkEndpointGroupsListEndpointsRequest, error) {
	ga := &compute.NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(ga, networkEndpointGroupsListEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpointGroupsListEndpointsRequest, err)
	}

	return ga, nil
}

// toNetworkEndpointWithHealthStatusList converts a list of compute alpha, beta or GA
// NetworkEndpointWithHealthStatus into a list of our composite type.
func toNetworkEndpointWithHealthStatusList(objs interface{}) ([]*NetworkEndpointWithHealthStatus, error) {
	result := []*NetworkEndpointWithHealthStatus{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpointWithHealthStatus is for package internal use only (not type-safe).
func toNetworkEndpointWithHealthStatus(obj interface{}) (*NetworkEndpointWithHealthStatus, error) {
	x := &NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpointWithHealthStatus convert to a composite type.
func AlphaToNetworkEndpointWithHealthStatus(obj *computealpha.NetworkEndpointWithHealthStatus) (*NetworkEndpointWithHealthStatus, error) {
	x := &NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpointWithHealthStatus convert to a composite type.
func BetaToNetworkEndpointWithHealthStatus(obj *computebeta.NetworkEndpointWithHealthStatus) (*NetworkEndpointWithHealthStatus, error) {
	x := &NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpointWithHealthStatus convert to a composite type.
func GAToNetworkEndpointWithHealthStatus(obj *compute.NetworkEndpointWithHealthStatus) (*NetworkEndpointWithHealthStatus, error) {
	x := &NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpointWithHealthStatus *NetworkEndpointWithHealthStatus) ToAlpha() (*computealpha.NetworkEndpointWithHealthStatus, error) {
	alpha := &computealpha.NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(alpha, networkEndpointWithHealthStatus)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpointWithHealthStatus, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpointWithHealthStatus *NetworkEndpointWithHealthStatus) ToBeta() (*computebeta.NetworkEndpointWithHealthStatus, error) {
	beta := &computebeta.NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(beta, networkEndpointWithHealthStatus)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpointWithHealthStatus, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpointWithHealthStatus *NetworkEndpointWithHealthStatus) ToGA() (*compute.NetworkEndpointWithHealthStatus, error) {
	ga := &compute.NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(ga, networkEndpointWithHealthStatus)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpointWithHealthStatus, err)
	}

	return ga, nil
}

// toSignedUrlKeyList converts a list of compute alpha, beta or GA
// SignedUrlKey into a list of our composite type.
func toSignedUrlKeyList(objs interface{}) ([]*SignedUrlKey, error) {
	result := []*SignedUrlKey{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toSignedUrlKey is for package internal use only (not type-safe).
func toSignedUrlKey(obj interface{}) (*SignedUrlKey, error) {
	x := &SignedUrlKey{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToSignedUrlKey convert to a composite type.
func AlphaToSignedUrlKey(obj *computealpha.SignedUrlKey) (*SignedUrlKey, error) {
	x := &SignedUrlKey{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToSignedUrlKey convert to a composite type.
func BetaToSignedUrlKey(obj *computebeta.SignedUrlKey) (*SignedUrlKey, error) {
	x := &SignedUrlKey{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToSignedUrlKey convert to a composite type.
func GAToSignedUrlKey(obj *compute.SignedUrlKey) (*SignedUrlKey, error) {
	x := &SignedUrlKey{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (signedUrlKey *SignedUrlKey) ToAlpha() (*computealpha.SignedUrlKey, error) {
	alpha := &computealpha.SignedUrlKey{}
	err := copyViaJSON(alpha, signedUrlKey)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", signedUrlKey, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (signedUrlKey *SignedUrlKey) ToBeta() (*computebeta.SignedUrlKey, error) {
	beta := &computebeta.SignedUrlKey{}
	err := copyViaJSON(beta, signedUrlKey)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", signedUrlKey, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (signedUrlKey *SignedUrlKey) ToGA() (*compute.SignedUrlKey, error) {
	ga := &compute.SignedUrlKey{}
	err := copyViaJSON(ga, signedUrlKey)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", signedUrlKey, err)
	}

	return ga, nil
}

func CreateSslCertificate(gceCloud *gce.Cloud, key *meta.Key, sslCertificate *SslCertificate, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("SslCertificate", "create", key.Region, key.Zone, string(sslCertificate.Version))

	switch sslCertificate.Version {
	case meta.VersionAlpha:
		alpha, err := sslCertificate.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Creating alpha region SslCertificate")
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionSslCertificates().Insert(ctx, key, alpha))
		default:
			alphaLogger.Info("Creating alpha SslCertificate")
			return mc.Observe(gceCloud.Compute().AlphaSslCertificates().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := sslCertificate.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Creating beta region SslCertificate")
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionSslCertificates().Insert(ctx, key, beta))
		default:
			betaLogger.Info("Creating beta SslCertificate")
			return mc.Observe(gceCloud.Compute().BetaSslCertificates().Insert(ctx, key, beta))
		}
	default:
		ga, err := sslCertificate.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Creating ga region SslCertificate")
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionSslCertificates().Insert(ctx, key, ga))
		default:
			gaLogger.Info("Creating ga SslCertificate")
			return mc.Observe(gceCloud.Compute().SslCertificates().Insert(ctx, key, ga))
		}
	}
}

func DeleteSslCertificate(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) error {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("SslCertificate", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting alpha region SslCertificate")
			return mc.Observe(gceCloud.Compute().AlphaRegionSslCertificates().Delete(ctx, key))
		default:
			logger.Info("Deleting alpha SslCertificate")
			return mc.Observe(gceCloud.Compute().AlphaSslCertificates().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting beta region SslCertificate")
			return mc.Observe(gceCloud.Compute().BetaRegionSslCertificates().Delete(ctx, key))
		default:
			logger.Info("Deleting beta SslCertificate")
			return mc.Observe(gceCloud.Compute().BetaSslCertificates().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting ga region SslCertificate")
			return mc.Observe(gceCloud.Compute().RegionSslCertificates().Delete(ctx, key))
		default:
			logger.Info("Deleting ga SslCertificate")
			return mc.Observe(gceCloud.Compute().SslCertificates().Delete(ctx, key))
		}
	}
}

func GetSslCertificate(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) (*SslCertificate, error) {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("SslCertificate", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting alpha region SslCertificate")
			gceObj, err = gceCloud.Compute().AlphaRegionSslCertificates().Get(ctx, key)
		default:
			logger.Info("Getting alpha SslCertificate")
			gceObj, err = gceCloud.Compute().AlphaSslCertificates().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting beta region SslCertificate")
			gceObj, err = gceCloud.Compute().BetaRegionSslCertificates().Get(ctx, key)
		default:
			logger.Info("Getting beta SslCertificate")
			gceObj, err = gceCloud.Compute().BetaSslCertificates().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting ga region SslCertificate")
			gceObj, err = gceCloud.Compute().RegionSslCertificates().Get(ctx, key)
		default:
			logger.Info("Getting ga SslCertificate")
			gceObj, err = gceCloud.Compute().SslCertificates().Get(ctx, key)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}
	compositeType, err := toSslCertificate(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListSslCertificates(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) ([]*SslCertificate, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("SslCertificate", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing alpha region SslCertificate")
			gceObjs, err = gceCloud.Compute().AlphaRegionSslCertificates().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing alpha SslCertificate")
			gceObjs, err = gceCloud.Compute().AlphaSslCertificates().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing beta region SslCertificate")
			gceObjs, err = gceCloud.Compute().BetaRegionSslCertificates().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing beta SslCertificate")
			gceObjs, err = gceCloud.Compute().BetaSslCertificates().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing ga region SslCertificate")
			gceObjs, err = gceCloud.Compute().RegionSslCertificates().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing ga SslCertificate")
			gceObjs, err = gceCloud.Compute().SslCertificates().List(ctx, filter.None)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}

	compositeObjs, err := toSslCertificateList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toSslCertificateList converts a list of compute alpha, beta or GA
// SslCertificate into a list of our composite type.
func toSslCertificateList(objs interface{}) ([]*SslCertificate, error) {
	result := []*SslCertificate{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toSslCertificate is for package internal use only (not type-safe).
func toSslCertificate(obj interface{}) (*SslCertificate, error) {
	x := &SslCertificate{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToSslCertificate convert to a composite type.
func AlphaToSslCertificate(obj *computealpha.SslCertificate) (*SslCertificate, error) {
	x := &SslCertificate{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToSslCertificate convert to a composite type.
func BetaToSslCertificate(obj *computebeta.SslCertificate) (*SslCertificate, error) {
	x := &SslCertificate{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToSslCertificate convert to a composite type.
func GAToSslCertificate(obj *compute.SslCertificate) (*SslCertificate, error) {
	x := &SslCertificate{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (sslCertificate *SslCertificate) ToAlpha() (*computealpha.SslCertificate, error) {
	alpha := &computealpha.SslCertificate{}
	err := copyViaJSON(alpha, sslCertificate)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", sslCertificate, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (sslCertificate *SslCertificate) ToBeta() (*computebeta.SslCertificate, error) {
	beta := &computebeta.SslCertificate{}
	err := copyViaJSON(beta, sslCertificate)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", sslCertificate, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (sslCertificate *SslCertificate) ToGA() (*compute.SslCertificate, error) {
	ga := &compute.SslCertificate{}
	err := copyViaJSON(ga, sslCertificate)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", sslCertificate, err)
	}

	return ga, nil
}

func CreateTargetHttpProxy(gceCloud *gce.Cloud, key *meta.Key, targetHttpProxy *TargetHttpProxy, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpProxy", "create", key.Region, key.Zone, string(targetHttpProxy.Version))

	switch targetHttpProxy.Version {
	case meta.VersionAlpha:
		alpha, err := targetHttpProxy.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Creating alpha region TargetHttpProxy")
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionTargetHttpProxies().Insert(ctx, key, alpha))
		default:
			alphaLogger.Info("Creating alpha TargetHttpProxy")
			return mc.Observe(gceCloud.Compute().AlphaTargetHttpProxies().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := targetHttpProxy.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Creating beta region TargetHttpProxy")
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionTargetHttpProxies().Insert(ctx, key, beta))
		default:
			betaLogger.Info("Creating beta TargetHttpProxy")
			return mc.Observe(gceCloud.Compute().BetaTargetHttpProxies().Insert(ctx, key, beta))
		}
	default:
		ga, err := targetHttpProxy.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Creating ga region TargetHttpProxy")
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionTargetHttpProxies().Insert(ctx, key, ga))
		default:
			gaLogger.Info("Creating ga TargetHttpProxy")
			return mc.Observe(gceCloud.Compute().TargetHttpProxies().Insert(ctx, key, ga))
		}
	}
}

func DeleteTargetHttpProxy(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) error {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpProxy", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting alpha region TargetHttpProxy")
			return mc.Observe(gceCloud.Compute().AlphaRegionTargetHttpProxies().Delete(ctx, key))
		default:
			logger.Info("Deleting alpha TargetHttpProxy")
			return mc.Observe(gceCloud.Compute().AlphaTargetHttpProxies().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting beta region TargetHttpProxy")
			return mc.Observe(gceCloud.Compute().BetaRegionTargetHttpProxies().Delete(ctx, key))
		default:
			logger.Info("Deleting beta TargetHttpProxy")
			return mc.Observe(gceCloud.Compute().BetaTargetHttpProxies().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting ga region TargetHttpProxy")
			return mc.Observe(gceCloud.Compute().RegionTargetHttpProxies().Delete(ctx, key))
		default:
			logger.Info("Deleting ga TargetHttpProxy")
			return mc.Observe(gceCloud.Compute().TargetHttpProxies().Delete(ctx, key))
		}
	}
}

func GetTargetHttpProxy(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) (*TargetHttpProxy, error) {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpProxy", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting alpha region TargetHttpProxy")
			gceObj, err = gceCloud.Compute().AlphaRegionTargetHttpProxies().Get(ctx, key)
		default:
			logger.Info("Getting alpha TargetHttpProxy")
			gceObj, err = gceCloud.Compute().AlphaTargetHttpProxies().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting beta region TargetHttpProxy")
			gceObj, err = gceCloud.Compute().BetaRegionTargetHttpProxies().Get(ctx, key)
		default:
			logger.Info("Getting beta TargetHttpProxy")
			gceObj, err = gceCloud.Compute().BetaTargetHttpProxies().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting ga region TargetHttpProxy")
			gceObj, err = gceCloud.Compute().RegionTargetHttpProxies().Get(ctx, key)
		default:
			logger.Info("Getting ga TargetHttpProxy")
			gceObj, err = gceCloud.Compute().TargetHttpProxies().Get(ctx, key)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}
	compositeType, err := toTargetHttpProxy(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListTargetHttpProxies(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) ([]*TargetHttpProxy, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpProxy", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing alpha region TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().AlphaRegionTargetHttpProxies().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing alpha TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().AlphaTargetHttpProxies().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing beta region TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().BetaRegionTargetHttpProxies().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing beta TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().BetaTargetHttpProxies().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing ga region TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().RegionTargetHttpProxies().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing ga TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().TargetHttpProxies().List(ctx, filter.None)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}

	compositeObjs, err := toTargetHttpProxyList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toTargetHttpProxyList converts a list of compute alpha, beta or GA
// TargetHttpProxy into a list of our composite type.
func toTargetHttpProxyList(objs interface{}) ([]*TargetHttpProxy, error) {
	result := []*TargetHttpProxy{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toTargetHttpProxy is for package internal use only (not type-safe).
func toTargetHttpProxy(obj interface{}) (*TargetHttpProxy, error) {
	x := &TargetHttpProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToTargetHttpProxy convert to a composite type.
func AlphaToTargetHttpProxy(obj *computealpha.TargetHttpProxy) (*TargetHttpProxy, error) {
	x := &TargetHttpProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToTargetHttpProxy convert to a composite type.
func BetaToTargetHttpProxy(obj *computebeta.TargetHttpProxy) (*TargetHttpProxy, error) {
	x := &TargetHttpProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToTargetHttpProxy convert to a composite type.
func GAToTargetHttpProxy(obj *compute.TargetHttpProxy) (*TargetHttpProxy, error) {
	x := &TargetHttpProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) ToAlpha() (*computealpha.TargetHttpProxy, error) {
	alpha := &computealpha.TargetHttpProxy{}
	err := copyViaJSON(alpha, targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", targetHttpProxy, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) ToBeta() (*computebeta.TargetHttpProxy, error) {
	beta := &computebeta.TargetHttpProxy{}
	err := copyViaJSON(beta, targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", targetHttpProxy, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) ToGA() (*compute.TargetHttpProxy, error) {
	ga := &compute.TargetHttpProxy{}
	err := copyViaJSON(ga, targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", targetHttpProxy, err)
	}

	return ga, nil
}

func CreateTargetHttpsProxy(gceCloud *gce.Cloud, key *meta.Key, targetHttpsProxy *TargetHttpsProxy, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpsProxy", "create", key.Region, key.Zone, string(targetHttpsProxy.Version))

	switch targetHttpsProxy.Version {
	case meta.VersionAlpha:
		alpha, err := targetHttpsProxy.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Creating alpha region TargetHttpsProxy")
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionTargetHttpsProxies().Insert(ctx, key, alpha))
		default:
			alphaLogger.Info("Creating alpha TargetHttpsProxy")
			return mc.Observe(gceCloud.Compute().AlphaTargetHttpsProxies().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := targetHttpsProxy.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Creating beta region TargetHttpsProxy")
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionTargetHttpsProxies().Insert(ctx, key, beta))
		default:
			betaLogger.Info("Creating beta TargetHttpsProxy")
			return mc.Observe(gceCloud.Compute().BetaTargetHttpsProxies().Insert(ctx, key, beta))
		}
	default:
		ga, err := targetHttpsProxy.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Creating ga region TargetHttpsProxy")
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionTargetHttpsProxies().Insert(ctx, key, ga))
		default:
			gaLogger.Info("Creating ga TargetHttpsProxy")
			return mc.Observe(gceCloud.Compute().TargetHttpsProxies().Insert(ctx, key, ga))
		}
	}
}

func DeleteTargetHttpsProxy(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) error {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpsProxy", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting alpha region TargetHttpsProxy")
			return mc.Observe(gceCloud.Compute().AlphaRegionTargetHttpsProxies().Delete(ctx, key))
		default:
			logger.Info("Deleting alpha TargetHttpsProxy")
			return mc.Observe(gceCloud.Compute().AlphaTargetHttpsProxies().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting beta region TargetHttpsProxy")
			return mc.Observe(gceCloud.Compute().BetaRegionTargetHttpsProxies().Delete(ctx, key))
		default:
			logger.Info("Deleting beta TargetHttpsProxy")
			return mc.Observe(gceCloud.Compute().BetaTargetHttpsProxies().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting ga region TargetHttpsProxy")
			return mc.Observe(gceCloud.Compute().RegionTargetHttpsProxies().Delete(ctx, key))
		default:
			logger.Info("Deleting ga TargetHttpsProxy")
			return mc.Observe(gceCloud.Compute().TargetHttpsProxies().Delete(ctx, key))
		}
	}
}

func GetTargetHttpsProxy(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) (*TargetHttpsProxy, error) {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpsProxy", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting alpha region TargetHttpsProxy")
			gceObj, err = gceCloud.Compute().AlphaRegionTargetHttpsProxies().Get(ctx, key)
		default:
			logger.Info("Getting alpha TargetHttpsProxy")
			gceObj, err = gceCloud.Compute().AlphaTargetHttpsProxies().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting beta region TargetHttpsProxy")
			gceObj, err = gceCloud.Compute().BetaRegionTargetHttpsProxies().Get(ctx, key)
		default:
			logger.Info("Getting beta TargetHttpsProxy")
			gceObj, err = gceCloud.Compute().BetaTargetHttpsProxies().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting ga region TargetHttpsProxy")
			gceObj, err = gceCloud.Compute().RegionTargetHttpsProxies().Get(ctx, key)
		default:
			logger.Info("Getting ga TargetHttpsProxy")
			gceObj, err = gceCloud.Compute().TargetHttpsProxies().Get(ctx, key)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}
	compositeType, err := toTargetHttpsProxy(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListTargetHttpsProxies(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) ([]*TargetHttpsProxy, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpsProxy", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing alpha region TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().AlphaRegionTargetHttpsProxies().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing alpha TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().AlphaTargetHttpsProxies().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing beta region TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().BetaRegionTargetHttpsProxies().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing beta TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().BetaTargetHttpsProxies().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing ga region TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().RegionTargetHttpsProxies().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing ga TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().TargetHttpsProxies().List(ctx, filter.None)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}

	compositeObjs, err := toTargetHttpsProxyList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toTargetHttpsProxyList converts a list of compute alpha, beta or GA
// TargetHttpsProxy into a list of our composite type.
func toTargetHttpsProxyList(objs interface{}) ([]*TargetHttpsProxy, error) {
	result := []*TargetHttpsProxy{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toTargetHttpsProxy is for package internal use only (not type-safe).
func toTargetHttpsProxy(obj interface{}) (*TargetHttpsProxy, error) {
	x := &TargetHttpsProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToTargetHttpsProxy convert to a composite type.
func AlphaToTargetHttpsProxy(obj *computealpha.TargetHttpsProxy) (*TargetHttpsProxy, error) {
	x := &TargetHttpsProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToTargetHttpsProxy convert to a composite type.
func BetaToTargetHttpsProxy(obj *computebeta.TargetHttpsProxy) (*TargetHttpsProxy, error) {
	x := &TargetHttpsProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToTargetHttpsProxy convert to a composite type.
func GAToTargetHttpsProxy(obj *compute.TargetHttpsProxy) (*TargetHttpsProxy, error) {
	x := &TargetHttpsProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) ToAlpha() (*computealpha.TargetHttpsProxy, error) {
	alpha := &computealpha.TargetHttpsProxy{}
	err := copyViaJSON(alpha, targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", targetHttpsProxy, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) ToBeta() (*computebeta.TargetHttpsProxy, error) {
	beta := &computebeta.TargetHttpsProxy{}
	err := copyViaJSON(beta, targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", targetHttpsProxy, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) ToGA() (*compute.TargetHttpsProxy, error) {
	ga := &compute.TargetHttpsProxy{}
	err := copyViaJSON(ga, targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", targetHttpsProxy, err)
	}

	return ga, nil
}

func CreateUrlMap(gceCloud *gce.Cloud, key *meta.Key, urlMap *UrlMap, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "create", key.Region, key.Zone, string(urlMap.Version))

	switch urlMap.Version {
	case meta.VersionAlpha:
		alpha, err := urlMap.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Creating alpha region UrlMap")
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionUrlMaps().Insert(ctx, key, alpha))
		default:
			alphaLogger.Info("Creating alpha UrlMap")
			return mc.Observe(gceCloud.Compute().AlphaUrlMaps().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := urlMap.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Creating beta region UrlMap")
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionUrlMaps().Insert(ctx, key, beta))
		default:
			betaLogger.Info("Creating beta UrlMap")
			return mc.Observe(gceCloud.Compute().BetaUrlMaps().Insert(ctx, key, beta))
		}
	default:
		ga, err := urlMap.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Creating ga region UrlMap")
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionUrlMaps().Insert(ctx, key, ga))
		default:
			gaLogger.Info("Creating ga UrlMap")
			return mc.Observe(gceCloud.Compute().UrlMaps().Insert(ctx, key, ga))
		}
	}
}

func UpdateUrlMap(gceCloud *gce.Cloud, key *meta.Key, urlMap *UrlMap, logger klog.Logger) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "update", key.Region, key.Zone, string(urlMap.Version))
	switch urlMap.Version {
	case meta.VersionAlpha:
		alpha, err := urlMap.ToAlpha()
		if err != nil {
			return err
		}
		alphaLogger := logger.WithValues("name", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			alphaLogger.Info("Updating alpha region UrlMap")
			return mc.Observe(gceCloud.Compute().AlphaRegionUrlMaps().Update(ctx, key, alpha))
		default:
			alphaLogger.Info("Updating alpha UrlMap")
			return mc.Observe(gceCloud.Compute().AlphaUrlMaps().Update(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := urlMap.ToBeta()
		if err != nil {
			return err
		}
		betaLogger := logger.WithValues("name", beta.Name)
		switch key.Type() {
		case meta.Regional:
			betaLogger.Info("Updating beta region UrlMap")
			return mc.Observe(gceCloud.Compute().BetaRegionUrlMaps().Update(ctx, key, beta))
		default:
			betaLogger.Info("Updating beta UrlMap")
			return mc.Observe(gceCloud.Compute().BetaUrlMaps().Update(ctx, key, beta))
		}
	default:
		ga, err := urlMap.ToGA()
		if err != nil {
			return err
		}
		gaLogger := logger.WithValues("name", ga.Name)
		switch key.Type() {
		case meta.Regional:
			gaLogger.Info("Updating ga region UrlMap")
			return mc.Observe(gceCloud.Compute().RegionUrlMaps().Update(ctx, key, ga))
		default:
			gaLogger.Info("Updating ga UrlMap")
			return mc.Observe(gceCloud.Compute().UrlMaps().Update(ctx, key, ga))
		}
	}
}

func DeleteUrlMap(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) error {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting alpha region UrlMap")
			return mc.Observe(gceCloud.Compute().AlphaRegionUrlMaps().Delete(ctx, key))
		default:
			logger.Info("Deleting alpha UrlMap")
			return mc.Observe(gceCloud.Compute().AlphaUrlMaps().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting beta region UrlMap")
			return mc.Observe(gceCloud.Compute().BetaRegionUrlMaps().Delete(ctx, key))
		default:
			logger.Info("Deleting beta UrlMap")
			return mc.Observe(gceCloud.Compute().BetaUrlMaps().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Deleting ga region UrlMap")
			return mc.Observe(gceCloud.Compute().RegionUrlMaps().Delete(ctx, key))
		default:
			logger.Info("Deleting ga UrlMap")
			return mc.Observe(gceCloud.Compute().UrlMaps().Delete(ctx, key))
		}
	}
}

func GetUrlMap(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) (*UrlMap, error) {
	logger = logger.WithValues("name", key.Name)
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting alpha region UrlMap")
			gceObj, err = gceCloud.Compute().AlphaRegionUrlMaps().Get(ctx, key)
		default:
			logger.Info("Getting alpha UrlMap")
			gceObj, err = gceCloud.Compute().AlphaUrlMaps().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting beta region UrlMap")
			gceObj, err = gceCloud.Compute().BetaRegionUrlMaps().Get(ctx, key)
		default:
			logger.Info("Getting beta UrlMap")
			gceObj, err = gceCloud.Compute().BetaUrlMaps().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Getting ga region UrlMap")
			gceObj, err = gceCloud.Compute().RegionUrlMaps().Get(ctx, key)
		default:
			logger.Info("Getting ga UrlMap")
			gceObj, err = gceCloud.Compute().UrlMaps().Get(ctx, key)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}
	compositeType, err := toUrlMap(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListUrlMaps(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, logger klog.Logger) ([]*UrlMap, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing alpha region UrlMap")
			gceObjs, err = gceCloud.Compute().AlphaRegionUrlMaps().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing alpha UrlMap")
			gceObjs, err = gceCloud.Compute().AlphaUrlMaps().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing beta region UrlMap")
			gceObjs, err = gceCloud.Compute().BetaRegionUrlMaps().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing beta UrlMap")
			gceObjs, err = gceCloud.Compute().BetaUrlMaps().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			logger.Info("Listing ga region UrlMap")
			gceObjs, err = gceCloud.Compute().RegionUrlMaps().List(ctx, key.Region, filter.None)
		default:
			logger.Info("Listing ga UrlMap")
			gceObjs, err = gceCloud.Compute().UrlMaps().List(ctx, filter.None)
		}
	}
	err = mc.Observe(err)
	if err != nil {
		return nil, err
	}

	compositeObjs, err := toUrlMapList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toUrlMapList converts a list of compute alpha, beta or GA
// UrlMap into a list of our composite type.
func toUrlMapList(objs interface{}) ([]*UrlMap, error) {
	result := []*UrlMap{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toUrlMap is for package internal use only (not type-safe).
func toUrlMap(obj interface{}) (*UrlMap, error) {
	x := &UrlMap{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToUrlMap convert to a composite type.
func AlphaToUrlMap(obj *computealpha.UrlMap) (*UrlMap, error) {
	x := &UrlMap{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToUrlMap convert to a composite type.
func BetaToUrlMap(obj *computebeta.UrlMap) (*UrlMap, error) {
	x := &UrlMap{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToUrlMap convert to a composite type.
func GAToUrlMap(obj *compute.UrlMap) (*UrlMap, error) {
	x := &UrlMap{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (urlMap *UrlMap) ToAlpha() (*computealpha.UrlMap, error) {
	alpha := &computealpha.UrlMap{}
	err := copyViaJSON(alpha, urlMap)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", urlMap, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (urlMap *UrlMap) ToBeta() (*computebeta.UrlMap, error) {
	beta := &computebeta.UrlMap{}
	err := copyViaJSON(beta, urlMap)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", urlMap, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (urlMap *UrlMap) ToGA() (*compute.UrlMap, error) {
	ga := &compute.UrlMap{}
	err := copyViaJSON(ga, urlMap)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", urlMap, err)
	}

	return ga, nil
}
