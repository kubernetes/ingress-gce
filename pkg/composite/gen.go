/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// This file was generated by "./hack/update-codegen.sh". Do not edit directly.
// directly.

package composite

import (
	"fmt"

	cloudprovider "github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud"
	"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud/filter"
	"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud/meta"
	computealpha "google.golang.org/api/compute/v0.alpha"
	computebeta "google.golang.org/api/compute/v0.beta"
	compute "google.golang.org/api/compute/v1"
	"google.golang.org/api/googleapi"
	compositemetrics "k8s.io/ingress-gce/pkg/composite/metrics"
	"k8s.io/klog"
	"k8s.io/legacy-cloud-providers/gce"
)

// Address is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Address struct {
	// Version keeps track of the intended compute version for this Address.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// The static IP address represented by this resource.
	Address string `json:"address,omitempty"`
	// The type of address to reserve, either INTERNAL or EXTERNAL. If
	// unspecified, defaults to EXTERNAL.
	AddressType string `json:"addressType,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this field when you
	// create the resource.
	Description string `json:"description,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// The IP version that will be used by this address. Valid options are
	// IPV4 or IPV6. This can only be specified for a global address.
	IpVersion string `json:"ipVersion,omitempty"`
	// [Output Only] Type of the resource. Always compute#address for
	// addresses.
	Kind string `json:"kind,omitempty"`
	// A fingerprint for the labels being applied to this Address, which is
	// essentially a hash of the labels set used for optimistic locking. The
	// fingerprint is initially generated by Compute Engine and changes
	// after every request to modify or update labels. You must always
	// provide an up-to-date fingerprint hash in order to update or change
	// labels, otherwise the request will fail with error 412
	// conditionNotMet.
	//
	// To see the latest fingerprint, make a get() request to retrieve an
	// Address.
	LabelFingerprint string `json:"labelFingerprint,omitempty"`
	// Labels for this resource. These can only be added or modified by the
	// setLabels method. Each label key/value pair must comply with RFC1035.
	// Label values may be empty.
	Labels map[string]string `json:"labels,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first
	// character must be a lowercase letter, and all following characters
	// (except for the last character) must be a dash, lowercase letter, or
	// digit. The last character must be a lowercase letter or digit.
	Name string `json:"name,omitempty"`
	// The URL of the network in which to reserve the address. This field
	// can only be used with INTERNAL type with the VPC_PEERING purpose.
	Network string `json:"network,omitempty"`
	// This signifies the networking tier used for configuring this address
	// and can only take the following values: PREMIUM or STANDARD. Global
	// forwarding rules can only be Premium Tier. Regional forwarding rules
	// can be either Premium or Standard Tier. Standard Tier addresses
	// applied to regional forwarding rules can be used with any external
	// load balancer. Regional forwarding rules in Premium Tier can only be
	// used with a network load balancer.
	//
	// If this field is not specified, it is assumed to be PREMIUM.
	NetworkTier string `json:"networkTier,omitempty"`
	// The prefix length if the resource represents an IP range.
	PrefixLength int64 `json:"prefixLength,omitempty"`
	// The purpose of this resource, which can be one of the following
	// values:
	// - `GCE_ENDPOINT` for addresses that are used by VM instances, alias
	// IP ranges, internal load balancers, and similar resources.
	// - `DNS_RESOLVER` for a DNS resolver address in a subnetwork
	// - `VPC_PEERING` for addresses that are reserved for VPC peer
	// networks.
	// - `NAT_AUTO` for addresses that are external IP addresses
	// automatically reserved for Cloud NAT.
	// - `IPSEC_INTERCONNECT` for addresses created from a private IP range
	// that are reserved for a VLAN attachment in an IPsec-encrypted Cloud
	// Interconnect configuration. These addresses are regional resources.
	Purpose string `json:"purpose,omitempty"`
	// [Output Only] The URL of the region where a regional address resides.
	// For regional addresses, you must specify the region as a path
	// parameter in the HTTP request URL. This field is not applicable to
	// global addresses.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// [Output Only] The status of the address, which can be one of
	// RESERVING, RESERVED, or IN_USE. An address that is RESERVING is
	// currently in the process of being reserved. A RESERVED address is
	// currently reserved and available to use. An IN_USE address is
	// currently being used by another resource and is not available.
	Status string `json:"status,omitempty"`
	// The URL of the subnetwork in which to reserve the address. If an IP
	// address is specified, it must be within the subnetwork's IP range.
	// This field can only be used with INTERNAL type with a GCE_ENDPOINT or
	// DNS_RESOLVER purpose.
	Subnetwork string `json:"subnetwork,omitempty"`
	// [Output Only] The URLs of the resources that are using this address.
	Users                    []string `json:"users,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// AuthenticationPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type AuthenticationPolicy struct {
	// List of authentication methods that can be used for origin
	// authentication. Similar to peers, these will be evaluated in order
	// the first valid one will be used to set origin identity. If none of
	// these methods pass, the request will be rejected with authentication
	// failed error (401). Leave the list empty if origin authentication is
	// not required.
	Origins []*OriginAuthenticationMethod `json:"origins,omitempty"`
	// List of authentication methods that can be used for peer
	// authentication. They will be evaluated in order the first valid one
	// will be used to set peer identity. If none of these methods pass, the
	// request will be rejected with authentication failed error (401).
	// Leave the list empty if peer authentication is not required.
	Peers []*PeerAuthenticationMethod `json:"peers,omitempty"`
	// Define whether peer or origin identity should be used for principal.
	// Default value is USE_PEER. If peer (or origin) identity is not
	// available, either because peer/origin authentication is not defined,
	// or failed, principal will be left unset. In other words, binding rule
	// does not affect the decision to accept or reject request. This field
	// can be set to one of the following: USE_PEER: Principal will be set
	// to the identity from peer authentication. USE_ORIGIN: Principal will
	// be set to the identity from origin authentication.
	PrincipalBinding string `json:"principalBinding,omitempty"`
	// Configures the mechanism to obtain server-side security certificates
	// and identity information.
	ServerTlsContext *TlsContext `json:"serverTlsContext,omitempty"`
	ForceSendFields  []string    `json:"-"`
	NullFields       []string    `json:"-"`
}

// AuthorizationConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type AuthorizationConfig struct {
	// List of RbacPolicies.
	Policies        []*RbacPolicy `json:"policies,omitempty"`
	ForceSendFields []string      `json:"-"`
	NullFields      []string      `json:"-"`
}

// Backend is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Backend struct {
	// Specifies how to determine whether the backend of a load balancer can
	// handle additional traffic or is fully loaded. For usage guidelines,
	// see  Connection balancing mode.
	BalancingMode string `json:"balancingMode,omitempty"`
	// A multiplier applied to the backend's target capacity of its
	// balancing mode. The default value is 1, which means the group serves
	// up to 100% of its configured capacity (depending on balancingMode). A
	// setting of 0 means the group is completely drained, offering 0% of
	// its available capacity. The valid ranges are 0.0 and [0.1,1.0]. You
	// cannot configure a setting larger than 0 and smaller than 0.1. You
	// cannot configure a setting of 0 when there is only one backend
	// attached to the backend service.
	//
	// Not supported by:
	//
	// - Internal TCP/UDP Load Balancing - Network Load Balancing
	CapacityScaler float64 `json:"capacityScaler,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// This field designates whether this is a failover backend. More than
	// one failover backend can be configured for a given BackendService.
	Failover bool `json:"failover,omitempty"`
	// The fully-qualified URL of an instance group or network endpoint
	// group (NEG) resource. The type of backend that a backend service
	// supports depends on the backend service's loadBalancingScheme.
	//
	//
	// - When the loadBalancingScheme for the backend service is EXTERNAL
	// (except Network Load Balancing),  INTERNAL_SELF_MANAGED, or
	// INTERNAL_MANAGED , the backend can be either an instance group or a
	// NEG. The backends on the backend service must be either all instance
	// groups or all NEGs. You cannot mix instance group and NEG backends on
	// the same backend service.
	//
	//
	// - When the loadBalancingScheme for the backend service is EXTERNAL
	// for Network Load Balancing or INTERNAL for Internal TCP/UDP Load
	// Balancing, the backend must be an instance group. NEGs are not
	// supported.
	//
	// For regional services, the backend must be in the same region as the
	// backend service.
	//
	// You must use the fully-qualified URL (starting with
	// https://www.googleapis.com/) to specify the instance group or NEG.
	// Partial URLs are not supported.
	Group string `json:"group,omitempty"`
	// Defines a target maximum number of simultaneous connections. For
	// usage guidelines, see Connection balancing mode and Utilization
	// balancing mode. Not available if the backend's balancingMode is RATE.
	// Not supported by:
	//
	// - Internal TCP/UDP Load Balancing - Network Load Balancing
	MaxConnections int64 `json:"maxConnections,omitempty"`
	// Defines a target maximum number of simultaneous connections. For
	// usage guidelines, see Connection balancing mode and Utilization
	// balancing mode.
	//
	// Not available if the backend's balancingMode is RATE. Not supported
	// by:
	//
	// - Internal TCP/UDP Load Balancing - Network Load Balancing.
	MaxConnectionsPerEndpoint int64 `json:"maxConnectionsPerEndpoint,omitempty"`
	// Defines a target maximum number of simultaneous connections. For
	// usage guidelines, see Connection balancing mode and Utilization
	// balancing mode.
	//
	// Not available if the backend's balancingMode is RATE. Not supported
	// by:
	//
	// - Internal TCP/UDP Load Balancing - Network Load Balancing.
	MaxConnectionsPerInstance int64 `json:"maxConnectionsPerInstance,omitempty"`
	// Defines a maximum number of HTTP requests per second (RPS). For usage
	// guidelines, see Rate balancing mode and Utilization balancing
	// mode.
	//
	// Not available if the backend's balancingMode is CONNECTION.
	MaxRate int64 `json:"maxRate,omitempty"`
	// Defines a maximum target for requests per second (RPS). For usage
	// guidelines, see Rate balancing mode and Utilization balancing
	// mode.
	//
	// Not available if the backend's balancingMode is CONNECTION.
	MaxRatePerEndpoint float64 `json:"maxRatePerEndpoint,omitempty"`
	// Defines a maximum target for requests per second (RPS). For usage
	// guidelines, see Rate balancing mode and Utilization balancing
	// mode.
	//
	// Not available if the backend's balancingMode is CONNECTION.
	MaxRatePerInstance float64  `json:"maxRatePerInstance,omitempty"`
	MaxUtilization     float64  `json:"maxUtilization,omitempty"`
	ForceSendFields    []string `json:"-"`
	NullFields         []string `json:"-"`
}

// BackendService is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendService struct {
	// Version keeps track of the intended compute version for this BackendService.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// Lifetime of cookies in seconds. Only applicable if the
	// loadBalancingScheme is EXTERNAL, INTERNAL_SELF_MANAGED, or
	// INTERNAL_MANAGED, the protocol is HTTP or HTTPS, and the
	// sessionAffinity is GENERATED_COOKIE, or HTTP_COOKIE.
	//
	// If set to 0, the cookie is non-persistent and lasts only until the
	// end of the browser session (or equivalent). The maximum allowed value
	// is one day (86,400).
	//
	// Not supported when the backend service is referenced by a URL map
	// that is bound to target gRPC proxy that has validateForProxyless
	// field set to true.
	AffinityCookieTtlSec int64 `json:"affinityCookieTtlSec,omitempty"`
	// The list of backends that serve this BackendService.
	Backends []*Backend `json:"backends,omitempty"`
	// Cloud CDN configuration for this BackendService. Only available for
	// external HTTP(S) Load Balancing.
	CdnPolicy *BackendServiceCdnPolicy `json:"cdnPolicy,omitempty"`
	// Settings controlling the volume of connections to a backend service.
	// If not set, this feature is considered disabled.
	//
	// This field is applicable to either:
	// - A regional backend service with the service_protocol set to HTTP,
	// HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
	//
	// - A global backend service with the load_balancing_scheme set to
	// INTERNAL_SELF_MANAGED.
	//
	// Not supported when the backend service is referenced by a URL map
	// that is bound to target gRPC proxy that has validateForProxyless
	// field set to true.
	CircuitBreakers          *CircuitBreakers                        `json:"circuitBreakers,omitempty"`
	ConnectionDraining       *ConnectionDraining                     `json:"connectionDraining,omitempty"`
	ConnectionTrackingPolicy *BackendServiceConnectionTrackingPolicy `json:"connectionTrackingPolicy,omitempty"`
	// Consistent Hash-based load balancing can be used to provide soft
	// session affinity based on HTTP headers, cookies or other properties.
	// This load balancing policy is applicable only for HTTP connections.
	// The affinity to a particular destination host will be lost when one
	// or more hosts are added/removed from the destination service. This
	// field specifies parameters that control consistent hashing. This
	// field is only applicable when localityLbPolicy is set to MAGLEV or
	// RING_HASH.
	//
	// This field is applicable to either:
	// - A regional backend service with the service_protocol set to HTTP,
	// HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
	//
	// - A global backend service with the load_balancing_scheme set to
	// INTERNAL_SELF_MANAGED.
	//
	// Not supported when the backend service is referenced by a URL map
	// that is bound to target gRPC proxy that has validateForProxyless
	// field set to true.
	ConsistentHash *ConsistentHashLoadBalancerSettings `json:"consistentHash,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// Headers that the HTTP/S load balancer should add to proxied requests.
	CustomRequestHeaders []string `json:"customRequestHeaders,omitempty"`
	// Headers that the HTTP/S load balancer should add to proxied
	// responses.
	CustomResponseHeaders []string `json:"customResponseHeaders,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// [Output Only] The resource URL for the edge security policy
	// associated with this backend service.
	EdgeSecurityPolicy string `json:"edgeSecurityPolicy,omitempty"`
	// If true, enables Cloud CDN for the backend service. Only applicable
	// if the loadBalancingScheme is EXTERNAL and the protocol is HTTP or
	// HTTPS.
	EnableCDN bool `json:"enableCDN,omitempty"`
	// Applicable only to Failover for Internal TCP/UDP Load Balancing and
	// Network Load Balancing. Requires at least one backend instance group
	// to be defined as a backup (failover) backend.
	FailoverPolicy *BackendServiceFailoverPolicy `json:"failoverPolicy,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a BackendService. An up-to-date fingerprint
	// must be provided in order to update the BackendService, otherwise the
	// request will fail with error 412 conditionNotMet.
	//
	// To see the latest fingerprint, make a get() request to retrieve a
	// BackendService.
	Fingerprint string `json:"fingerprint,omitempty"`
	// The list of URLs to the healthChecks, httpHealthChecks (legacy), or
	// httpsHealthChecks (legacy) resource for health checking this backend
	// service. Not all backend services support legacy health checks. See
	// Load balancer guide. Currently, at most one health check can be
	// specified for each backend service. Backend services with instance
	// group or zonal NEG backends must have a health check. Backend
	// services with internet or serverless NEG backends must not have a
	// health check.
	HealthChecks []string `json:"healthChecks,omitempty"`
	// The configurations for Identity-Aware Proxy on this resource. Not
	// available for Internal TCP/UDP Load Balancing and Network Load
	// Balancing.
	Iap *BackendServiceIAP `json:"iap,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of resource. Always compute#backendService for
	// backend services.
	Kind string `json:"kind,omitempty"`
	// Specifies the load balancer type. Choose EXTERNAL for external
	// HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose
	// INTERNAL for Internal TCP/UDP Load Balancing. Choose
	// INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.
	// INTERNAL_SELF_MANAGED for Traffic Director. A backend service created
	// for one type of load balancer cannot be used with another. For more
	// information, refer to Choosing a load balancer.
	LoadBalancingScheme string `json:"loadBalancingScheme,omitempty"`
	// The load balancing algorithm used within the scope of the locality.
	// The possible values are:
	// - ROUND_ROBIN: This is a simple policy in which each healthy backend
	// is selected in round robin order. This is the default.
	// - LEAST_REQUEST: An O(1) algorithm which selects two random healthy
	// hosts and picks the host which has fewer active requests.
	// - RING_HASH: The ring/modulo hash load balancer implements consistent
	// hashing to backends. The algorithm has the property that the
	// addition/removal of a host from a set of N hosts only affects 1/N of
	// the requests.
	// - RANDOM: The load balancer selects a random healthy host.
	// - ORIGINAL_DESTINATION: Backend host is selected based on the client
	// connection metadata, i.e., connections are opened to the same address
	// as the destination address of the incoming connection before the
	// connection was redirected to the load balancer.
	// - MAGLEV: used as a drop in replacement for the ring hash load
	// balancer. Maglev is not as stable as ring hash but has faster table
	// lookup build times and host selection times. For more information
	// about Maglev, see https://ai.google/research/pubs/pub44824
	//
	// This field is applicable to either:
	// - A regional backend service with the service_protocol set to HTTP,
	// HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
	//
	// - A global backend service with the load_balancing_scheme set to
	// INTERNAL_SELF_MANAGED.
	//
	// If sessionAffinity is not NONE, and this field is not set to MAGLEV
	// or RING_HASH, session affinity settings will not take effect.
	//
	// Only the default ROUND_ROBIN policy is supported when the backend
	// service is referenced by a URL map that is bound to target gRPC proxy
	// that has validateForProxyless field set to true.
	LocalityLbPolicy string `json:"localityLbPolicy,omitempty"`
	// This field denotes the logging options for the load balancer traffic
	// served by this backend service. If logging is enabled, logs will be
	// exported to Stackdriver.
	LogConfig *BackendServiceLogConfig `json:"logConfig,omitempty"`
	// Specifies the default maximum duration (timeout) for streams to this
	// service. Duration is computed from the beginning of the stream until
	// the response has been completely processed, including all retries. A
	// stream that does not complete in this duration is closed.
	// If not specified, there will be no timeout limit, i.e. the maximum
	// duration is infinite.
	// This field is only allowed when the loadBalancingScheme of the
	// backend service is INTERNAL_SELF_MANAGED.
	MaxStreamDuration *Duration `json:"maxStreamDuration,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// The URL of the network to which this backend service belongs. This
	// field can only be specified when the load balancing scheme is set to
	// INTERNAL.
	Network string `json:"network,omitempty"`
	// Settings controlling the eviction of unhealthy hosts from the load
	// balancing pool for the backend service. If not set, this feature is
	// considered disabled.
	//
	// This field is applicable to either:
	// - A regional backend service with the service_protocol set to HTTP,
	// HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
	//
	// - A global backend service with the load_balancing_scheme set to
	// INTERNAL_SELF_MANAGED.
	//
	// Not supported when the backend service is referenced by a URL map
	// that is bound to target gRPC proxy that has validateForProxyless
	// field set to true.
	OutlierDetection *OutlierDetection `json:"outlierDetection,omitempty"`
	// Deprecated in favor of portName. The TCP port to connect on the
	// backend. The default value is 80.
	//
	// Backend services for Internal TCP/UDP Load Balancing and Network Load
	// Balancing require you omit port.
	Port int64 `json:"port,omitempty"`
	// A named port on a backend instance group representing the port for
	// communication to the backend VMs in that group. Required when the
	// loadBalancingScheme is EXTERNAL (except Network Load Balancing),
	// INTERNAL_MANAGED, or  INTERNAL_SELF_MANAGED and the backends are
	// instance groups. The named port must be defined on each backend
	// instance group. This parameter has no meaning if the backends are
	// NEGs.
	//
	//
	//
	// Backend services for Internal TCP/UDP Load Balancing and Network Load
	// Balancing require you omit port_name.
	PortName string `json:"portName,omitempty"`
	// The protocol this BackendService uses to communicate with
	// backends.
	//
	// Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC.
	// depending on the chosen load balancer or Traffic Director
	// configuration. Refer to the documentation for the load balancer or
	// for Traffic Director for more information.
	//
	// Must be set to GRPC when the backend service is referenced by a URL
	// map that is bound to target gRPC proxy.
	Protocol string `json:"protocol,omitempty"`
	// [Output Only] URL of the region where the regional backend service
	// resides. This field is not applicable to global backend services. You
	// must specify this field as part of the HTTP request URL. It is not
	// settable as a field in the request body.
	Region string `json:"region,omitempty"`
	// [Output Only] The resource URL for the security policy associated
	// with this backend service.
	SecurityPolicy string `json:"securityPolicy,omitempty"`
	// This field specifies the security policy that applies to this backend
	// service. This field is applicable to either:
	// - A regional backend service with the service_protocol set to HTTP,
	// HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
	//
	// - A global backend service with the load_balancing_scheme set to
	// INTERNAL_SELF_MANAGED.
	SecuritySettings *SecuritySettings `json:"securitySettings,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// Type of session affinity to use. The default is NONE.
	//
	// When the loadBalancingScheme is EXTERNAL: * For Network Load
	// Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO,
	// or  CLIENT_IP_PORT_PROTO. * For all other load balancers that use
	// loadBalancingScheme=EXTERNAL, the possible values are NONE,
	// CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the
	// protocol is HTTP, HTTP2, or HTTPS.
	//
	// When the loadBalancingScheme is INTERNAL, possible values are NONE,
	// CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
	//
	// When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or
	// INTERNAL_MANAGED, possible values are NONE, CLIENT_IP,
	// GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
	//
	// Not supported when the backend service is referenced by a URL map
	// that is bound to target gRPC proxy that has validateForProxyless
	// field set to true.
	SessionAffinity string      `json:"sessionAffinity,omitempty"`
	Subsetting      *Subsetting `json:"subsetting,omitempty"`
	// The backend service timeout has a different meaning depending on the
	// type of load balancer. For more information see,  Backend service
	// settings The default is 30 seconds. The full range of timeout values
	// allowed is 1 - 2,147,483,647 seconds.
	TimeoutSec               int64 `json:"timeoutSec,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// BackendServiceCdnPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceCdnPolicy struct {
	// Bypass the cache when the specified request headers are matched -
	// e.g. Pragma or Authorization headers. Up to 5 headers can be
	// specified. The cache is bypassed for all cdnPolicy.cacheMode
	// settings.
	BypassCacheOnRequestHeaders []*BackendServiceCdnPolicyBypassCacheOnRequestHeader `json:"bypassCacheOnRequestHeaders,omitempty"`
	// The CacheKeyPolicy for this CdnPolicy.
	CacheKeyPolicy *CacheKeyPolicy `json:"cacheKeyPolicy,omitempty"`
	// Specifies the cache setting for all responses from this backend. The
	// possible values are:
	//
	// USE_ORIGIN_HEADERS Requires the origin to set valid caching headers
	// to cache content. Responses without these headers will not be cached
	// at Google's edge, and will require a full trip to the origin on every
	// request, potentially impacting performance and increasing load on the
	// origin server.
	//
	// FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store"
	// or "no-cache" directives in Cache-Control response headers. Warning:
	// this may result in Cloud CDN caching private, per-user (user
	// identifiable) content.
	//
	// CACHE_ALL_STATIC Automatically cache static content, including common
	// image formats, media (video and audio), and web assets (JavaScript
	// and CSS). Requests and responses that are marked as uncacheable, as
	// well as dynamic content (including HTML), will not be cached.
	CacheMode string `json:"cacheMode,omitempty"`
	// Specifies a separate client (e.g. browser client) maximum TTL. This
	// is used to clamp the max-age (or Expires) value sent to the client.
	// With FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is
	// used for the response max-age directive, along with a "public"
	// directive. For cacheable content in CACHE_ALL_STATIC mode, client_ttl
	// clamps the max-age from the origin (if specified), or else sets the
	// response max-age directive to the lesser of the client_ttl and
	// default_ttl, and also ensures a "public" cache-control directive is
	// present. If a client TTL is not specified, a default value (1 hour)
	// will be used. The maximum allowed value is 86400s (1 day).
	ClientTtl int64 `json:"clientTtl,omitempty"`
	// Specifies the default TTL for cached content served by this origin
	// for responses that do not have an existing valid TTL (max-age or
	// s-max-age). Setting a TTL of "0" means "always revalidate". The value
	// of defaultTTL cannot be set to a value greater than that of maxTTL,
	// but can be equal. When the cacheMode is set to FORCE_CACHE_ALL, the
	// defaultTTL will overwrite the TTL set in all responses. The maximum
	// allowed value is 31,622,400s (1 year), noting that infrequently
	// accessed objects may be evicted from the cache before the defined
	// TTL.
	DefaultTtl int64 `json:"defaultTtl,omitempty"`
	// Specifies the maximum allowed TTL for cached content served by this
	// origin. Cache directives that attempt to set a max-age or s-maxage
	// higher than this, or an Expires header more than maxTTL seconds in
	// the future will be capped at the value of maxTTL, as if it were the
	// value of an s-maxage Cache-Control directive. Headers sent to the
	// client will not be modified. Setting a TTL of "0" means "always
	// revalidate". The maximum allowed value is 31,622,400s (1 year),
	// noting that infrequently accessed objects may be evicted from the
	// cache before the defined TTL.
	MaxTtl int64 `json:"maxTtl,omitempty"`
	// Negative caching allows per-status code TTLs to be set, in order to
	// apply fine-grained caching for common errors or redirects. This can
	// reduce the load on your origin and improve end-user experience by
	// reducing response latency. When the cache mode is set to
	// CACHE_ALL_STATIC or USE_ORIGIN_HEADERS, negative caching applies to
	// responses with the specified response code that lack any
	// Cache-Control, Expires, or Pragma: no-cache directives. When the
	// cache mode is set to FORCE_CACHE_ALL, negative caching applies to all
	// responses with the specified response code, and override any caching
	// headers. By default, Cloud CDN will apply the following default TTLs
	// to these status codes: HTTP 300 (Multiple Choice), 301, 308
	// (Permanent Redirects): 10m HTTP 404 (Not Found), 410 (Gone), 451
	// (Unavailable For Legal Reasons): 120s HTTP 405 (Method Not Found),
	// 421 (Misdirected Request), 501 (Not Implemented): 60s. These defaults
	// can be overridden in negative_caching_policy.
	NegativeCaching bool `json:"negativeCaching,omitempty"`
	// Sets a cache TTL for the specified HTTP status code. negative_caching
	// must be enabled to configure negative_caching_policy. Omitting the
	// policy and leaving negative_caching enabled will use Cloud CDN's
	// default cache TTLs. Note that when specifying an explicit
	// negative_caching_policy, you should take care to specify a cache TTL
	// for all response codes that you wish to cache. Cloud CDN will not
	// apply any default negative caching when a policy exists.
	NegativeCachingPolicy []*BackendServiceCdnPolicyNegativeCachingPolicy `json:"negativeCachingPolicy,omitempty"`
	// If true then Cloud CDN will combine multiple concurrent cache fill
	// requests into a small number of requests to the origin.
	RequestCoalescing bool `json:"requestCoalescing,omitempty"`
	// Serve existing content from the cache (if available) when
	// revalidating content with the origin, or when an error is encountered
	// when refreshing the cache. This setting defines the default
	// "max-stale" duration for any cached responses that do not specify a
	// max-stale directive. Stale responses that exceed the TTL configured
	// here will not be served. The default limit (max-stale) is 86400s (1
	// day), which will allow stale content to be served up to this limit
	// beyond the max-age (or s-max-age) of a cached response. The maximum
	// allowed value is 604800 (1 week). Set this to zero (0) to disable
	// serve-while-stale.
	ServeWhileStale int64 `json:"serveWhileStale,omitempty"`
	// Maximum number of seconds the response to a signed URL request will
	// be considered fresh. After this time period, the response will be
	// revalidated before being served. Defaults to 1hr (3600s). When
	// serving responses to signed URL requests, Cloud CDN will internally
	// behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in responses
	// will not be altered.
	SignedUrlCacheMaxAgeSec int64 `json:"signedUrlCacheMaxAgeSec,omitempty,string"`
	// [Output Only] Names of the keys for signing request URLs.
	SignedUrlKeyNames []string `json:"signedUrlKeyNames,omitempty"`
	ForceSendFields   []string `json:"-"`
	NullFields        []string `json:"-"`
}

// BackendServiceCdnPolicyBypassCacheOnRequestHeader is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceCdnPolicyBypassCacheOnRequestHeader struct {
	// The header field name to match on when bypassing cache. Values are
	// case-insensitive.
	HeaderName      string   `json:"headerName,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceCdnPolicyNegativeCachingPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceCdnPolicyNegativeCachingPolicy struct {
	// The HTTP status code to define a TTL against. Only HTTP status codes
	// 300, 301, 302, 307, 308, 404, 405, 410, 421, 451 and 501 are can be
	// specified as values, and you cannot specify a status code more than
	// once.
	Code int64 `json:"code,omitempty"`
	// The TTL (in seconds) for which to cache responses with the
	// corresponding status code. The maximum allowed value is 1800s (30
	// minutes), noting that infrequently accessed objects may be evicted
	// from the cache before the defined TTL.
	Ttl             int64    `json:"ttl,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceConnectionTrackingPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceConnectionTrackingPolicy struct {
	// Specifies connection persistence when backends are unhealthy. The
	// default value is DEFAULT_FOR_PROTOCOL.
	//
	// If set to DEFAULT_FOR_PROTOCOL, the existing connections persist on
	// unhealthy backends only for connection-oriented protocols (TCP and
	// SCTP) and only if the Tracking Mode is PER_CONNECTION (default
	// tracking mode) or the Session Affinity is configured for 5-tuple.
	// They do not persist for UDP.
	//
	// If set to NEVER_PERSIST, after a backend becomes unhealthy, the
	// existing connections on the unhealthy backend are never persisted on
	// the unhealthy backend. They are always diverted to newly selected
	// healthy backends (unless all backends are unhealthy).
	//
	// If set to ALWAYS_PERSIST, existing connections always persist on
	// unhealthy backends regardless of protocol and session affinity. It is
	// generally not recommended to use this mode overriding the default.
	ConnectionPersistenceOnUnhealthyBackends string `json:"connectionPersistenceOnUnhealthyBackends,omitempty"`
	// Specifies how long to keep a Connection Tracking entry while there is
	// no matching traffic (in seconds).
	//
	// For L4 ILB the minimum(default) is 10 minutes and maximum is 16
	// hours.
	//
	// For NLB the minimum(default) is 60 seconds and the maximum is 16
	// hours.
	//
	// This field will be supported only if the Connection Tracking key is
	// less than 5-tuple.
	IdleTimeoutSec int64 `json:"idleTimeoutSec,omitempty"`
	// Specifies the key used for connection tracking. There are two
	// options:
	//
	// PER_CONNECTION: This is the default mode. The Connection Tracking is
	// performed as per the Connection Key (default Hash Method) for the
	// specific protocol.
	//
	// PER_SESSION: The Connection Tracking is performed as per the
	// configured Session Affinity. It matches the configured Session
	// Affinity.
	TrackingMode    string   `json:"trackingMode,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceFailoverPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceFailoverPolicy struct {
	// This can be set to true only if the protocol is TCP.
	//
	// The default is false.
	DisableConnectionDrainOnFailover bool `json:"disableConnectionDrainOnFailover,omitempty"`
	// Applicable only to Failover for Internal TCP/UDP Load Balancing and
	// Network Load Balancing, If set to true, connections to the load
	// balancer are dropped when all primary and all backup backend VMs are
	// unhealthy.If set to false, connections are distributed among all
	// primary VMs when all primary and all backup backend VMs are
	// unhealthy. The default is false.
	DropTrafficIfUnhealthy bool `json:"dropTrafficIfUnhealthy,omitempty"`
	// Applicable only to Failover for Internal TCP/UDP Load Balancing and
	// Network Load Balancing. The value of the field must be in the range
	// [0, 1]. If the value is 0, the load balancer performs a failover when
	// the number of healthy primary VMs equals zero. For all other values,
	// the load balancer performs a failover when the total number of
	// healthy primary VMs is less than this ratio.
	FailoverRatio   float64  `json:"failoverRatio,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceIAP is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceIAP struct {
	// Whether the serving infrastructure will authenticate and authorize
	// all incoming requests. If true, the oauth2ClientId and
	// oauth2ClientSecret fields must be non-empty.
	Enabled bool `json:"enabled,omitempty"`
	// OAuth2 client ID to use for the authentication flow.
	Oauth2ClientId string `json:"oauth2ClientId,omitempty"`
	// [Input Only] OAuth client info required to generate client id to be
	// used for IAP.
	Oauth2ClientInfo *BackendServiceIAPOAuth2ClientInfo `json:"oauth2ClientInfo,omitempty"`
	// OAuth2 client secret to use for the authentication flow. For security
	// reasons, this value cannot be retrieved via the API. Instead, the
	// SHA-256 hash of the value is returned in the oauth2ClientSecretSha256
	// field.
	Oauth2ClientSecret string `json:"oauth2ClientSecret,omitempty"`
	// [Output Only] SHA256 hash value for the field oauth2_client_secret
	// above.
	Oauth2ClientSecretSha256 string   `json:"oauth2ClientSecretSha256,omitempty"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// BackendServiceIAPOAuth2ClientInfo is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceIAPOAuth2ClientInfo struct {
	// Application name to be used in OAuth consent screen.
	ApplicationName string `json:"applicationName,omitempty"`
	// Name of the client to be generated. Optional - If not provided, the
	// name will be autogenerated by the backend.
	ClientName string `json:"clientName,omitempty"`
	// Developer's information to be used in OAuth consent screen.
	DeveloperEmailAddress string   `json:"developerEmailAddress,omitempty"`
	ForceSendFields       []string `json:"-"`
	NullFields            []string `json:"-"`
}

// BackendServiceLogConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceLogConfig struct {
	// This field denotes whether to enable logging for the load balancer
	// traffic served by this backend service.
	Enable bool `json:"enable,omitempty"`
	// This field can only be specified if logging is enabled for this
	// backend service. The value of the field must be in [0, 1]. This
	// configures the sampling rate of requests to the load balancer where
	// 1.0 means all logged requests are reported and 0.0 means no logged
	// requests are reported. The default value is 1.0.
	SampleRate      float64  `json:"sampleRate,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceReference is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceReference struct {
	BackendService  string   `json:"backendService,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// CacheKeyPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CacheKeyPolicy struct {
	// If true, requests to different hosts will be cached separately.
	IncludeHost bool `json:"includeHost,omitempty"`
	// Allows HTTP request headers (by name) to be used in the cache key.
	IncludeHttpHeaders []string `json:"includeHttpHeaders,omitempty"`
	// Allows HTTP cookies (by name) to be used in the cache key. The
	// name=value pair will be used in the cache key Cloud CDN generates.
	IncludeNamedCookies []string `json:"includeNamedCookies,omitempty"`
	// If true, http and https requests will be cached separately.
	IncludeProtocol bool `json:"includeProtocol,omitempty"`
	// If true, include query string parameters in the cache key according
	// to query_string_whitelist and query_string_blacklist. If neither is
	// set, the entire query string will be included. If false, the query
	// string will be excluded from the cache key entirely.
	IncludeQueryString bool `json:"includeQueryString,omitempty"`
	// Names of query string parameters to exclude in cache keys. All other
	// parameters will be included. Either specify query_string_whitelist or
	// query_string_blacklist, not both. '&' and '=' will be percent encoded
	// and not treated as delimiters.
	QueryStringBlacklist []string `json:"queryStringBlacklist,omitempty"`
	// Names of query string parameters to include in cache keys. All other
	// parameters will be excluded. Either specify query_string_whitelist or
	// query_string_blacklist, not both. '&' and '=' will be percent encoded
	// and not treated as delimiters.
	QueryStringWhitelist []string `json:"queryStringWhitelist,omitempty"`
	ForceSendFields      []string `json:"-"`
	NullFields           []string `json:"-"`
}

// CallCredentials is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CallCredentials struct {
	// The type of call credentials to use for GRPC requests to the SDS
	// server. This field can be set to one of the following:
	// - GCE_VM: The local GCE VM service account credentials are used to
	// access the SDS server.
	// - FROM_PLUGIN: Custom authenticator credentials are used to access
	// the SDS server.
	CallCredentialType string `json:"callCredentialType,omitempty"`
	// Custom authenticator credentials. Valid if callCredentialType is
	// FROM_PLUGIN.
	FromPlugin      *MetadataCredentialsFromPlugin `json:"fromPlugin,omitempty"`
	ForceSendFields []string                       `json:"-"`
	NullFields      []string                       `json:"-"`
}

// ChannelCredentials is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ChannelCredentials struct {
	// The call credentials to access the SDS server.
	Certificates *TlsCertificatePaths `json:"certificates,omitempty"`
	// The channel credentials to access the SDS server. This field can be
	// set to one of the following: CERTIFICATES: Use TLS certificates to
	// access the SDS server. GCE_VM: Use local GCE VM credentials to access
	// the SDS server.
	ChannelCredentialType string   `json:"channelCredentialType,omitempty"`
	ForceSendFields       []string `json:"-"`
	NullFields            []string `json:"-"`
}

// CircuitBreakers is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CircuitBreakers struct {
	// The timeout for new network connections to hosts.
	ConnectTimeout *Duration `json:"connectTimeout,omitempty"`
	// The maximum number of connections to the backend service. If not
	// specified, there is no limit.
	MaxConnections int64 `json:"maxConnections,omitempty"`
	// The maximum number of pending requests allowed to the backend
	// service. If not specified, there is no limit.
	MaxPendingRequests int64 `json:"maxPendingRequests,omitempty"`
	// The maximum number of parallel requests that allowed to the backend
	// service. If not specified, there is no limit.
	MaxRequests int64 `json:"maxRequests,omitempty"`
	// Maximum requests for a single connection to the backend service. This
	// parameter is respected by both the HTTP/1.1 and HTTP/2
	// implementations. If not specified, there is no limit. Setting this
	// parameter to 1 will effectively disable keep alive.
	MaxRequestsPerConnection int64 `json:"maxRequestsPerConnection,omitempty"`
	// The maximum number of parallel retries allowed to the backend
	// cluster. If not specified, the default is 1.
	MaxRetries      int64    `json:"maxRetries,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// ClientTlsSettings is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ClientTlsSettings struct {
	// Configures the mechanism to obtain client-side security certificates
	// and identity information. This field is only applicable when mode is
	// set to MUTUAL.
	ClientTlsContext *TlsContext `json:"clientTlsContext,omitempty"`
	// Indicates whether connections to this port should be secured using
	// TLS. The value of this field determines how TLS is enforced. This can
	// be set to one of the following values: DISABLE: Do not setup a TLS
	// connection to the backends. SIMPLE: Originate a TLS connection to the
	// backends. MUTUAL: Secure connections to the backends using mutual TLS
	// by presenting client certificates for authentication.
	Mode string `json:"mode,omitempty"`
	// SNI string to present to the server during TLS handshake. This field
	// is applicable only when mode is SIMPLE or MUTUAL.
	Sni string `json:"sni,omitempty"`
	// A list of alternate names to verify the subject identity in the
	// certificate.If specified, the proxy will verify that the server
	// certificate's subject alt name matches one of the specified values.
	// This field is applicable only when mode is SIMPLE or MUTUAL.
	SubjectAltNames []string `json:"subjectAltNames,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// ConnectionDraining is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ConnectionDraining struct {
	// Configures a duration timeout for existing requests on a removed
	// backend instance. For supported load balancers and protocols, as
	// described in Enabling connection draining.
	DrainingTimeoutSec int64    `json:"drainingTimeoutSec,omitempty"`
	ForceSendFields    []string `json:"-"`
	NullFields         []string `json:"-"`
}

// ConsistentHashLoadBalancerSettings is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ConsistentHashLoadBalancerSettings struct {
	// Hash is based on HTTP Cookie. This field describes a HTTP cookie that
	// will be used as the hash key for the consistent hash load balancer.
	// If the cookie is not present, it will be generated. This field is
	// applicable if the sessionAffinity is set to HTTP_COOKIE.
	HttpCookie *ConsistentHashLoadBalancerSettingsHttpCookie `json:"httpCookie,omitempty"`
	// The hash based on the value of the specified header field. This field
	// is applicable if the sessionAffinity is set to HEADER_FIELD.
	HttpHeaderName string `json:"httpHeaderName,omitempty"`
	// The minimum number of virtual nodes to use for the hash ring.
	// Defaults to 1024. Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool is
	// larger than the ring size, each host will be assigned a single
	// virtual node.
	MinimumRingSize int64    `json:"minimumRingSize,omitempty,string"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// ConsistentHashLoadBalancerSettingsHttpCookie is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ConsistentHashLoadBalancerSettingsHttpCookie struct {
	// Name of the cookie.
	Name string `json:"name,omitempty"`
	// Path to set for the cookie.
	Path string `json:"path,omitempty"`
	// Lifetime of the cookie.
	Ttl             *Duration `json:"ttl,omitempty"`
	ForceSendFields []string  `json:"-"`
	NullFields      []string  `json:"-"`
}

// CorsPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CorsPolicy struct {
	// In response to a preflight request, setting this to true indicates
	// that the actual request can include user credentials. This translates
	// to the Access-Control-Allow-Credentials header.
	// Default is false.
	AllowCredentials bool `json:"allowCredentials,omitempty"`
	// Specifies the content for the Access-Control-Allow-Headers header.
	AllowHeaders []string `json:"allowHeaders,omitempty"`
	// Specifies the content for the Access-Control-Allow-Methods header.
	AllowMethods []string `json:"allowMethods,omitempty"`
	// Specifies the regualar expression patterns that match allowed
	// origins. For regular expression grammar please see
	// github.com/google/re2/wiki/Syntax
	// An origin is allowed if it matches either an item in allowOrigins or
	// an item in allowOriginRegexes.
	AllowOriginRegexes []string `json:"allowOriginRegexes,omitempty"`
	// Specifies the list of origins that will be allowed to do CORS
	// requests.
	// An origin is allowed if it matches either an item in allowOrigins or
	// an item in allowOriginRegexes.
	AllowOrigins []string `json:"allowOrigins,omitempty"`
	// If true, specifies the CORS policy is disabled. The default value of
	// false, which indicates that the CORS policy is in effect.
	Disabled bool `json:"disabled,omitempty"`
	// Specifies the content for the Access-Control-Expose-Headers header.
	ExposeHeaders []string `json:"exposeHeaders,omitempty"`
	// Specifies how long results of a preflight request can be cached in
	// seconds. This translates to the Access-Control-Max-Age header.
	MaxAge          int64    `json:"maxAge,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// Duration is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Duration struct {
	// Span of time that's a fraction of a second at nanosecond resolution.
	// Durations less than one second are represented with a 0 `seconds`
	// field and a positive `nanos` field. Must be from 0 to 999,999,999
	// inclusive.
	Nanos int64 `json:"nanos,omitempty"`
	// Span of time at a resolution of a second. Must be from 0 to
	// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
	// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
	Seconds         int64    `json:"seconds,omitempty,string"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// ForwardingRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ForwardingRule struct {
	// Version keeps track of the intended compute version for this ForwardingRule.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// This field is used along with the backend_service field for internal
	// load balancing or with the target field for internal TargetInstance.
	// This field cannot be used with port or portRange fields.
	//
	// When the load balancing scheme is INTERNAL and protocol is TCP/UDP,
	// specify this field to allow packets addressed to any ports will be
	// forwarded to the backends configured with this forwarding rule.
	AllPorts bool `json:"allPorts,omitempty"`
	// This field is used along with the backend_service field for internal
	// load balancing or with the target field for internal TargetInstance.
	// If the field is set to TRUE, clients can access ILB from all regions.
	// Otherwise only allows access from clients in the same region as the
	// internal load balancer.
	AllowGlobalAccess bool `json:"allowGlobalAccess,omitempty"`
	// Identifies the backend service to which the forwarding rule sends
	// traffic. Required for Internal TCP/UDP Load Balancing and Network
	// Load Balancing; must be omitted for all other load balancer types.
	BackendService string `json:"backendService,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a ForwardingRule. Include the fingerprint in
	// patch request to ensure that you do not overwrite changes that were
	// applied from another concurrent request.
	//
	// To see the latest fingerprint, make a get() request to retrieve a
	// ForwardingRule.
	Fingerprint string `json:"fingerprint,omitempty"`
	// IP address that this forwarding rule serves. When a client sends
	// traffic to this IP address, the forwarding rule directs the traffic
	// to the target that you specify in the forwarding rule.
	//
	// If you don't specify a reserved IP address, an ephemeral IP address
	// is assigned. Methods for specifying an IP address:
	//
	// * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in
	// https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name * Partial URL or by name, as in:
	// - projects/project_id/regions/region/addresses/address-name
	// - regions/region/addresses/address-name
	// - global/addresses/address-name
	// - address-name
	//
	// The loadBalancingScheme and the forwarding rule's target determine
	// the type of IP address that you can use. For detailed information,
	// refer to [IP address
	// specifications](/load-balancing/docs/forwarding-rule-concepts#ip_addre
	// ss_specifications).
	//
	// Must be set to `0.0.0.0` when the target is targetGrpcProxy that has
	// validateForProxyless field set to true.
	//
	// For Private Service Connect forwarding rules that forward traffic to
	// Google APIs, IP address must be provided.
	IPAddress string `json:"IPAddress,omitempty"`
	// The IP protocol to which this rule applies.
	//
	// For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP
	// and ICMP.
	//
	// The valid IP protocols are different for different load balancing
	// products:
	// - Internal TCP/UDP Load Balancing: The load balancing scheme is
	// INTERNAL, and one of TCP, UDP or ALL is valid.
	// - Traffic Director: The load balancing scheme is
	// INTERNAL_SELF_MANAGED, and only TCP is valid.
	// - Internal HTTP(S) Load Balancing: The load balancing scheme is
	// INTERNAL_MANAGED, and only TCP is valid.
	// - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load
	// balancing scheme is EXTERNAL and only TCP is valid.
	// - Network Load Balancing: The load balancing scheme is EXTERNAL, and
	// one of TCP or UDP is valid.
	IPProtocol string `json:"IPProtocol,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// The IP Version that will be used by this forwarding rule. Valid
	// options are IPV4 or IPV6. This can only be specified for an external
	// global forwarding rule.
	IpVersion string `json:"ipVersion,omitempty"`
	// Indicates whether or not this load balancer can be used as a
	// collector for packet mirroring. To prevent mirroring loops, instances
	// behind this load balancer will not have their traffic mirrored even
	// if a PacketMirroring rule applies to them. This can only be set to
	// true for load balancers that have their loadBalancingScheme set to
	// INTERNAL.
	IsMirroringCollector bool `json:"isMirroringCollector,omitempty"`
	// [Output Only] Type of the resource. Always compute#forwardingRule for
	// Forwarding Rule resources.
	Kind string `json:"kind,omitempty"`
	// A fingerprint for the labels being applied to this resource, which is
	// essentially a hash of the labels set used for optimistic locking. The
	// fingerprint is initially generated by Compute Engine and changes
	// after every request to modify or update labels. You must always
	// provide an up-to-date fingerprint hash in order to update or change
	// labels, otherwise the request will fail with error 412
	// conditionNotMet.
	//
	// To see the latest fingerprint, make a get() request to retrieve a
	// ForwardingRule.
	LabelFingerprint string `json:"labelFingerprint,omitempty"`
	// Labels for this resource. These can only be added or modified by the
	// setLabels method. Each label key/value pair must comply with RFC1035.
	// Label values may be empty.
	Labels map[string]string `json:"labels,omitempty"`
	// Specifies the forwarding rule type.
	//
	//
	// - EXTERNAL is used for:
	// - Classic Cloud VPN gateways
	// - Protocol forwarding to VMs from an external IP address
	// - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
	// - INTERNAL is used for:
	// - Protocol forwarding to VMs from an internal IP address
	// - Internal TCP/UDP Load Balancing
	// - INTERNAL_MANAGED is used for:
	// - Internal HTTP(S) Load Balancing
	// - INTERNAL_SELF_MANAGED is used for:
	// - Traffic Director
	//
	// For more information about forwarding rules, refer to Forwarding rule
	// concepts.
	LoadBalancingScheme string `json:"loadBalancingScheme,omitempty"`
	// Opaque filter criteria used by Loadbalancer to restrict routing
	// configuration to a limited set of xDS compliant clients. In their xDS
	// requests to Loadbalancer, xDS clients present node metadata. When
	// there is a match, the relevant configuration is made available to
	// those proxies. Otherwise, all the resources (e.g. TargetHttpProxy,
	// UrlMap) referenced by the ForwardingRule will not be visible to those
	// proxies.
	// For each metadataFilter in this list, if its filterMatchCriteria is
	// set to MATCH_ANY, at least one of the filterLabels must match the
	// corresponding label provided in the metadata. If its
	// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels
	// must match with corresponding labels provided in the metadata. If
	// multiple metadataFilters are specified, all of them need to be
	// satisfied in order to be considered a match.
	// metadataFilters specified here will be applifed before those
	// specified in the UrlMap that this ForwardingRule
	// references.
	// metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	MetadataFilters []*MetadataFilter `json:"metadataFilters,omitempty"`
	// Name of the resource; provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// This field is not used for external load balancing.
	//
	// For Internal TCP/UDP Load Balancing, this field identifies the
	// network that the load balanced IP should belong to for this
	// Forwarding Rule. If this field is not specified, the default network
	// will be used.
	//
	// For Private Service Connect forwarding rules that forward traffic to
	// Google APIs, a network must be provided.
	Network string `json:"network,omitempty"`
	// This signifies the networking tier used for configuring this load
	// balancer and can only take the following values: PREMIUM,
	// STANDARD.
	//
	// For regional ForwardingRule, the valid values are PREMIUM and
	// STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
	//
	// If this field is not specified, it is assumed to be PREMIUM. If
	// IPAddress is specified, this value must be equal to the networkTier
	// of the Address.
	NetworkTier string `json:"networkTier,omitempty"`
	// This field can be used only if: * Load balancing scheme is one of
	// EXTERNAL,  INTERNAL_SELF_MANAGED or INTERNAL_MANAGED, and *
	// IPProtocol is one of TCP, UDP, or SCTP.
	//
	// Packets addressed to ports in the specified range will be forwarded
	// to target or  backend_service. You can only use one of ports,
	// port_range, or allPorts. The three are mutually exclusive. Forwarding
	// rules with the same [IPAddress, IPProtocol] pair must have disjoint
	// port ranges.
	//
	// Some types of forwarding target have constraints on the acceptable
	// ports:
	// - TargetHttpProxy: 80, 8080
	// - TargetHttpsProxy: 443
	// - TargetGrpcProxy: no constraints
	// - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993,
	// 995, 1688, 1883, 5222
	// - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993,
	// 995, 1688, 1883, 5222
	// - TargetVpnGateway: 500, 4500
	PortRange string `json:"portRange,omitempty"`
	// The ports field is only supported when the forwarding rule references
	// a backend_service directly. Supported load balancing products are
	// Internal TCP/UDP Load Balancing and Network Load Balancing. Only
	// packets addressed to the specified list of ports are forwarded to
	// backends.
	//
	// You can only use one of ports and port_range, or allPorts. The three
	// are mutually exclusive.
	//
	// You can specify a list of up to five ports, which can be
	// non-contiguous.
	//
	// For Internal TCP/UDP Load Balancing, if you specify allPorts, you
	// should not specify ports.
	//
	// For more information, see [Port
	// specifications](/load-balancing/docs/forwarding-rule-concepts#port_spe
	// cifications).
	Ports []string `json:"ports,omitempty"`
	// [Output Only] The PSC connection id of the PSC Forwarding Rule.
	PscConnectionId     uint64 `json:"pscConnectionId,omitempty,string"`
	PscConnectionStatus string `json:"pscConnectionStatus,omitempty"`
	// [Output Only] URL of the region where the regional forwarding rule
	// resides. This field is not applicable to global forwarding rules. You
	// must specify this field as part of the HTTP request URL. It is not
	// settable as a field in the request body.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// Service Directory resources to register this forwarding rule with.
	// Currently, only supports a single Service Directory resource.
	//
	// It is only supported for Internal TCP/UDP Load Balancing and Internal
	// HTTP(S) Load Balancing.
	ServiceDirectoryRegistrations []*ForwardingRuleServiceDirectoryRegistration `json:"serviceDirectoryRegistrations,omitempty"`
	// An optional prefix to the service name for this Forwarding Rule. If
	// specified, the prefix is the first label of the fully qualified
	// service name.
	//
	// The label must be 1-63 characters long, and comply with RFC1035.
	// Specifically, the label must be 1-63 characters long and match the
	// regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
	// character must be a lowercase letter, and all following characters
	// must be a dash, lowercase letter, or digit, except the last
	// character, which cannot be a dash.
	//
	// This field is only used for internal load balancing.
	ServiceLabel string `json:"serviceLabel,omitempty"`
	// [Output Only] The internal fully qualified service name for this
	// Forwarding Rule.
	//
	// This field is only used for internal load balancing.
	ServiceName string `json:"serviceName,omitempty"`
	// This field is only used for internal load balancing.
	//
	// For internal load balancing, this field identifies the subnetwork
	// that the load balanced IP should belong to for this Forwarding
	// Rule.
	//
	// If the network specified is in auto subnet mode, this field is
	// optional. However, if the network is in custom subnet mode, a
	// subnetwork must be specified.
	Subnetwork               string `json:"subnetwork,omitempty"`
	Target                   string `json:"target,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// ForwardingRuleReference is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ForwardingRuleReference struct {
	ForwardingRule  string   `json:"forwardingRule,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// ForwardingRuleServiceDirectoryRegistration is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ForwardingRuleServiceDirectoryRegistration struct {
	// Service Directory namespace to register the forwarding rule under.
	Namespace string `json:"namespace,omitempty"`
	// Service Directory service to register the forwarding rule under.
	Service string `json:"service,omitempty"`
	// [Optional] Service Directory region to register this global
	// forwarding rule under. Default to "us-central1". Only used for PSC
	// for Google APIs. All PSC for Google APIs Forwarding Rules on the same
	// network should use the same Service Directory region.
	ServiceDirectoryRegion string   `json:"serviceDirectoryRegion,omitempty"`
	ForceSendFields        []string `json:"-"`
	NullFields             []string `json:"-"`
}

// GRPCHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type GRPCHealthCheck struct {
	// The gRPC service name for the health check. This field is optional.
	// The value of grpc_service_name has the following meanings by
	// convention:
	// - Empty service_name means the overall status of all services at the
	// backend.
	// - Non-empty service_name means the health of that gRPC service, as
	// defined by the owner of the service.
	// The grpc_service_name can only be ASCII.
	GrpcServiceName string `json:"grpcServiceName,omitempty"`
	// The port number for the health check request. Must be specified if
	// port_name and port_specification are not set or if port_specification
	// is USE_FIXED_PORT. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence. The port_name
	// should conform to RFC1035.
	PortName string `json:"portName,omitempty"`
	// Specifies how port is selected for health checking, can be one of
	// following values:
	// USE_FIXED_PORT: The port number in port is used for health
	// checking.
	// USE_NAMED_PORT: The portName is used for health
	// checking.
	// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for
	// each network endpoint is used for health checking. For other
	// backends, the port or named port specified in the Backend Service is
	// used for health checking.
	//
	//
	// If not specified, gRPC health check follows behavior specified in
	// port and portName fields.
	PortSpecification string   `json:"portSpecification,omitempty"`
	ForceSendFields   []string `json:"-"`
	NullFields        []string `json:"-"`
}

// GrpcServiceConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type GrpcServiceConfig struct {
	// The call credentials to access the SDS server.
	CallCredentials *CallCredentials `json:"callCredentials,omitempty"`
	// The channel credentials to access the SDS server.
	ChannelCredentials *ChannelCredentials `json:"channelCredentials,omitempty"`
	// The target URI of the SDS server.
	TargetUri       string   `json:"targetUri,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HTTP2HealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HTTP2HealthCheck struct {
	// The value of the host header in the HTTP/2 health check request. If
	// left empty (default value), the IP on behalf of which this health
	// check is performed will be used.
	Host string `json:"host,omitempty"`
	// The TCP port number for the health check request. The default value
	// is 443. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Specifies how port is selected for health checking, can be one of
	// following values:
	// USE_FIXED_PORT: The port number in port is used for health
	// checking.
	// USE_NAMED_PORT: The portName is used for health
	// checking.
	// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for
	// each network endpoint is used for health checking. For other
	// backends, the port or named port specified in the Backend Service is
	// used for health checking.
	//
	//
	// If not specified, HTTP2 health check follows behavior specified in
	// port and portName fields.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The request path of the HTTP/2 health check request. The default
	// value is /.
	RequestPath string `json:"requestPath,omitempty"`
	// The string to match anywhere in the first 1024 bytes of the response
	// body. If left empty (the default value), the status code determines
	// health. The response data can only be ASCII.
	Response string `json:"response,omitempty"`
	// Weight report mode. used for weighted Load Balancing.
	WeightReportMode string   `json:"weightReportMode,omitempty"`
	ForceSendFields  []string `json:"-"`
	NullFields       []string `json:"-"`
}

// HTTPHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HTTPHealthCheck struct {
	// The value of the host header in the HTTP health check request. If
	// left empty (default value), the IP on behalf of which this health
	// check is performed will be used.
	Host string `json:"host,omitempty"`
	// The TCP port number for the health check request. The default value
	// is 80. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Specifies how port is selected for health checking, can be one of
	// following values:
	// USE_FIXED_PORT: The port number in port is used for health
	// checking.
	// USE_NAMED_PORT: The portName is used for health
	// checking.
	// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for
	// each network endpoint is used for health checking. For other
	// backends, the port or named port specified in the Backend Service is
	// used for health checking.
	//
	//
	// If not specified, HTTP health check follows behavior specified in
	// port and portName fields.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The request path of the HTTP health check request. The default value
	// is /.
	RequestPath string `json:"requestPath,omitempty"`
	// The string to match anywhere in the first 1024 bytes of the response
	// body. If left empty (the default value), the status code determines
	// health. The response data can only be ASCII.
	Response string `json:"response,omitempty"`
	// Weight report mode. used for weighted Load Balancing.
	WeightReportMode string   `json:"weightReportMode,omitempty"`
	ForceSendFields  []string `json:"-"`
	NullFields       []string `json:"-"`
}

// HTTPSHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HTTPSHealthCheck struct {
	// The value of the host header in the HTTPS health check request. If
	// left empty (default value), the IP on behalf of which this health
	// check is performed will be used.
	Host string `json:"host,omitempty"`
	// The TCP port number for the health check request. The default value
	// is 443. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Specifies how port is selected for health checking, can be one of
	// following values:
	// USE_FIXED_PORT: The port number in port is used for health
	// checking.
	// USE_NAMED_PORT: The portName is used for health
	// checking.
	// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for
	// each network endpoint is used for health checking. For other
	// backends, the port or named port specified in the Backend Service is
	// used for health checking.
	//
	//
	// If not specified, HTTPS health check follows behavior specified in
	// port and portName fields.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The request path of the HTTPS health check request. The default value
	// is /.
	RequestPath string `json:"requestPath,omitempty"`
	// The string to match anywhere in the first 1024 bytes of the response
	// body. If left empty (the default value), the status code determines
	// health. The response data can only be ASCII.
	Response string `json:"response,omitempty"`
	// Weight report mode. used for weighted Load Balancing.
	WeightReportMode string   `json:"weightReportMode,omitempty"`
	ForceSendFields  []string `json:"-"`
	NullFields       []string `json:"-"`
}

// HealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HealthCheck struct {
	// Version keeps track of the intended compute version for this HealthCheck.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// How often (in seconds) to send a health check. The default value is 5
	// seconds.
	CheckIntervalSec int64 `json:"checkIntervalSec,omitempty"`
	// [Output Only] Creation timestamp in 3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description     string           `json:"description,omitempty"`
	GrpcHealthCheck *GRPCHealthCheck `json:"grpcHealthCheck,omitempty"`
	// A so-far unhealthy instance will be marked healthy after this many
	// consecutive successes. The default value is 2.
	HealthyThreshold int64             `json:"healthyThreshold,omitempty"`
	Http2HealthCheck *HTTP2HealthCheck `json:"http2HealthCheck,omitempty"`
	HttpHealthCheck  *HTTPHealthCheck  `json:"httpHealthCheck,omitempty"`
	HttpsHealthCheck *HTTPSHealthCheck `json:"httpsHealthCheck,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// Type of the resource.
	Kind string `json:"kind,omitempty"`
	// Configure logging on this health check.
	LogConfig *HealthCheckLogConfig `json:"logConfig,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. For example, a name that is 1-63 characters long, matches
	// the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`, and otherwise
	// complies with RFC1035. This regular expression describes a name where
	// the first character is a lowercase letter, and all following
	// characters are a dash, lowercase letter, or digit, except the last
	// character, which isn't a dash.
	Name string `json:"name,omitempty"`
	// [Output Only] Region where the health check resides. Not applicable
	// to global health checks.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string          `json:"selfLinkWithId,omitempty"`
	SslHealthCheck *SSLHealthCheck `json:"sslHealthCheck,omitempty"`
	TcpHealthCheck *TCPHealthCheck `json:"tcpHealthCheck,omitempty"`
	// How long (in seconds) to wait before claiming failure. The default
	// value is 5 seconds. It is invalid for timeoutSec to have greater
	// value than checkIntervalSec.
	TimeoutSec int64 `json:"timeoutSec,omitempty"`
	// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS
	// or HTTP2. If not specified, the default is TCP. Exactly one of the
	// protocol-specific health check field must be specified, which must
	// match type field.
	Type           string          `json:"type,omitempty"`
	UdpHealthCheck *UDPHealthCheck `json:"udpHealthCheck,omitempty"`
	// A so-far healthy instance will be marked unhealthy after this many
	// consecutive failures. The default value is 2.
	UnhealthyThreshold       int64 `json:"unhealthyThreshold,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// HealthCheckLogConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HealthCheckLogConfig struct {
	// Indicates whether or not to export logs. This is false by default,
	// which means no health check logging will be done.
	Enable          bool     `json:"enable,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HealthCheckReference is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HealthCheckReference struct {
	HealthCheck     string   `json:"healthCheck,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HealthCheckServiceReference is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HealthCheckServiceReference struct {
	HealthCheckService string   `json:"healthCheckService,omitempty"`
	ForceSendFields    []string `json:"-"`
	NullFields         []string `json:"-"`
}

// HealthStatusForNetworkEndpoint is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HealthStatusForNetworkEndpoint struct {
	// Version keeps track of the intended compute version for this HealthStatusForNetworkEndpoint.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// URL of the backend service associated with the health state of the
	// network endpoint.
	BackendService *BackendServiceReference `json:"backendService,omitempty"`
	// URL of the forwarding rule associated with the health state of the
	// network endpoint.
	ForwardingRule *ForwardingRuleReference `json:"forwardingRule,omitempty"`
	// URL of the health check associated with the health state of the
	// network endpoint.
	HealthCheck *HealthCheckReference `json:"healthCheck,omitempty"`
	// URL of the health check service associated with the health state of
	// the network endpoint.
	HealthCheckService *HealthCheckServiceReference `json:"healthCheckService,omitempty"`
	// Health state of the network endpoint determined based on the health
	// checks configured.
	HealthState     string   `json:"healthState,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HostRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HostRule struct {
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// The list of host patterns to match. They must be valid hostnames with
	// optional port numbers in the format host:port. * matches any string
	// of ([a-z0-9-.]*). In that case, * must be the first character and
	// must be followed in the pattern by either - or ..
	// * based matching is not supported when the URL map is bound to target
	// gRPC proxy that has validateForProxyless field set to true.
	Hosts []string `json:"hosts,omitempty"`
	// The name of the PathMatcher to use to match the path portion of the
	// URL if the hostRule matches the URL's host portion.
	PathMatcher     string   `json:"pathMatcher,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpFaultAbort is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpFaultAbort struct {
	// The HTTP status code used to abort the request.
	// The value must be between 200 and 599 inclusive.
	HttpStatus int64 `json:"httpStatus,omitempty"`
	// The percentage of traffic (connections/operations/requests) which
	// will be aborted as part of fault injection.
	// The value must be between 0.0 and 100.0 inclusive.
	Percentage      float64  `json:"percentage,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpFaultDelay is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpFaultDelay struct {
	// Specifies the value of the fixed delay interval.
	FixedDelay *Duration `json:"fixedDelay,omitempty"`
	// The percentage of traffic (connections/operations/requests) on which
	// delay will be introduced as part of fault injection.
	// The value must be between 0.0 and 100.0 inclusive.
	Percentage      float64  `json:"percentage,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpFaultInjection is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpFaultInjection struct {
	// The specification for how client requests are aborted as part of
	// fault injection.
	Abort *HttpFaultAbort `json:"abort,omitempty"`
	// The specification for how client requests are delayed as part of
	// fault injection, before being sent to a backend service.
	Delay           *HttpFaultDelay `json:"delay,omitempty"`
	ForceSendFields []string        `json:"-"`
	NullFields      []string        `json:"-"`
}

// HttpFilterConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpFilterConfig struct {
	// The configuration needed to enable the networkservices.HttpFilter
	// resource. The configuration must be YAML formatted and only contain
	// fields defined in the protobuf identified in configTypeUrl
	Config string `json:"config,omitempty"`
	// The fully qualified versioned proto3 type url of the protobuf that
	// the filter expects for its contextual settings, for example:
	// type.googleapis.com/google.protobuf.Struct
	ConfigTypeUrl string `json:"configTypeUrl,omitempty"`
	// Name of the networkservices.HttpFilter resource this configuration
	// belongs to. This name must be known to the xDS client. Example:
	// envoy.wasm
	FilterName      string   `json:"filterName,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpHeaderAction is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpHeaderAction struct {
	// Headers to add to a matching request prior to forwarding the request
	// to the backendService.
	RequestHeadersToAdd []*HttpHeaderOption `json:"requestHeadersToAdd,omitempty"`
	// A list of header names for headers that need to be removed from the
	// request prior to forwarding the request to the backendService.
	RequestHeadersToRemove []string `json:"requestHeadersToRemove,omitempty"`
	// Headers to add the response prior to sending the response back to the
	// client.
	ResponseHeadersToAdd []*HttpHeaderOption `json:"responseHeadersToAdd,omitempty"`
	// A list of header names for headers that need to be removed from the
	// response prior to sending the response back to the client.
	ResponseHeadersToRemove []string `json:"responseHeadersToRemove,omitempty"`
	ForceSendFields         []string `json:"-"`
	NullFields              []string `json:"-"`
}

// HttpHeaderMatch is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpHeaderMatch struct {
	// The value should exactly match contents of exactMatch.
	// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
	// presentMatch or rangeMatch must be set.
	ExactMatch string `json:"exactMatch,omitempty"`
	// The name of the HTTP header to match.
	// For matching against the HTTP request's authority, use a headerMatch
	// with the header name ":authority".
	// For matching a request's method, use the headerName ":method".
	// When the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true, only non-binary
	// user-specified custom metadata and the `content-type` header are
	// supported. The following transport-level headers cannot be used in
	// header matching rules: `:authority`, `:method`, `:path`, `:scheme`,
	// `user-agent`, `accept-encoding`, `content-encoding`,
	// `grpc-accept-encoding`, `grpc-encoding`,
	// `grpc-previous-rpc-attempts`, `grpc-tags-bin`, `grpc-timeout` and
	// `grpc-trace-bin.
	HeaderName string `json:"headerName,omitempty"`
	// If set to false, the headerMatch is considered a match if the match
	// criteria above are met. If set to true, the headerMatch is considered
	// a match if the match criteria above are NOT met.
	// The default setting is false.
	InvertMatch bool `json:"invertMatch,omitempty"`
	// The value of the header must start with the contents of
	// prefixMatch.
	// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
	// presentMatch or rangeMatch must be set.
	PrefixMatch string `json:"prefixMatch,omitempty"`
	// A header with the contents of headerName must exist. The match takes
	// place whether or not the request's header has a value.
	// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
	// presentMatch or rangeMatch must be set.
	PresentMatch bool `json:"presentMatch,omitempty"`
	// The header value must be an integer and its value must be in the
	// range specified in rangeMatch. If the header does not contain an
	// integer, number or is empty, the match fails.
	// For example for a range [-5, 0]
	// - -3 will match.
	// - 0 will not match.
	// - 0.25 will not match.
	// - -3someString will not match.
	// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
	// presentMatch or rangeMatch must be set.
	// Note that rangeMatch is not supported for Loadbalancers that have
	// their loadBalancingScheme set to EXTERNAL.
	RangeMatch *Int64RangeMatch `json:"rangeMatch,omitempty"`
	// The value of the header must match the regular expression specified
	// in regexMatch. For regular expression grammar, please see:
	// github.com/google/re2/wiki/Syntax
	// For matching against a port specified in the HTTP request, use a
	// headerMatch with headerName set to PORT and a regular expression that
	// satisfies the RFC2616 Host header's port specifier.
	// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
	// presentMatch or rangeMatch must be set.
	// Note that regexMatch only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	RegexMatch string `json:"regexMatch,omitempty"`
	// The value of the header must end with the contents of
	// suffixMatch.
	// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
	// presentMatch or rangeMatch must be set.
	SuffixMatch     string   `json:"suffixMatch,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpHeaderOption is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpHeaderOption struct {
	// The name of the header.
	HeaderName string `json:"headerName,omitempty"`
	// The value of the header to add.
	HeaderValue string `json:"headerValue,omitempty"`
	// If false, headerValue is appended to any values that already exist
	// for the header. If true, headerValue is set for the header,
	// discarding any values that were set for that header.
	// The default value is false.
	Replace         bool     `json:"replace,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpQueryParameterMatch is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpQueryParameterMatch struct {
	// The queryParameterMatch matches if the value of the parameter exactly
	// matches the contents of exactMatch.
	// Only one of presentMatch, exactMatch or regexMatch must be set.
	ExactMatch string `json:"exactMatch,omitempty"`
	// The name of the query parameter to match. The query parameter must
	// exist in the request, in the absence of which the request match
	// fails.
	Name string `json:"name,omitempty"`
	// Specifies that the queryParameterMatch matches if the request
	// contains the query parameter, irrespective of whether the parameter
	// has a value or not.
	// Only one of presentMatch, exactMatch or regexMatch must be set.
	PresentMatch bool `json:"presentMatch,omitempty"`
	// The queryParameterMatch matches if the value of the parameter matches
	// the regular expression specified by regexMatch. For the regular
	// expression grammar, please see github.com/google/re2/wiki/Syntax
	//
	// Only one of presentMatch, exactMatch or regexMatch must be set.
	// Note that regexMatch only applies when the loadBalancingScheme is set
	// to INTERNAL_SELF_MANAGED.
	RegexMatch      string   `json:"regexMatch,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpRedirectAction is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpRedirectAction struct {
	// The host that will be used in the redirect response instead of the
	// one that was supplied in the request.
	// The value must be between 1 and 255 characters.
	HostRedirect string `json:"hostRedirect,omitempty"`
	// If set to true, the URL scheme in the redirected request is set to
	// https. If set to false, the URL scheme of the redirected request will
	// remain the same as that of the request.
	// This must only be set for UrlMaps used in TargetHttpProxys. Setting
	// this true for TargetHttpsProxy is not permitted.
	// The default is set to false.
	HttpsRedirect bool `json:"httpsRedirect,omitempty"`
	// The path that will be used in the redirect response instead of the
	// one that was supplied in the request.
	// pathRedirect cannot be supplied together with prefixRedirect. Supply
	// one alone or neither. If neither is supplied, the path of the
	// original request will be used for the redirect.
	// The value must be between 1 and 1024 characters.
	PathRedirect string `json:"pathRedirect,omitempty"`
	// The prefix that replaces the prefixMatch specified in the
	// HttpRouteRuleMatch, retaining the remaining portion of the URL before
	// redirecting the request.
	// prefixRedirect cannot be supplied together with pathRedirect. Supply
	// one alone or neither. If neither is supplied, the path of the
	// original request will be used for the redirect.
	// The value must be between 1 and 1024 characters.
	PrefixRedirect string `json:"prefixRedirect,omitempty"`
	// The HTTP Status code to use for this RedirectAction.
	// Supported values are:
	// - MOVED_PERMANENTLY_DEFAULT, which is the default value and
	// corresponds to 301.
	// - FOUND, which corresponds to 302.
	// - SEE_OTHER which corresponds to 303.
	// - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the
	// request method will be retained.
	// - PERMANENT_REDIRECT, which corresponds to 308. In this case, the
	// request method will be retained.
	RedirectResponseCode string `json:"redirectResponseCode,omitempty"`
	// If set to true, any accompanying query portion of the original URL is
	// removed prior to redirecting the request. If set to false, the query
	// portion of the original URL is retained.
	// The default is set to false.
	StripQuery      bool     `json:"stripQuery,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpRetryPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpRetryPolicy struct {
	// Specifies the allowed number retries. This number must be > 0. If not
	// specified, defaults to 1.
	NumRetries int64 `json:"numRetries,omitempty"`
	// Specifies a non-zero timeout per retry attempt.
	// If not specified, will use the timeout set in HttpRouteAction. If
	// timeout in HttpRouteAction is not set, will use the largest timeout
	// among all backend services associated with the route.
	PerTryTimeout *Duration `json:"perTryTimeout,omitempty"`
	// Specfies one or more conditions when this retry rule applies. Valid
	// values are:
	// - 5xx: Loadbalancer will attempt a retry if the backend service
	// responds with any 5xx response code, or if the backend service does
	// not respond at all, example: disconnects, reset, read timeout,
	// connection failure, and refused streams.
	// - gateway-error: Similar to 5xx, but only applies to response codes
	// 502, 503 or 504.
	// -
	// - connect-failure: Loadbalancer will retry on failures connecting to
	// backend services, for example due to connection timeouts.
	// - retriable-4xx: Loadbalancer will retry for retriable 4xx response
	// codes. Currently the only retriable error supported is 409.
	// - refused-stream:Loadbalancer will retry if the backend service
	// resets the stream with a REFUSED_STREAM error code. This reset type
	// indicates that it is safe to retry.
	// - cancelledLoadbalancer will retry if the gRPC status code in the
	// response header is set to cancelled
	// - deadline-exceeded: Loadbalancer will retry if the gRPC status code
	// in the response header is set to deadline-exceeded
	// - resource-exhausted: Loadbalancer will retry if the gRPC status code
	// in the response header is set to resource-exhausted
	// - unavailable: Loadbalancer will retry if the gRPC status code in the
	// response header is set to unavailable
	RetryConditions []string `json:"retryConditions,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpRouteAction is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpRouteAction struct {
	// The specification for allowing client side cross-origin requests.
	// Please see W3C Recommendation for Cross Origin Resource Sharing
	// Not supported when the URL map is bound to target gRPC proxy.
	CorsPolicy *CorsPolicy `json:"corsPolicy,omitempty"`
	// The specification for fault injection introduced into traffic to test
	// the resiliency of clients to backend service failure. As part of
	// fault injection, when clients send requests to a backend service,
	// delays can be introduced by Loadbalancer on a percentage of requests
	// before sending those request to the backend service. Similarly
	// requests from clients can be aborted by the Loadbalancer for a
	// percentage of requests.
	// timeout and retry_policy will be ignored by clients that are
	// configured with a fault_injection_policy.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	FaultInjectionPolicy *HttpFaultInjection `json:"faultInjectionPolicy,omitempty"`
	// Specifies the maximum duration (timeout) for streams on the selected
	// route. Unlike the timeout field where the timeout duration starts
	// from the time the request has been fully processed (i.e.
	// end-of-stream), the duration in this field is computed from the
	// beginning of the stream until the response has been completely
	// processed, including all retries. A stream that does not complete in
	// this duration is closed.
	// If not specified, will use the largest maxStreamDuration among all
	// backend services associated with the route.
	// This field is only allowed if the Url map is used with backend
	// services with loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	MaxStreamDuration *Duration `json:"maxStreamDuration,omitempty"`
	// Specifies the policy on how requests intended for the route's
	// backends are shadowed to a separate mirrored backend service.
	// Loadbalancer does not wait for responses from the shadow service.
	// Prior to sending traffic to the shadow service, the host / authority
	// header is suffixed with -shadow.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	RequestMirrorPolicy *RequestMirrorPolicy `json:"requestMirrorPolicy,omitempty"`
	// Specifies the retry policy associated with this route.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	RetryPolicy *HttpRetryPolicy `json:"retryPolicy,omitempty"`
	// Specifies the timeout for the selected route. Timeout is computed
	// from the time the request has been fully processed (i.e.
	// end-of-stream) up until the response has been completely processed.
	// Timeout includes all retries.
	// If not specified, will use the largest timeout among all backend
	// services associated with the route.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	Timeout *Duration `json:"timeout,omitempty"`
	// The spec to modify the URL of the request, prior to forwarding the
	// request to the matched service.
	// urlRewrite is the only action supported in UrlMaps for external
	// HTTP(S) load balancers.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	UrlRewrite *UrlRewrite `json:"urlRewrite,omitempty"`
	// A list of weighted backend services to send traffic to when a route
	// match occurs. The weights determine the fraction of traffic that
	// flows to their corresponding backend service. If all traffic needs to
	// go to a single backend service, there must be one
	// weightedBackendService with weight set to a non-zero number.
	// Once a backendService is identified and before forwarding the request
	// to the backend service, advanced routing actions such as URL rewrites
	// and header transformations are applied depending on additional
	// settings specified in this HttpRouteAction.
	WeightedBackendServices []*WeightedBackendService `json:"weightedBackendServices,omitempty"`
	ForceSendFields         []string                  `json:"-"`
	NullFields              []string                  `json:"-"`
}

// HttpRouteRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpRouteRule struct {
	// The short description conveying the intent of this routeRule.
	// The description can have a maximum length of 1024 characters.
	Description string `json:"description,omitempty"`
	// Specifies changes to request and response headers that need to take
	// effect for the selected backendService.
	// The headerAction specified here are applied before the matching
	// pathMatchers[].headerAction and after
	// pathMatchers[].routeRules[].routeAction.weightedBackendService.backend
	// ServiceWeightAction[].headerAction
	// Note that headerAction is not supported for Loadbalancers that have
	// their loadBalancingScheme set to EXTERNAL.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	HeaderAction *HttpHeaderAction `json:"headerAction,omitempty"`
	// Outbound route specific configuration for networkservices.HttpFilter
	// resources enabled by Traffic Director. httpFilterConfigs only applies
	// for Loadbalancers with loadBalancingScheme set to
	// INTERNAL_SELF_MANAGED. See ForwardingRule for more details.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	HttpFilterConfigs []*HttpFilterConfig `json:"httpFilterConfigs,omitempty"`
	// Outbound route specific metadata supplied to
	// networkservices.HttpFilter resources enabled by Traffic Director.
	// httpFilterMetadata only applies for Loadbalancers with
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED. See ForwardingRule
	// for more details.
	// The only configTypeUrl supported is
	// type.googleapis.com/google.protobuf.Struct
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	HttpFilterMetadata []*HttpFilterConfig `json:"httpFilterMetadata,omitempty"`
	// The list of criteria for matching attributes of a request to this
	// routeRule. This list has OR semantics: the request matches this
	// routeRule when any of the matchRules are satisfied. However
	// predicates within a given matchRule have AND semantics. All
	// predicates within a matchRule must match for the request to match the
	// rule.
	MatchRules []*HttpRouteRuleMatch `json:"matchRules,omitempty"`
	// For routeRules within a given pathMatcher, priority determines the
	// order in which load balancer will interpret routeRules. RouteRules
	// are evaluated in order of priority, from the lowest to highest
	// number. The priority of a rule decreases as its number increases (1,
	// 2, 3, N+1). The first rule that matches the request is applied.
	// You cannot configure two or more routeRules with the same priority.
	// Priority for each rule must be set to a number between 0 and
	// 2147483647 inclusive.
	// Priority numbers can have gaps, which enable you to add or remove
	// rules in the future without affecting the rest of the rules. For
	// example, 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority
	// numbers to which you could add rules numbered from 6 to 8, 10 to 11,
	// and 13 to 15 in the future without any impact on existing rules.
	Priority int64 `json:"priority,omitempty"`
	// In response to a matching matchRule, the load balancer performs
	// advanced routing actions like URL rewrites, header transformations,
	// etc. prior to forwarding the request to the selected backend. If
	// routeAction specifies any  weightedBackendServices, service must not
	// be set. Conversely if service is set, routeAction cannot contain any
	// weightedBackendServices.
	// Only one of urlRedirect, service or
	// routeAction.weightedBackendService must be set.
	// UrlMaps for external HTTP(S) load balancers support only the
	// urlRewrite action within a routeRule's routeAction.
	RouteAction *HttpRouteAction `json:"routeAction,omitempty"`
	// The full or partial URL of the backend service resource to which
	// traffic is directed if this rule is matched. If routeAction is
	// additionally specified, advanced routing actions like URL Rewrites,
	// etc. take effect prior to sending the request to the backend.
	// However, if service is specified, routeAction cannot contain any
	// weightedBackendService s. Conversely, if routeAction specifies any
	// weightedBackendServices, service must not be specified.
	// Only one of urlRedirect, service or
	// routeAction.weightedBackendService must be set.
	Service string `json:"service,omitempty"`
	// When this rule is matched, the request is redirected to a URL
	// specified by urlRedirect.
	// If urlRedirect is specified, service or routeAction must not be
	// set.
	// Not supported when the URL map is bound to target gRPC proxy.
	UrlRedirect     *HttpRedirectAction `json:"urlRedirect,omitempty"`
	ForceSendFields []string            `json:"-"`
	NullFields      []string            `json:"-"`
}

// HttpRouteRuleMatch is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpRouteRuleMatch struct {
	// For satisfying the matchRule condition, the path of the request must
	// exactly match the value specified in fullPathMatch after removing any
	// query parameters and anchor that may be part of the original
	// URL.
	// fullPathMatch must be between 1 and 1024 characters.
	// Only one of prefixMatch, fullPathMatch or regexMatch must be
	// specified.
	FullPathMatch string `json:"fullPathMatch,omitempty"`
	// Specifies a list of header match criteria, all of which must match
	// corresponding headers in the request.
	HeaderMatches []*HttpHeaderMatch `json:"headerMatches,omitempty"`
	// Specifies that prefixMatch and fullPathMatch matches are case
	// sensitive.
	// The default value is false.
	// ignoreCase must not be used with regexMatch.
	// Not supported when the URL map is bound to target gRPC proxy.
	IgnoreCase bool `json:"ignoreCase,omitempty"`
	// Opaque filter criteria used by Loadbalancer to restrict routing
	// configuration to a limited set of xDS compliant clients. In their xDS
	// requests to Loadbalancer, xDS clients present node metadata. When
	// there is a match, the relevant routing configuration is made
	// available to those proxies.
	// For each metadataFilter in this list, if its filterMatchCriteria is
	// set to MATCH_ANY, at least one of the filterLabels must match the
	// corresponding label provided in the metadata. If its
	// filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels
	// must match with corresponding labels provided in the metadata. If
	// multiple metadataFilters are specified, all of them need to be
	// satisfied in order to be considered a match.
	// metadataFilters specified here will be applied after those specified
	// in ForwardingRule that refers to the UrlMap this HttpRouteRuleMatch
	// belongs to.
	// metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	MetadataFilters []*MetadataFilter `json:"metadataFilters,omitempty"`
	// For satisfying the matchRule condition, the request's path must begin
	// with the specified prefixMatch. prefixMatch must begin with a /.
	// The value must be between 1 and 1024 characters.
	// Only one of prefixMatch, fullPathMatch or regexMatch must be
	// specified.
	PrefixMatch string `json:"prefixMatch,omitempty"`
	// Specifies a list of query parameter match criteria, all of which must
	// match corresponding query parameters in the request.
	// Not supported when the URL map is bound to target gRPC proxy.
	QueryParameterMatches []*HttpQueryParameterMatch `json:"queryParameterMatches,omitempty"`
	// For satisfying the matchRule condition, the path of the request must
	// satisfy the regular expression specified in regexMatch after removing
	// any query parameters and anchor supplied with the original URL. For
	// regular expression grammar please see
	// github.com/google/re2/wiki/Syntax
	// Only one of prefixMatch, fullPathMatch or regexMatch must be
	// specified.
	// Note that regexMatch only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	RegexMatch      string   `json:"regexMatch,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// Int64RangeMatch is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Int64RangeMatch struct {
	// The end of the range (exclusive) in signed long integer format.
	RangeEnd int64 `json:"rangeEnd,omitempty,string"`
	// The start of the range (inclusive) in signed long integer format.
	RangeStart      int64    `json:"rangeStart,omitempty,string"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// Jwt is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Jwt struct {
	// A JWT containing any of these audiences will be accepted. The service
	// name will be accepted if audiences is empty. Examples:
	// bookstore_android.apps.googleusercontent.com,
	// bookstore_web.apps.googleusercontent.com
	Audiences []string `json:"audiences,omitempty"`
	// Identifies the issuer that issued the JWT, which is usually a URL or
	// an email address. Examples: https://securetoken.google.com,
	// 1234567-compute@developer.gserviceaccount.com
	Issuer string `json:"issuer,omitempty"`
	// The provider's public key set to validate the signature of the JWT.
	JwksPublicKeys string `json:"jwksPublicKeys,omitempty"`
	// jwt_headers and jwt_params define where to extract the JWT from an
	// HTTP request. If no explicit location is specified, the following
	// default locations are tried in order:
	//
	// 1. The Authorization header using the Bearer schema. See `here `_.
	// Example:
	//
	// Authorization: Bearer .
	//
	// 2. `access_token` query parameter. See `this `_
	//
	// Multiple JWTs can be verified for a request. Each JWT has to be
	// extracted from the locations its issuer specified or from the default
	// locations.
	//
	// This field is set if JWT is sent in a request header. This field
	// specifies the header name. For example, if
	// `header=x-goog-iap-jwt-assertion`, the header format will be
	// x-goog-iap-jwt-assertion: .
	JwtHeaders []*JwtHeader `json:"jwtHeaders,omitempty"`
	// This field is set if JWT is sent in a query parameter. This field
	// specifies the query parameter name. For example, if jwt_params[0] is
	// jwt_token, the JWT format in the query parameter is /path?jwt_token=.
	JwtParams       []string `json:"jwtParams,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// JwtHeader is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type JwtHeader struct {
	// The HTTP header name.
	Name string `json:"name,omitempty"`
	// The value prefix. The value format is "value_prefix" For example, for
	// "Authorization: Bearer ", value_prefix="Bearer " with a space at the
	// end.
	ValuePrefix     string   `json:"valuePrefix,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// MetadataCredentialsFromPlugin is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type MetadataCredentialsFromPlugin struct {
	// Plugin name.
	Name string `json:"name,omitempty"`
	// A text proto that conforms to a Struct type definition interpreted by
	// the plugin.
	StructConfig    string   `json:"structConfig,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// MetadataFilter is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type MetadataFilter struct {
	// The list of label value pairs that must match labels in the provided
	// metadata based on filterMatchCriteria
	// This list must not be empty and can have at the most 64 entries.
	FilterLabels []*MetadataFilterLabelMatch `json:"filterLabels,omitempty"`
	// Specifies how individual filterLabel matches within the list of
	// filterLabels contribute towards the overall metadataFilter
	// match.
	// Supported values are:
	// - MATCH_ANY: At least one of the filterLabels must have a matching
	// label in the provided metadata.
	// - MATCH_ALL: All filterLabels must have matching labels in the
	// provided metadata.
	FilterMatchCriteria string   `json:"filterMatchCriteria,omitempty"`
	ForceSendFields     []string `json:"-"`
	NullFields          []string `json:"-"`
}

// MetadataFilterLabelMatch is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type MetadataFilterLabelMatch struct {
	// Name of metadata label.
	// The name can have a maximum length of 1024 characters and must be at
	// least 1 character long.
	Name string `json:"name,omitempty"`
	// The value of the label must match the specified value.
	// value can have a maximum length of 1024 characters.
	Value           string   `json:"value,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// MutualTls is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type MutualTls struct {
	// Specifies if the server TLS is configured to be strict or permissive.
	// This field can be set to one of the following: STRICT: Client
	// certificate must be presented, connection is in TLS. PERMISSIVE:
	// Client certificate can be omitted, connection can be either plaintext
	// or TLS.
	Mode            string   `json:"mode,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpoint is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpoint struct {
	// Version keeps track of the intended compute version for this NetworkEndpoint.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// Metadata defined as annotations on the network endpoint.
	Annotations map[string]string `json:"annotations,omitempty"`
	// Optional fully qualified domain name of network endpoint. This can
	// only be specified when NetworkEndpointGroup.network_endpoint_type is
	// NON_GCP_FQDN_PORT.
	Fqdn string `json:"fqdn,omitempty"`
	// The name for a specific VM instance that the IP address belongs to.
	// This is required for network endpoints of type GCE_VM_IP_PORT. The
	// instance must be in the same zone of network endpoint group.
	//
	// The name must be 1-63 characters long, and comply with RFC1035.
	Instance string `json:"instance,omitempty"`
	// Optional IPv4 address of network endpoint. The IP address must belong
	// to a VM in Compute Engine (either the primary IP or as part of an
	// aliased IP range). If the IP address is not specified, then the
	// primary IP address for the VM instance in the network that the
	// network endpoint group belongs to will be used.
	IpAddress string `json:"ipAddress,omitempty"`
	// Optional port number of network endpoint. If not specified, the
	// defaultPort for the network endpoint group will be used.
	Port            int64    `json:"port,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroup is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroup struct {
	// Version keeps track of the intended compute version for this NetworkEndpointGroup.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// Metadata defined as annotations on the network endpoint group.
	Annotations map[string]string `json:"annotations,omitempty"`
	// Only valid when networkEndpointType is "SERVERLESS". Only one of
	// cloudRun, appEngine or cloudFunction may be set.
	AppEngine *NetworkEndpointGroupAppEngine `json:"appEngine,omitempty"`
	// Only valid when networkEndpointType is "SERVERLESS". Only one of
	// cloudRun, appEngine or cloudFunction may be set.
	CloudFunction *NetworkEndpointGroupCloudFunction `json:"cloudFunction,omitempty"`
	// Only valid when networkEndpointType is "SERVERLESS". Only one of
	// cloudRun, appEngine or cloudFunction may be set.
	CloudRun *NetworkEndpointGroupCloudRun `json:"cloudRun,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// The default port used if the port number is not specified in the
	// network endpoint.
	DefaultPort int64 `json:"defaultPort,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of the resource. Always
	// compute#networkEndpointGroup for network endpoint group.
	Kind string `json:"kind,omitempty"`
	// This field is only valid when the network endpoint group is used for
	// load balancing. [Deprecated] This field is deprecated.
	LoadBalancer *NetworkEndpointGroupLbNetworkEndpointGroup `json:"loadBalancer,omitempty"`
	// Name of the resource; provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// The URL of the network to which all network endpoints in the NEG
	// belong. Uses "default" project network if unspecified.
	Network string `json:"network,omitempty"`
	// Type of network endpoints in this network endpoint group. Can be one
	// of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT,
	// INTERNET_IP_PORT, or SERVERLESS.
	NetworkEndpointType string `json:"networkEndpointType,omitempty"`
	// The target service url used to set up private service connection to a
	// Google API. An example value is:
	// "asia-northeast3-cloudkms.googleapis.com"
	PscTargetService string `json:"pscTargetService,omitempty"`
	// [Output Only] The URL of the region where the network endpoint group
	// is located.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// Only valid when networkEndpointType is "SERVERLESS". Only one of
	// cloudRun, appEngine, cloudFunction or serverlessDeployment may be
	// set.
	ServerlessDeployment *NetworkEndpointGroupServerlessDeployment `json:"serverlessDeployment,omitempty"`
	// [Output only] Number of network endpoints in the network endpoint
	// group.
	Size int64 `json:"size,omitempty"`
	// Optional URL of the subnetwork to which all network endpoints in the
	// NEG belong.
	Subnetwork string `json:"subnetwork,omitempty"`
	// Specify the type of this network endpoint group. Only LOAD_BALANCING
	// is valid for now.
	Type string `json:"type,omitempty"`
	// [Output Only] The URL of the zone where the network endpoint group is
	// located.
	Zone                     string `json:"zone,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// NetworkEndpointGroupAppEngine is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupAppEngine struct {
	// Optional serving service.
	//
	// The service name is case-sensitive and must be 1-63 characters
	// long.
	//
	// Example value: "default", "my-service".
	Service string `json:"service,omitempty"`
	// A template to parse service and version fields from a request URL.
	// URL mask allows for routing to multiple App Engine services without
	// having to create multiple Network Endpoint Groups and backend
	// services.
	//
	// For example, the request URLs "foo1-dot-appname.appspot.com/v1" and
	// "foo1-dot-appname.appspot.com/v2" can be backed by the same
	// Serverless NEG with URL mask "-dot-appname.appspot.com/". The URL
	// mask will parse them to { service = "foo1", version = "v1" } and {
	// service = "foo1", version = "v2" } respectively.
	UrlMask string `json:"urlMask,omitempty"`
	// Optional serving version.
	//
	// The version name is case-sensitive and must be 1-100 characters
	// long.
	//
	// Example value: "v1", "v2".
	Version         string   `json:"version,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupCloudFunction is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupCloudFunction struct {
	// A user-defined name of the Cloud Function.
	//
	// The function name is case-sensitive and must be 1-63 characters
	// long.
	//
	// Example value: "func1".
	Function string `json:"function,omitempty"`
	// A template to parse function field from a request URL. URL mask
	// allows for routing to multiple Cloud Functions without having to
	// create multiple Network Endpoint Groups and backend services.
	//
	// For example, request URLs "mydomain.com/function1" and
	// "mydomain.com/function2" can be backed by the same Serverless NEG
	// with URL mask "/". The URL mask will parse them to { function =
	// "function1" } and { function = "function2" } respectively.
	UrlMask         string   `json:"urlMask,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupCloudRun is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupCloudRun struct {
	// Cloud Run service is the main resource of Cloud Run.
	//
	// The service must be 1-63 characters long, and comply with
	// RFC1035.
	//
	// Example value: "run-service".
	Service string `json:"service,omitempty"`
	// Optional Cloud Run tag represents the "named-revision" to provide
	// additional fine-grained traffic routing information.
	//
	// The tag must be 1-63 characters long, and comply with
	// RFC1035.
	//
	// Example value: "revision-0010".
	Tag string `json:"tag,omitempty"`
	// A template to parse service and tag fields from a request URL. URL
	// mask allows for routing to multiple Run services without having to
	// create multiple network endpoint groups and backend services.
	//
	// For example, request URLs "foo1.domain.com/bar1" and
	// "foo1.domain.com/bar2" can be backed by the same Serverless Network
	// Endpoint Group (NEG) with URL mask ".domain.com/". The URL mask will
	// parse them to { service="bar1", tag="foo1" } and { service="bar2",
	// tag="foo2" } respectively.
	UrlMask         string   `json:"urlMask,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupLbNetworkEndpointGroup is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupLbNetworkEndpointGroup struct {
	// The default port used if the port number is not specified in the
	// network endpoint. [Deprecated] This field is deprecated.
	DefaultPort int64 `json:"defaultPort,omitempty"`
	// The URL of the network to which all network endpoints in the NEG
	// belong. Uses "default" project network if unspecified. [Deprecated]
	// This field is deprecated.
	Network string `json:"network,omitempty"`
	// Optional URL of the subnetwork to which all network endpoints in the
	// NEG belong. [Deprecated] This field is deprecated.
	Subnetwork string `json:"subnetwork,omitempty"`
	// [Output Only] The URL of the zone where the network endpoint group is
	// located. [Deprecated] This field is deprecated.
	Zone            string   `json:"zone,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupServerlessDeployment is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupServerlessDeployment struct {
	// The platform of the backend target(s) of this NEG. Possible values
	// include:
	//
	//
	// - API Gateway: apigateway.googleapis.com
	// - App Engine: appengine.googleapis.com
	// - Cloud Functions: cloudfunctions.googleapis.com
	// - Cloud Run: run.googleapis.com
	Platform string `json:"platform,omitempty"`
	// The user-defined name of the workload/instance. This value must be
	// provided explicitly or in the urlMask. The resource identified by
	// this value is platform-specific and is as follows:
	//
	//
	// - API Gateway: The gateway ID
	// - App Engine: The service name
	// - Cloud Functions: The function name
	// - Cloud Run: The service name
	Resource string `json:"resource,omitempty"`
	// A template to parse platform-specific fields from a request URL. URL
	// mask allows for routing to multiple resources on the same serverless
	// platform without having to create multiple Network Endpoint Groups
	// and backend resources. The fields parsed by this template are
	// platform-specific and are as follows:
	//
	//
	// - API Gateway: The gateway ID
	// - App Engine: The service and version
	// - Cloud Functions: The function name
	// - Cloud Run: The service and tag
	UrlMask string `json:"urlMask,omitempty"`
	// The optional resource version. The version identified by this value
	// is platform-specific and is follows:
	//
	//
	// - API Gateway: Unused
	// - App Engine: The service version
	// - Cloud Functions: Unused
	// - Cloud Run: The service tag
	Version         string   `json:"version,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupsAttachEndpointsRequest is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupsAttachEndpointsRequest struct {
	// Version keeps track of the intended compute version for this NetworkEndpointGroupsAttachEndpointsRequest.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// The list of network endpoints to be attached.
	NetworkEndpoints []*NetworkEndpoint `json:"networkEndpoints,omitempty"`
	ForceSendFields  []string           `json:"-"`
	NullFields       []string           `json:"-"`
}

// NetworkEndpointGroupsDetachEndpointsRequest is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupsDetachEndpointsRequest struct {
	// Version keeps track of the intended compute version for this NetworkEndpointGroupsDetachEndpointsRequest.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// The list of network endpoints to be detached.
	NetworkEndpoints []*NetworkEndpoint `json:"networkEndpoints,omitempty"`
	ForceSendFields  []string           `json:"-"`
	NullFields       []string           `json:"-"`
}

// NetworkEndpointGroupsListEndpointsRequest is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupsListEndpointsRequest struct {
	// Version keeps track of the intended compute version for this NetworkEndpointGroupsListEndpointsRequest.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// Optional list of endpoints to query. This is a more efficient but
	// also limited version of filter parameter. Endpoints in the filter
	// must have ip_address and port fields populated, other fields are not
	// supported.
	EndpointFilters []*NetworkEndpointGroupsListEndpointsRequestNetworkEndpointFilter `json:"endpointFilters,omitempty"`
	// Optional query parameter for showing the health status of each
	// network endpoint. Valid options are SKIP or SHOW. If you don't
	// specify this parameter, the health status of network endpoints will
	// not be provided.
	HealthStatus    string   `json:"healthStatus,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// NetworkEndpointGroupsListEndpointsRequestNetworkEndpointFilter is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointGroupsListEndpointsRequestNetworkEndpointFilter struct {
	NetworkEndpoint *NetworkEndpoint `json:"networkEndpoint,omitempty"`
	ForceSendFields []string         `json:"-"`
	NullFields      []string         `json:"-"`
}

// NetworkEndpointWithHealthStatus is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type NetworkEndpointWithHealthStatus struct {
	// Version keeps track of the intended compute version for this NetworkEndpointWithHealthStatus.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// [Output only] The health status of network endpoint;
	Healths []*HealthStatusForNetworkEndpoint `json:"healths,omitempty"`
	// [Output only] The network endpoint;
	NetworkEndpoint *NetworkEndpoint `json:"networkEndpoint,omitempty"`
	ForceSendFields []string         `json:"-"`
	NullFields      []string         `json:"-"`
}

// OriginAuthenticationMethod is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type OriginAuthenticationMethod struct {
	Jwt             *Jwt     `json:"jwt,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// OutlierDetection is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type OutlierDetection struct {
	// The base time that a host is ejected for. The real ejection time is
	// equal to the base ejection time multiplied by the number of times the
	// host has been ejected. Defaults to 30000ms or 30s.
	BaseEjectionTime *Duration `json:"baseEjectionTime,omitempty"`
	// Number of errors before a host is ejected from the connection pool.
	// When the backend host is accessed over HTTP, a 5xx return code
	// qualifies as an error. Defaults to 5.
	ConsecutiveErrors int64 `json:"consecutiveErrors,omitempty"`
	// The number of consecutive gateway failures (502, 503, 504 status or
	// connection errors that are mapped to one of those status codes)
	// before a consecutive gateway failure ejection occurs. Defaults to 3.
	ConsecutiveGatewayFailure int64 `json:"consecutiveGatewayFailure,omitempty"`
	// The percentage chance that a host will be actually ejected when an
	// outlier status is detected through consecutive 5xx. This setting can
	// be used to disable ejection or to ramp it up slowly. Defaults to 0.
	EnforcingConsecutiveErrors int64 `json:"enforcingConsecutiveErrors,omitempty"`
	// The percentage chance that a host will be actually ejected when an
	// outlier status is detected through consecutive gateway failures. This
	// setting can be used to disable ejection or to ramp it up slowly.
	// Defaults to 100.
	EnforcingConsecutiveGatewayFailure int64 `json:"enforcingConsecutiveGatewayFailure,omitempty"`
	// The percentage chance that a host will be actually ejected when an
	// outlier status is detected through success rate statistics. This
	// setting can be used to disable ejection or to ramp it up slowly.
	// Defaults to 100.
	EnforcingSuccessRate int64 `json:"enforcingSuccessRate,omitempty"`
	// Time interval between ejection analysis sweeps. This can result in
	// both new ejections as well as hosts being returned to service.
	// Defaults to 1 second.
	Interval *Duration `json:"interval,omitempty"`
	// Maximum percentage of hosts in the load balancing pool for the
	// backend service that can be ejected. Defaults to 50%.
	MaxEjectionPercent int64 `json:"maxEjectionPercent,omitempty"`
	// The number of hosts in a cluster that must have enough request volume
	// to detect success rate outliers. If the number of hosts is less than
	// this setting, outlier detection via success rate statistics is not
	// performed for any host in the cluster. Defaults to 5.
	SuccessRateMinimumHosts int64 `json:"successRateMinimumHosts,omitempty"`
	// The minimum number of total requests that must be collected in one
	// interval (as defined by the interval duration above) to include this
	// host in success rate based outlier detection. If the volume is lower
	// than this setting, outlier detection via success rate statistics is
	// not performed for that host. Defaults to 100.
	SuccessRateRequestVolume int64 `json:"successRateRequestVolume,omitempty"`
	// This factor is used to determine the ejection threshold for success
	// rate outlier ejection. The ejection threshold is the difference
	// between the mean success rate, and the product of this factor and the
	// standard deviation of the mean success rate: mean - (stdev *
	// success_rate_stdev_factor). This factor is divided by a thousand to
	// get a double. That is, if the desired factor is 1.9, the runtime
	// value should be 1900. Defaults to 1900.
	SuccessRateStdevFactor int64    `json:"successRateStdevFactor,omitempty"`
	ForceSendFields        []string `json:"-"`
	NullFields             []string `json:"-"`
}

// PathMatcher is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PathMatcher struct {
	// defaultRouteAction takes effect when none of the  pathRules or
	// routeRules match. The load balancer performs advanced routing actions
	// like URL rewrites, header transformations, etc. prior to forwarding
	// the request to the selected backend. If defaultRouteAction specifies
	// any weightedBackendServices, defaultService must not be set.
	// Conversely if defaultService is set, defaultRouteAction cannot
	// contain any  weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be
	// set.
	// UrlMaps for external HTTP(S) load balancers support only the
	// urlRewrite action within a pathMatcher's defaultRouteAction.
	DefaultRouteAction *HttpRouteAction `json:"defaultRouteAction,omitempty"`
	// The full or partial URL to the BackendService resource. This will be
	// used if none of the pathRules or routeRules defined by this
	// PathMatcher are matched. For example, the following are all valid
	// URLs to a BackendService resource:
	// -
	// https://www.googleapis.com/compute/v1/projects/project/global/backendServices/backendService
	// - compute/v1/projects/project/global/backendServices/backendService
	//
	// - global/backendServices/backendService  If defaultRouteAction is
	// additionally specified, advanced routing actions like URL Rewrites,
	// etc. take effect prior to sending the request to the backend.
	// However, if defaultService is specified, defaultRouteAction cannot
	// contain any weightedBackendServices. Conversely, if
	// defaultRouteAction specifies any weightedBackendServices,
	// defaultService must not be specified.
	// Only one of defaultService, defaultUrlRedirect  or
	// defaultRouteAction.weightedBackendService must be set.
	// Authorization requires one or more of the following Google IAM
	// permissions on the specified resource default_service:
	// - compute.backendBuckets.use
	// - compute.backendServices.use
	DefaultService string `json:"defaultService,omitempty"`
	// When none of the specified pathRules or routeRules match, the request
	// is redirected to a URL specified by defaultUrlRedirect.
	// If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Not supported when the URL map is bound to target gRPC proxy.
	DefaultUrlRedirect *HttpRedirectAction `json:"defaultUrlRedirect,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Specifies changes to request and response headers that need to take
	// effect for the selected backendService.
	// HeaderAction specified here are applied after the matching
	// HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap
	//
	// Note that headerAction is not supported for Loadbalancers that have
	// their loadBalancingScheme set to EXTERNAL.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	HeaderAction *HttpHeaderAction `json:"headerAction,omitempty"`
	// The name to which this PathMatcher is referred by the HostRule.
	Name string `json:"name,omitempty"`
	// The list of path rules. Use this list instead of routeRules when
	// routing based on simple path matching is all that's required. The
	// order by which path rules are specified does not matter. Matches are
	// always done on the longest-path-first basis.
	// For example: a pathRule with a path /a/b/c/* will match before /a/b/*
	// irrespective of the order in which those paths appear in this
	// list.
	// Within a given pathMatcher, only one of pathRules or routeRules must
	// be set.
	PathRules []*PathRule `json:"pathRules,omitempty"`
	// The list of HTTP route rules. Use this list instead of pathRules when
	// advanced route matching and routing actions are desired. routeRules
	// are evaluated in order of priority, from the lowest to highest
	// number.
	// Within a given pathMatcher, you can set only one of pathRules or
	// routeRules.
	RouteRules      []*HttpRouteRule `json:"routeRules,omitempty"`
	ForceSendFields []string         `json:"-"`
	NullFields      []string         `json:"-"`
}

// PathRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PathRule struct {
	// The list of path patterns to match. Each must start with / and the
	// only place a * is allowed is at the end following a /. The string fed
	// to the path matcher does not include any text after the first ? or #,
	// and those chars are not allowed here.
	Paths []string `json:"paths,omitempty"`
	// In response to a matching path, the load balancer performs advanced
	// routing actions like URL rewrites, header transformations, etc. prior
	// to forwarding the request to the selected backend. If routeAction
	// specifies any  weightedBackendServices, service must not be set.
	// Conversely if service is set, routeAction cannot contain any
	// weightedBackendServices.
	// Only one of routeAction or urlRedirect must be set.
	// UrlMaps for external HTTP(S) load balancers support only the
	// urlRewrite action within a pathRule's routeAction.
	RouteAction *HttpRouteAction `json:"routeAction,omitempty"`
	// The full or partial URL of the backend service resource to which
	// traffic is directed if this rule is matched. If routeAction is
	// additionally specified, advanced routing actions like URL Rewrites,
	// etc. take effect prior to sending the request to the backend.
	// However, if service is specified, routeAction cannot contain any
	// weightedBackendService s. Conversely, if routeAction specifies any
	// weightedBackendServices, service must not be specified.
	// Only one of urlRedirect, service or
	// routeAction.weightedBackendService must be set.
	Service string `json:"service,omitempty"`
	// When a path pattern is matched, the request is redirected to a URL
	// specified by urlRedirect.
	// If urlRedirect is specified, service or routeAction must not be
	// set.
	// Not supported when the URL map is bound to target gRPC proxy.
	UrlRedirect     *HttpRedirectAction `json:"urlRedirect,omitempty"`
	ForceSendFields []string            `json:"-"`
	NullFields      []string            `json:"-"`
}

// PeerAuthenticationMethod is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PeerAuthenticationMethod struct {
	// Set if mTLS is used for peer authentication.
	Mtls            *MutualTls `json:"mtls,omitempty"`
	ForceSendFields []string   `json:"-"`
	NullFields      []string   `json:"-"`
}

// Permission is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Permission struct {
	// Extra custom constraints. The constraints are ANDed together.
	Constraints []*PermissionConstraint `json:"constraints,omitempty"`
	// Used in Ingress or Egress Gateway cases to specify hosts that the
	// policy applies to. Exact match, prefix match, and suffix match are
	// supported.
	Hosts []string `json:"hosts,omitempty"`
	// HTTP method.
	Methods []string `json:"methods,omitempty"`
	// Negate of hosts. Specifies exclusions.
	NotHosts []string `json:"notHosts,omitempty"`
	// Negate of methods. Specifies exclusions.
	NotMethods []string `json:"notMethods,omitempty"`
	// Negate of paths. Specifies exclusions.
	NotPaths []string `json:"notPaths,omitempty"`
	// Negate of ports. Specifies exclusions.
	NotPorts []string `json:"notPorts,omitempty"`
	// HTTP request paths or gRPC methods. Exact match, prefix match, and
	// suffix match are supported.
	Paths []string `json:"paths,omitempty"`
	// Port names or numbers.
	Ports           []string `json:"ports,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// PermissionConstraint is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PermissionConstraint struct {
	// Key of the constraint.
	Key string `json:"key,omitempty"`
	// A list of allowed values.
	Values          []string `json:"values,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// Principal is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Principal struct {
	// An expression to specify custom condition.
	Condition string `json:"condition,omitempty"`
	// The groups the principal belongs to. Exact match, prefix match, and
	// suffix match are supported.
	Groups []string `json:"groups,omitempty"`
	// IPv4 or IPv6 address or range (In CIDR format)
	Ips []string `json:"ips,omitempty"`
	// The namespaces. Exact match, prefix match, and suffix match are
	// supported.
	Namespaces []string `json:"namespaces,omitempty"`
	// Negate of groups. Specifies exclusions.
	NotGroups []string `json:"notGroups,omitempty"`
	// Negate of IPs. Specifies exclusions.
	NotIps []string `json:"notIps,omitempty"`
	// Negate of namespaces. Specifies exclusions.
	NotNamespaces []string `json:"notNamespaces,omitempty"`
	// Negate of users. Specifies exclusions.
	NotUsers []string `json:"notUsers,omitempty"`
	// A map of Istio attribute to expected values. Exact match, prefix
	// match, and suffix match are supported for values. For example,
	// `request.headers[version]: "v1". The properties are ANDed together.
	Properties map[string]string `json:"properties,omitempty"`
	// The user names/IDs or service accounts. Exact match, prefix match,
	// and suffix match are supported.
	Users           []string `json:"users,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// RbacPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type RbacPolicy struct {
	// Name of the RbacPolicy.
	Name string `json:"name,omitempty"`
	// The list of permissions.
	Permissions []*Permission `json:"permissions,omitempty"`
	// The list of principals.
	Principals      []*Principal `json:"principals,omitempty"`
	ForceSendFields []string     `json:"-"`
	NullFields      []string     `json:"-"`
}

// RequestMirrorPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type RequestMirrorPolicy struct {
	// The full or partial URL to the BackendService resource being mirrored
	// to.
	BackendService  string   `json:"backendService,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// SSLHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SSLHealthCheck struct {
	// The TCP port number for the health check request. The default value
	// is 443. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Specifies how port is selected for health checking, can be one of
	// following values:
	// USE_FIXED_PORT: The port number in port is used for health
	// checking.
	// USE_NAMED_PORT: The portName is used for health
	// checking.
	// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for
	// each network endpoint is used for health checking. For other
	// backends, the port or named port specified in the Backend Service is
	// used for health checking.
	//
	//
	// If not specified, SSL health check follows behavior specified in port
	// and portName fields.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The application data to send once the SSL connection has been
	// established (default value is empty). If both request and response
	// are empty, the connection establishment alone will indicate health.
	// The request data can only be ASCII.
	Request string `json:"request,omitempty"`
	// The bytes to match against the beginning of the response data. If
	// left empty (the default value), any response will indicate health.
	// The response data can only be ASCII.
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// SdsConfig is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SdsConfig struct {
	// The configuration to access the SDS server over GRPC.
	GrpcServiceConfig *GrpcServiceConfig `json:"grpcServiceConfig,omitempty"`
	ForceSendFields   []string           `json:"-"`
	NullFields        []string           `json:"-"`
}

// SecuritySettings is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SecuritySettings struct {
	// [Deprecated] Use clientTlsPolicy instead.
	Authentication string `json:"authentication,omitempty"`
	// [Deprecated] Authentication policy defines what authentication
	// methods can be accepted on backends, and if authenticated, which
	// method/certificate will set the request principal. request principal.
	AuthenticationPolicy *AuthenticationPolicy `json:"authenticationPolicy,omitempty"`
	// [Deprecated] Authorization config defines the Role Based Access
	// Control (RBAC) config. Authorization config defines the Role Based
	// Access Control (RBAC) config.
	AuthorizationConfig *AuthorizationConfig `json:"authorizationConfig,omitempty"`
	// Optional. A URL referring to a networksecurity.ClientTlsPolicy
	// resource that describes how clients should authenticate with this
	// service's backends.
	// clientTlsPolicy only applies to a global BackendService with the
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// If left blank, communications are not encrypted.
	// Note: This field currently has no impact.
	ClientTlsPolicy string `json:"clientTlsPolicy,omitempty"`
	// [Deprecated] TLS Settings for the backend service.
	ClientTlsSettings *ClientTlsSettings `json:"clientTlsSettings,omitempty"`
	// Optional. A list of Subject Alternative Names (SANs) that the client
	// verifies during a mutual TLS handshake with an server/endpoint for
	// this BackendService. When the server presents its X.509 certificate
	// to the client, the client inspects the certificate's subjectAltName
	// field. If the field contains one of the specified values, the
	// communication continues. Otherwise, it fails. This additional check
	// enables the client to verify that the server is authorized to run the
	// requested service.
	// Note that the contents of the server certificate's subjectAltName
	// field are configured by the Public Key Infrastructure which
	// provisions server identities.
	// Only applies to a global BackendService with loadBalancingScheme set
	// to INTERNAL_SELF_MANAGED. Only applies when BackendService has an
	// attached clientTlsPolicy with clientCertificate (mTLS mode).
	// Note: This field currently has no impact.
	SubjectAltNames []string `json:"subjectAltNames,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// SslCertificate is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SslCertificate struct {
	// Version keeps track of the intended compute version for this SslCertificate.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// A value read into memory from a certificate file. The certificate
	// file must be in PEM format. The certificate chain must be no greater
	// than 5 certs long. The chain must include at least one intermediate
	// cert.
	Certificate string `json:"certificate,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// [Output Only] Expire time of the certificate. RFC3339
	ExpireTime string `json:"expireTime,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of the resource. Always compute#sslCertificate for
	// SSL certificates.
	Kind string `json:"kind,omitempty"`
	// Configuration and status of a managed SSL certificate.
	Managed *SslCertificateManagedSslCertificate `json:"managed,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// A value read into memory from a write-only private key file. The
	// private key file must be in PEM format. For security, only insert
	// requests include this field.
	PrivateKey string `json:"privateKey,omitempty"`
	// [Output Only] URL of the region where the regional SSL Certificate
	// resides. This field is not applicable to global SSL Certificate.
	Region string `json:"region,omitempty"`
	// [Output only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// Configuration and status of a self-managed SSL certificate.
	SelfManaged *SslCertificateSelfManagedSslCertificate `json:"selfManaged,omitempty"`
	// [Output Only] Domains associated with the certificate via Subject
	// Alternative Name.
	SubjectAlternativeNames []string `json:"subjectAlternativeNames,omitempty"`
	// (Optional) Specifies the type of SSL certificate, either
	// "SELF_MANAGED" or "MANAGED". If not specified, the certificate is
	// self-managed and the fields certificate and private_key are used.
	Type                     string `json:"type,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// SslCertificateManagedSslCertificate is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SslCertificateManagedSslCertificate struct {
	// [Output only] Detailed statuses of the domains specified for managed
	// certificate resource.
	DomainStatus map[string]string `json:"domainStatus,omitempty"`
	// The domains for which a managed SSL certificate will be generated.
	// Each Google-managed SSL certificate supports up to the [maximum
	// number of domains per Google-managed SSL
	// certificate](/load-balancing/docs/quotas#ssl_certificates).
	Domains []string `json:"domains,omitempty"`
	// [Output only] Status of the managed certificate resource.
	Status          string   `json:"status,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// SslCertificateSelfManagedSslCertificate is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SslCertificateSelfManagedSslCertificate struct {
	// A local certificate file. The certificate must be in PEM format. The
	// certificate chain must be no greater than 5 certs long. The chain
	// must include at least one intermediate cert.
	Certificate string `json:"certificate,omitempty"`
	// A write-only private key in PEM format. Only insert requests will
	// include this field.
	PrivateKey      string   `json:"privateKey,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// Subsetting is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Subsetting struct {
	Policy          string   `json:"policy,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// TCPHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TCPHealthCheck struct {
	// The TCP port number for the health check request. The default value
	// is 80. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Specifies how port is selected for health checking, can be one of
	// following values:
	// USE_FIXED_PORT: The port number in port is used for health
	// checking.
	// USE_NAMED_PORT: The portName is used for health
	// checking.
	// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for
	// each network endpoint is used for health checking. For other
	// backends, the port or named port specified in the Backend Service is
	// used for health checking.
	//
	//
	// If not specified, TCP health check follows behavior specified in port
	// and portName fields.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The application data to send once the TCP connection has been
	// established (default value is empty). If both request and response
	// are empty, the connection establishment alone will indicate health.
	// The request data can only be ASCII.
	Request string `json:"request,omitempty"`
	// The bytes to match against the beginning of the response data. If
	// left empty (the default value), any response will indicate health.
	// The response data can only be ASCII.
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// TargetHttpProxy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TargetHttpProxy struct {
	// Version keeps track of the intended compute version for this TargetHttpProxy.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a TargetHttpProxy. An up-to-date fingerprint
	// must be provided in order to patch/update the TargetHttpProxy;
	// otherwise, the request will fail with error 412 conditionNotMet. To
	// see the latest fingerprint, make a get() request to retrieve the
	// TargetHttpProxy.
	Fingerprint string `json:"fingerprint,omitempty"`
	// URLs to networkservices.HttpFilter resources enabled for xDS clients
	// using this configuration. For example,
	// https://networkservices.googleapis.com/v1alpha1/projects/project/locations/locationhttpFilters/httpFilter Only filters that handle outbound connection and stream events may be specified. These filters work in conjunction with a default set of HTTP filters that may already be configured by Traffic Director. Traffic Director will determine the final location of these filters within xDS configuration based on the name of the HTTP filter. If Traffic Director positions multiple filters at the same location, those filters will be in the same order as specified in this list.
	// httpFilters only applies for loadbalancers with loadBalancingScheme
	// set to INTERNAL_SELF_MANAGED. See ForwardingRule for more details.
	HttpFilters []string `json:"httpFilters,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of resource. Always compute#targetHttpProxy for
	// target HTTP proxies.
	Kind string `json:"kind,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// This field only applies when the forwarding rule that references this
	// target proxy has a loadBalancingScheme set to
	// INTERNAL_SELF_MANAGED.
	//
	// When this field is set to true, Envoy proxies set up inbound traffic
	// interception and bind to the IP address and port specified in the
	// forwarding rule. This is generally useful when using Traffic Director
	// to configure Envoy as a gateway or middle proxy (in other words, not
	// a sidecar proxy). The Envoy proxy listens for inbound requests and
	// handles requests when it receives them.
	//
	// The default is false.
	ProxyBind bool `json:"proxyBind,omitempty"`
	// [Output Only] URL of the region where the regional Target HTTP Proxy
	// resides. This field is not applicable to global Target HTTP Proxies.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// URL to the UrlMap resource that defines the mapping from URL to the
	// BackendService.
	UrlMap                   string `json:"urlMap,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// TargetHttpsProxy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TargetHttpsProxy struct {
	// Version keeps track of the intended compute version for this TargetHttpsProxy.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// [Deprecated] Use serverTlsPolicy instead.
	Authentication string `json:"authentication,omitempty"`
	// [Deprecated] Use authorizationPolicy instead.
	Authorization string `json:"authorization,omitempty"`
	// Optional. A URL referring to a networksecurity.AuthorizationPolicy
	// resource that describes how the proxy should authorize inbound
	// traffic. If left blank, access will not be restricted by an
	// authorization policy.
	// Refer to the AuthorizationPolicy resource for additional
	// details.
	// authorizationPolicy only applies to a global TargetHttpsProxy
	// attached to globalForwardingRules with the loadBalancingScheme set to
	// INTERNAL_SELF_MANAGED.
	// Note: This field currently has no impact.
	AuthorizationPolicy string `json:"authorizationPolicy,omitempty"`
	// URL of a certificate map that identifies a certificate map associated
	// with the given target proxy. This field can only be set for global
	// target proxies. If set, sslCertificates will be ignored.
	CertificateMap string `json:"certificateMap,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a TargetHttpsProxy. An up-to-date fingerprint
	// must be provided in order to patch the TargetHttpsProxy; otherwise,
	// the request will fail with error 412 conditionNotMet. To see the
	// latest fingerprint, make a get() request to retrieve the
	// TargetHttpsProxy.
	Fingerprint string `json:"fingerprint,omitempty"`
	// URLs to networkservices.HttpFilter resources enabled for xDS clients
	// using this configuration. For example,
	// https://networkservices.googleapis.com/beta/projects/project/locations/locationhttpFilters/httpFilter Only filters that handle outbound connection and stream events may be specified. These filters work in conjunction with a default set of HTTP filters that may already be configured by Traffic Director. Traffic Director will determine the final location of these filters within xDS configuration based on the name of the HTTP filter. If Traffic Director positions multiple filters at the same location, those filters will be in the same order as specified in this list.
	// httpFilters only applies for loadbalancers with loadBalancingScheme
	// set to INTERNAL_SELF_MANAGED. See ForwardingRule for more details.
	HttpFilters []string `json:"httpFilters,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of resource. Always compute#targetHttpsProxy for
	// target HTTPS proxies.
	Kind string `json:"kind,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// This field only applies when the forwarding rule that references this
	// target proxy has a loadBalancingScheme set to
	// INTERNAL_SELF_MANAGED.
	//
	// When this field is set to true, Envoy proxies set up inbound traffic
	// interception and bind to the IP address and port specified in the
	// forwarding rule. This is generally useful when using Traffic Director
	// to configure Envoy as a gateway or middle proxy (in other words, not
	// a sidecar proxy). The Envoy proxy listens for inbound requests and
	// handles requests when it receives them.
	//
	// The default is false.
	ProxyBind bool `json:"proxyBind,omitempty"`
	// Specifies the QUIC override policy for this TargetHttpsProxy
	// resource. This setting determines whether the load balancer attempts
	// to negotiate QUIC with clients. You can specify NONE, ENABLE, or
	// DISABLE.
	// - When quic-override is set to NONE, Google manages whether QUIC is
	// used.
	// - When quic-override is set to ENABLE, the load balancer uses QUIC
	// when possible.
	// - When quic-override is set to DISABLE, the load balancer doesn't use
	// QUIC.
	// - If the quic-override flag is not specified, NONE is implied.
	QuicOverride string `json:"quicOverride,omitempty"`
	// [Output Only] URL of the region where the regional TargetHttpsProxy
	// resides. This field is not applicable to global TargetHttpsProxies.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// [Output Only] Server-defined URL for this resource with the resource
	// id.
	SelfLinkWithId string `json:"selfLinkWithId,omitempty"`
	// Optional. A URL referring to a networksecurity.ServerTlsPolicy
	// resource that describes how the proxy should authenticate inbound
	// traffic.
	// serverTlsPolicy only applies to a global TargetHttpsProxy attached to
	// globalForwardingRules with the loadBalancingScheme set to
	// INTERNAL_SELF_MANAGED.
	// If left blank, communications are not encrypted.
	// Note: This field currently has no impact.
	ServerTlsPolicy string `json:"serverTlsPolicy,omitempty"`
	// URLs to SslCertificate resources that are used to authenticate
	// connections between users and the load balancer. At least one SSL
	// certificate must be specified. Currently, you may specify up to 15
	// SSL certificates.
	SslCertificates []string `json:"sslCertificates,omitempty"`
	// URL of SslPolicy resource that will be associated with the
	// TargetHttpsProxy resource. If not set, the TargetHttpsProxy resource
	// has no SSL policy configured.
	SslPolicy string `json:"sslPolicy,omitempty"`
	// A fully-qualified or valid partial URL to the UrlMap resource that
	// defines the mapping from URL to the BackendService. For example, the
	// following are all valid URLs for specifying a URL map:
	// -
	// https://www.googleapis.compute/v1/projects/project/global/urlMaps/url-map
	// - projects/project/global/urlMaps/url-map
	// - global/urlMaps/url-map
	UrlMap                   string `json:"urlMap,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// TlsCertificateContext is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TlsCertificateContext struct {
	// Specifies the certificate and private key paths. This field is
	// applicable only if tlsCertificateSource is set to USE_PATH.
	CertificatePaths *TlsCertificatePaths `json:"certificatePaths,omitempty"`
	// Defines how TLS certificates are obtained.
	CertificateSource string `json:"certificateSource,omitempty"`
	// Specifies the config to retrieve certificates through SDS. This field
	// is applicable only if tlsCertificateSource is set to USE_SDS.
	SdsConfig       *SdsConfig `json:"sdsConfig,omitempty"`
	ForceSendFields []string   `json:"-"`
	NullFields      []string   `json:"-"`
}

// TlsCertificatePaths is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TlsCertificatePaths struct {
	// The path to the file holding the client or server TLS certificate to
	// use.
	CertificatePath string `json:"certificatePath,omitempty"`
	// The path to the file holding the client or server private key.
	PrivateKeyPath  string   `json:"privateKeyPath,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// TlsContext is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TlsContext struct {
	// Defines the mechanism to obtain the client or server certificate.
	CertificateContext *TlsCertificateContext `json:"certificateContext,omitempty"`
	// Defines the mechanism to obtain the Certificate Authority certificate
	// to validate the client/server certificate. If omitted, the proxy will
	// not validate the server or client certificate.
	ValidationContext *TlsValidationContext `json:"validationContext,omitempty"`
	ForceSendFields   []string              `json:"-"`
	NullFields        []string              `json:"-"`
}

// TlsValidationContext is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TlsValidationContext struct {
	// The path to the file holding the CA certificate to validate the
	// client or server certificate.
	CertificatePath string `json:"certificatePath,omitempty"`
	// Specifies the config to retrieve certificates through SDS. This field
	// is applicable only if tlsCertificateSource is set to USE_SDS.
	SdsConfig *SdsConfig `json:"sdsConfig,omitempty"`
	// Defines how TLS certificates are obtained.
	ValidationSource string   `json:"validationSource,omitempty"`
	ForceSendFields  []string `json:"-"`
	NullFields       []string `json:"-"`
}

// UDPHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UDPHealthCheck struct {
	// The UDP port number for the health check request. Valid values are 1
	// through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Raw data of request to send in payload of UDP packet. It is an error
	// if this is empty. The request data can only be ASCII.
	Request string `json:"request,omitempty"`
	// The bytes to match against the beginning of the response data. It is
	// an error if this is empty. The response data can only be ASCII.
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// UrlMap is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlMap struct {
	// Version keeps track of the intended compute version for this UrlMap.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// Scope keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	Scope meta.KeyType `json:"-"`

	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// defaultRouteAction takes effect when none of the  hostRules match.
	// The load balancer performs advanced routing actions like URL
	// rewrites, header transformations, etc. prior to forwarding the
	// request to the selected backend. If defaultRouteAction specifies any
	// weightedBackendServices, defaultService must not be set. Conversely
	// if defaultService is set, defaultRouteAction cannot contain any
	// weightedBackendServices.
	// Only one of defaultRouteAction or defaultUrlRedirect must be
	// set.
	// UrlMaps for external HTTP(S) load balancers support only the
	// urlRewrite action within defaultRouteAction.
	// defaultRouteAction has no effect when the URL map is bound to target
	// gRPC proxy that has validateForProxyless field set to true.
	DefaultRouteAction *HttpRouteAction `json:"defaultRouteAction,omitempty"`
	// The full or partial URL of the defaultService resource to which
	// traffic is directed if none of the hostRules match. If
	// defaultRouteAction is additionally specified, advanced routing
	// actions like URL Rewrites, etc. take effect prior to sending the
	// request to the backend. However, if defaultService is specified,
	// defaultRouteAction cannot contain any weightedBackendServices.
	// Conversely, if routeAction specifies any weightedBackendServices,
	// service must not be specified.
	// Only one of defaultService, defaultUrlRedirect  or
	// defaultRouteAction.weightedBackendService must be set.
	// defaultService has no effect when the URL map is bound to target gRPC
	// proxy that has validateForProxyless field set to true.
	DefaultService string `json:"defaultService,omitempty"`
	// When none of the specified hostRules match, the request is redirected
	// to a URL specified by defaultUrlRedirect.
	// If defaultUrlRedirect is specified, defaultService or
	// defaultRouteAction must not be set.
	// Not supported when the URL map is bound to target gRPC proxy.
	DefaultUrlRedirect *HttpRedirectAction `json:"defaultUrlRedirect,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a UrlMap. An up-to-date fingerprint must be
	// provided in order to update the UrlMap, otherwise the request will
	// fail with error 412 conditionNotMet.
	//
	// To see the latest fingerprint, make a get() request to retrieve a
	// UrlMap.
	Fingerprint string `json:"fingerprint,omitempty"`
	// Specifies changes to request and response headers that need to take
	// effect for the selected backendService.
	// The headerAction specified here take effect after headerAction
	// specified under pathMatcher.
	// Note that headerAction is not supported for Loadbalancers that have
	// their loadBalancingScheme set to EXTERNAL.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	HeaderAction *HttpHeaderAction `json:"headerAction,omitempty"`
	// The list of HostRules to use against the URL.
	HostRules []*HostRule `json:"hostRules,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of the resource. Always compute#urlMaps for url
	// maps.
	Kind string `json:"kind,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// The list of named PathMatchers to use against the URL.
	PathMatchers []*PathMatcher `json:"pathMatchers,omitempty"`
	// [Output Only] URL of the region where the regional URL map resides.
	// This field is not applicable to global URL maps. You must specify
	// this field as part of the HTTP request URL. It is not settable as a
	// field in the request body.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// The list of expected URL mapping tests. Request to update this UrlMap
	// will succeed only if all of the test cases pass. You can specify a
	// maximum of 100 tests per UrlMap.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	Tests                    []*UrlMapTest `json:"tests,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// UrlMapTest is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlMapTest struct {
	// The weight to use for the supplied host and path when using advanced
	// routing rules that involve traffic splitting.
	BackendServiceWeight int64 `json:"backendServiceWeight,omitempty"`
	// Description of this test case.
	Description string `json:"description,omitempty"`
	// The expected output URL evaluated by load balancer containing the
	// scheme, host, path and query parameters.
	// For rules that forward requests to backends, the test passes only
	// when expectedOutputUrl matches the request forwarded by load balancer
	// to backends. For rules with urlRewrite, the test verifies that the
	// forwarded request matches hostRewrite and pathPrefixRewrite in the
	// urlRewrite action. When service is specified, expectedOutputUrl`s
	// scheme is ignored.
	// For rules with urlRedirect, the test passes only if expectedOutputUrl
	// matches the URL in the load balancer's redirect response. If
	// urlRedirect specifies https_redirect, the test passes only if the
	// scheme in expectedOutputUrl is also set to https. If urlRedirect
	// specifies strip_query, the test passes only if expectedOutputUrl does
	// not contain any query parameters.
	// expectedOutputUrl is optional when service is specified.
	ExpectedOutputUrl string `json:"expectedOutputUrl,omitempty"`
	// For rules with urlRedirect, the test passes only if
	// expectedRedirectResponseCode matches the HTTP status code in load
	// balancer's redirect response.
	// expectedRedirectResponseCode cannot be set when service is set.
	ExpectedRedirectResponseCode int64 `json:"expectedRedirectResponseCode,omitempty"`
	// The expected URL that should be redirected to for the host and path
	// being tested. [Deprecated] This field is deprecated. Use
	// expected_output_url instead.
	ExpectedUrlRedirect string `json:"expectedUrlRedirect,omitempty"`
	// HTTP headers for this request. If headers contains a host header,
	// then host must also match the header value.
	Headers []*UrlMapTestHeader `json:"headers,omitempty"`
	// Host portion of the URL. If headers contains a host header, then host
	// must also match the header value.
	Host string `json:"host,omitempty"`
	// Path portion of the URL.
	Path string `json:"path,omitempty"`
	// Expected BackendService or BackendBucket resource the given URL
	// should be mapped to.
	// service cannot be set if expectedRedirectResponseCode is set.
	Service         string   `json:"service,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// UrlMapTestHeader is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlMapTestHeader struct {
	// Header name.
	Name string `json:"name,omitempty"`
	// Header value.
	Value           string   `json:"value,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// UrlRewrite is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlRewrite struct {
	// Prior to forwarding the request to the selected service, the
	// request's host header is replaced with contents of hostRewrite.
	// The value must be between 1 and 255 characters.
	HostRewrite string `json:"hostRewrite,omitempty"`
	// Prior to forwarding the request to the selected backend service, the
	// matching portion of the request's path is replaced by
	// pathPrefixRewrite.
	// The value must be between 1 and 1024 characters.
	PathPrefixRewrite string   `json:"pathPrefixRewrite,omitempty"`
	ForceSendFields   []string `json:"-"`
	NullFields        []string `json:"-"`
}

// WeightedBackendService is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type WeightedBackendService struct {
	// The full or partial URL to the default BackendService resource.
	// Before forwarding the request to backendService, the loadbalancer
	// applies any relevant headerActions specified as part of this
	// backendServiceWeight.
	BackendService string `json:"backendService,omitempty"`
	// Specifies changes to request and response headers that need to take
	// effect for the selected backendService.
	// headerAction specified here take effect before headerAction in the
	// enclosing HttpRouteRule, PathMatcher and UrlMap.
	// Note that headerAction is not supported for Loadbalancers that have
	// their loadBalancingScheme set to EXTERNAL.
	// Not supported when the URL map is bound to target gRPC proxy that has
	// validateForProxyless field set to true.
	HeaderAction *HttpHeaderAction `json:"headerAction,omitempty"`
	// Specifies the fraction of traffic sent to backendService, computed as
	// weight / (sum of all weightedBackendService weights in routeAction)
	// .
	// The selection of a backend service is determined only for new
	// traffic. Once a user's request has been directed to a backendService,
	// subsequent requests will be sent to the same backendService as
	// determined by the BackendService's session affinity policy.
	// The value must be between 0 and 1000
	Weight          int64    `json:"weight,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

func CreateAddress(gceCloud *gce.Cloud, key *meta.Key, address *Address) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("Address", "create", key.Region, key.Zone, string(address.Version))

	switch address.Version {
	case meta.VersionAlpha:
		alpha, err := address.ToAlpha()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating alpha region Address %v", alpha.Name)
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaAddresses().Insert(ctx, key, alpha))
		default:
			klog.V(3).Infof("Creating alpha Address %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaGlobalAddresses().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := address.ToBeta()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating beta region Address %v", beta.Name)
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaAddresses().Insert(ctx, key, beta))
		default:
			klog.V(3).Infof("Creating beta Address %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaGlobalAddresses().Insert(ctx, key, beta))
		}
	default:
		ga, err := address.ToGA()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating ga region Address %v", ga.Name)
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().Addresses().Insert(ctx, key, ga))
		default:
			klog.V(3).Infof("Creating ga Address %v", ga.Name)
			return mc.Observe(gceCloud.Compute().GlobalAddresses().Insert(ctx, key, ga))
		}
	}
}

func DeleteAddress(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("Address", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting alpha region Address %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaAddresses().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting alpha Address %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaGlobalAddresses().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting beta region Address %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaAddresses().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting beta Address %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaGlobalAddresses().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting ga region Address %v", key.Name)
			return mc.Observe(gceCloud.Compute().Addresses().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting ga Address %v", key.Name)
			return mc.Observe(gceCloud.Compute().GlobalAddresses().Delete(ctx, key))
		}
	}
}

func GetAddress(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) (*Address, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("Address", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting alpha region Address %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaAddresses().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting alpha Address %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaGlobalAddresses().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting beta region Address %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaAddresses().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting beta Address %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaGlobalAddresses().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting ga region Address %v", key.Name)
			gceObj, err = gceCloud.Compute().Addresses().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting ga Address %v", key.Name)
			gceObj, err = gceCloud.Compute().GlobalAddresses().Get(ctx, key)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	compositeType, err := toAddress(gceObj)
	if err != nil {
		return nil, err
	}
	if key.Type() == meta.Regional {
		compositeType.Scope = meta.Regional
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListAddresses(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) ([]*Address, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("Address", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing alpha region Address")
			gceObjs, err = gceCloud.Compute().AlphaAddresses().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing alpha Address")
			gceObjs, err = gceCloud.Compute().AlphaGlobalAddresses().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing beta region Address")
			gceObjs, err = gceCloud.Compute().BetaAddresses().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing beta Address")
			gceObjs, err = gceCloud.Compute().BetaGlobalAddresses().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing ga region Address")
			gceObjs, err = gceCloud.Compute().Addresses().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing ga Address")
			gceObjs, err = gceCloud.Compute().GlobalAddresses().List(ctx, filter.None)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}

	compositeObjs, err := toAddressList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toAddressList converts a list of compute alpha, beta or GA
// Address into a list of our composite type.
func toAddressList(objs interface{}) ([]*Address, error) {
	result := []*Address{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toAddress is for package internal use only (not type-safe).
func toAddress(obj interface{}) (*Address, error) {
	x := &Address{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToAddress convert to a composite type.
func AlphaToAddress(obj *computealpha.Address) (*Address, error) {
	x := &Address{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToAddress convert to a composite type.
func BetaToAddress(obj *computebeta.Address) (*Address, error) {
	x := &Address{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToAddress convert to a composite type.
func GAToAddress(obj *compute.Address) (*Address, error) {
	x := &Address{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (address *Address) ToAlpha() (*computealpha.Address, error) {
	alpha := &computealpha.Address{}
	err := copyViaJSON(alpha, address)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", address, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (address *Address) ToBeta() (*computebeta.Address, error) {
	beta := &computebeta.Address{}
	err := copyViaJSON(beta, address)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", address, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (address *Address) ToGA() (*compute.Address, error) {
	ga := &compute.Address{}
	err := copyViaJSON(ga, address)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", address, err)
	}

	return ga, nil
}

func CreateBackendService(gceCloud *gce.Cloud, key *meta.Key, backendService *BackendService) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "create", key.Region, key.Zone, string(backendService.Version))

	switch backendService.Version {
	case meta.VersionAlpha:
		alpha, err := backendService.ToAlpha()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating alpha region BackendService %v", alpha.Name)
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionBackendServices().Insert(ctx, key, alpha))
		default:
			klog.V(3).Infof("Creating alpha BackendService %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaBackendServices().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := backendService.ToBeta()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating beta region BackendService %v", beta.Name)
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionBackendServices().Insert(ctx, key, beta))
		default:
			klog.V(3).Infof("Creating beta BackendService %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaBackendServices().Insert(ctx, key, beta))
		}
	default:
		ga, err := backendService.ToGA()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating ga region BackendService %v", ga.Name)
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionBackendServices().Insert(ctx, key, ga))
		default:
			klog.V(3).Infof("Creating ga BackendService %v", ga.Name)
			return mc.Observe(gceCloud.Compute().BackendServices().Insert(ctx, key, ga))
		}
	}
}

func UpdateBackendService(gceCloud *gce.Cloud, key *meta.Key, backendService *BackendService) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "update", key.Region, key.Zone, string(backendService.Version))
	switch backendService.Version {
	case meta.VersionAlpha:
		alpha, err := backendService.ToAlpha()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Updating alpha region BackendService %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaRegionBackendServices().Update(ctx, key, alpha))
		default:
			klog.V(3).Infof("Updating alpha BackendService %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaBackendServices().Update(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := backendService.ToBeta()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Updating beta region BackendService %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaRegionBackendServices().Update(ctx, key, beta))
		default:
			klog.V(3).Infof("Updating beta BackendService %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaBackendServices().Update(ctx, key, beta))
		}
	default:
		ga, err := backendService.ToGA()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Updating ga region BackendService %v", ga.Name)
			return mc.Observe(gceCloud.Compute().RegionBackendServices().Update(ctx, key, ga))
		default:
			klog.V(3).Infof("Updating ga BackendService %v", ga.Name)
			return mc.Observe(gceCloud.Compute().BackendServices().Update(ctx, key, ga))
		}
	}
}

func DeleteBackendService(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting alpha region BackendService %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaRegionBackendServices().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting alpha BackendService %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaBackendServices().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting beta region BackendService %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaRegionBackendServices().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting beta BackendService %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaBackendServices().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting ga region BackendService %v", key.Name)
			return mc.Observe(gceCloud.Compute().RegionBackendServices().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting ga BackendService %v", key.Name)
			return mc.Observe(gceCloud.Compute().BackendServices().Delete(ctx, key))
		}
	}
}

func GetBackendService(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) (*BackendService, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting alpha region BackendService %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaRegionBackendServices().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting alpha BackendService %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaBackendServices().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting beta region BackendService %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaRegionBackendServices().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting beta BackendService %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaBackendServices().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting ga region BackendService %v", key.Name)
			gceObj, err = gceCloud.Compute().RegionBackendServices().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting ga BackendService %v", key.Name)
			gceObj, err = gceCloud.Compute().BackendServices().Get(ctx, key)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	compositeType, err := toBackendService(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListBackendServices(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) ([]*BackendService, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing alpha region BackendService")
			gceObjs, err = gceCloud.Compute().AlphaRegionBackendServices().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing alpha BackendService")
			gceObjs, err = gceCloud.Compute().AlphaBackendServices().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing beta region BackendService")
			gceObjs, err = gceCloud.Compute().BetaRegionBackendServices().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing beta BackendService")
			gceObjs, err = gceCloud.Compute().BetaBackendServices().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing ga region BackendService")
			gceObjs, err = gceCloud.Compute().RegionBackendServices().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing ga BackendService")
			gceObjs, err = gceCloud.Compute().BackendServices().List(ctx, filter.None)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}

	compositeObjs, err := toBackendServiceList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toBackendServiceList converts a list of compute alpha, beta or GA
// BackendService into a list of our composite type.
func toBackendServiceList(objs interface{}) ([]*BackendService, error) {
	result := []*BackendService{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toBackendService is for package internal use only (not type-safe).
func toBackendService(obj interface{}) (*BackendService, error) {
	x := &BackendService{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToBackendService convert to a composite type.
func AlphaToBackendService(obj *computealpha.BackendService) (*BackendService, error) {
	x := &BackendService{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToBackendService convert to a composite type.
func BetaToBackendService(obj *computebeta.BackendService) (*BackendService, error) {
	x := &BackendService{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToBackendService convert to a composite type.
func GAToBackendService(obj *compute.BackendService) (*BackendService, error) {
	x := &BackendService{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (backendService *BackendService) ToAlpha() (*computealpha.BackendService, error) {
	alpha := &computealpha.BackendService{}
	err := copyViaJSON(alpha, backendService)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", backendService, err)
	}
	// Set force send fields. This is a temporary hack.
	if alpha.CdnPolicy != nil && alpha.CdnPolicy.CacheKeyPolicy != nil {
		alpha.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
	}
	if alpha.Iap != nil {
		alpha.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}
	if alpha.LogConfig != nil {
		alpha.LogConfig.ForceSendFields = []string{"Enable"}
		if alpha.LogConfig.Enable {
			alpha.LogConfig.ForceSendFields = []string{"Enable", "SampleRate"}
		}
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (backendService *BackendService) ToBeta() (*computebeta.BackendService, error) {
	beta := &computebeta.BackendService{}
	err := copyViaJSON(beta, backendService)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", backendService, err)
	}
	// Set force send fields. This is a temporary hack.
	if beta.CdnPolicy != nil && beta.CdnPolicy.CacheKeyPolicy != nil {
		beta.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
	}
	if beta.Iap != nil {
		beta.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}
	if beta.LogConfig != nil {
		beta.LogConfig.ForceSendFields = []string{"Enable"}
		if beta.LogConfig.Enable {
			beta.LogConfig.ForceSendFields = []string{"Enable", "SampleRate"}
		}
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (backendService *BackendService) ToGA() (*compute.BackendService, error) {
	ga := &compute.BackendService{}
	err := copyViaJSON(ga, backendService)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", backendService, err)
	}
	// Set force send fields. This is a temporary hack.
	if ga.CdnPolicy != nil && ga.CdnPolicy.CacheKeyPolicy != nil {
		ga.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
	}
	if ga.Iap != nil {
		ga.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}
	if ga.LogConfig != nil {
		ga.LogConfig.ForceSendFields = []string{"Enable"}
		if ga.LogConfig.Enable {
			ga.LogConfig.ForceSendFields = []string{"Enable", "SampleRate"}
		}
	}

	return ga, nil
}

func CreateForwardingRule(gceCloud *gce.Cloud, key *meta.Key, forwardingRule *ForwardingRule) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("ForwardingRule", "create", key.Region, key.Zone, string(forwardingRule.Version))

	switch forwardingRule.Version {
	case meta.VersionAlpha:
		alpha, err := forwardingRule.ToAlpha()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating alpha region ForwardingRule %v", alpha.Name)
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaForwardingRules().Insert(ctx, key, alpha))
		default:
			klog.V(3).Infof("Creating alpha ForwardingRule %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaGlobalForwardingRules().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := forwardingRule.ToBeta()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating beta region ForwardingRule %v", beta.Name)
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaForwardingRules().Insert(ctx, key, beta))
		default:
			klog.V(3).Infof("Creating beta ForwardingRule %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaGlobalForwardingRules().Insert(ctx, key, beta))
		}
	default:
		ga, err := forwardingRule.ToGA()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating ga region ForwardingRule %v", ga.Name)
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().ForwardingRules().Insert(ctx, key, ga))
		default:
			klog.V(3).Infof("Creating ga ForwardingRule %v", ga.Name)
			return mc.Observe(gceCloud.Compute().GlobalForwardingRules().Insert(ctx, key, ga))
		}
	}
}

func DeleteForwardingRule(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("ForwardingRule", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting alpha region ForwardingRule %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaForwardingRules().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting alpha ForwardingRule %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaGlobalForwardingRules().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting beta region ForwardingRule %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaForwardingRules().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting beta ForwardingRule %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaGlobalForwardingRules().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting ga region ForwardingRule %v", key.Name)
			return mc.Observe(gceCloud.Compute().ForwardingRules().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting ga ForwardingRule %v", key.Name)
			return mc.Observe(gceCloud.Compute().GlobalForwardingRules().Delete(ctx, key))
		}
	}
}

func GetForwardingRule(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) (*ForwardingRule, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("ForwardingRule", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting alpha region ForwardingRule %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaForwardingRules().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting alpha ForwardingRule %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaGlobalForwardingRules().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting beta region ForwardingRule %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaForwardingRules().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting beta ForwardingRule %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaGlobalForwardingRules().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting ga region ForwardingRule %v", key.Name)
			gceObj, err = gceCloud.Compute().ForwardingRules().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting ga ForwardingRule %v", key.Name)
			gceObj, err = gceCloud.Compute().GlobalForwardingRules().Get(ctx, key)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	compositeType, err := toForwardingRule(gceObj)
	if err != nil {
		return nil, err
	}
	if key.Type() == meta.Regional {
		compositeType.Scope = meta.Regional
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListForwardingRules(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) ([]*ForwardingRule, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("ForwardingRule", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing alpha region ForwardingRule")
			gceObjs, err = gceCloud.Compute().AlphaForwardingRules().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing alpha ForwardingRule")
			gceObjs, err = gceCloud.Compute().AlphaGlobalForwardingRules().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing beta region ForwardingRule")
			gceObjs, err = gceCloud.Compute().BetaForwardingRules().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing beta ForwardingRule")
			gceObjs, err = gceCloud.Compute().BetaGlobalForwardingRules().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing ga region ForwardingRule")
			gceObjs, err = gceCloud.Compute().ForwardingRules().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing ga ForwardingRule")
			gceObjs, err = gceCloud.Compute().GlobalForwardingRules().List(ctx, filter.None)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}

	compositeObjs, err := toForwardingRuleList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toForwardingRuleList converts a list of compute alpha, beta or GA
// ForwardingRule into a list of our composite type.
func toForwardingRuleList(objs interface{}) ([]*ForwardingRule, error) {
	result := []*ForwardingRule{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toForwardingRule is for package internal use only (not type-safe).
func toForwardingRule(obj interface{}) (*ForwardingRule, error) {
	x := &ForwardingRule{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToForwardingRule convert to a composite type.
func AlphaToForwardingRule(obj *computealpha.ForwardingRule) (*ForwardingRule, error) {
	x := &ForwardingRule{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToForwardingRule convert to a composite type.
func BetaToForwardingRule(obj *computebeta.ForwardingRule) (*ForwardingRule, error) {
	x := &ForwardingRule{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToForwardingRule convert to a composite type.
func GAToForwardingRule(obj *compute.ForwardingRule) (*ForwardingRule, error) {
	x := &ForwardingRule{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) ToAlpha() (*computealpha.ForwardingRule, error) {
	alpha := &computealpha.ForwardingRule{}
	err := copyViaJSON(alpha, forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", forwardingRule, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) ToBeta() (*computebeta.ForwardingRule, error) {
	beta := &computebeta.ForwardingRule{}
	err := copyViaJSON(beta, forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", forwardingRule, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) ToGA() (*compute.ForwardingRule, error) {
	ga := &compute.ForwardingRule{}
	err := copyViaJSON(ga, forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", forwardingRule, err)
	}

	return ga, nil
}

func CreateHealthCheck(gceCloud *gce.Cloud, key *meta.Key, healthCheck *HealthCheck) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "create", key.Region, key.Zone, string(healthCheck.Version))

	switch healthCheck.Version {
	case meta.VersionAlpha:
		alpha, err := healthCheck.ToAlpha()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating alpha region HealthCheck %v", alpha.Name)
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionHealthChecks().Insert(ctx, key, alpha))
		default:
			klog.V(3).Infof("Creating alpha HealthCheck %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaHealthChecks().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := healthCheck.ToBeta()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating beta region HealthCheck %v", beta.Name)
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionHealthChecks().Insert(ctx, key, beta))
		default:
			klog.V(3).Infof("Creating beta HealthCheck %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaHealthChecks().Insert(ctx, key, beta))
		}
	default:
		ga, err := healthCheck.ToGA()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating ga region HealthCheck %v", ga.Name)
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionHealthChecks().Insert(ctx, key, ga))
		default:
			klog.V(3).Infof("Creating ga HealthCheck %v", ga.Name)
			return mc.Observe(gceCloud.Compute().HealthChecks().Insert(ctx, key, ga))
		}
	}
}

func UpdateHealthCheck(gceCloud *gce.Cloud, key *meta.Key, healthCheck *HealthCheck) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "update", key.Region, key.Zone, string(healthCheck.Version))
	switch healthCheck.Version {
	case meta.VersionAlpha:
		alpha, err := healthCheck.ToAlpha()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Updating alpha region HealthCheck %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaRegionHealthChecks().Update(ctx, key, alpha))
		default:
			klog.V(3).Infof("Updating alpha HealthCheck %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaHealthChecks().Update(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := healthCheck.ToBeta()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Updating beta region HealthCheck %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaRegionHealthChecks().Update(ctx, key, beta))
		default:
			klog.V(3).Infof("Updating beta HealthCheck %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaHealthChecks().Update(ctx, key, beta))
		}
	default:
		ga, err := healthCheck.ToGA()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Updating ga region HealthCheck %v", ga.Name)
			return mc.Observe(gceCloud.Compute().RegionHealthChecks().Update(ctx, key, ga))
		default:
			klog.V(3).Infof("Updating ga HealthCheck %v", ga.Name)
			return mc.Observe(gceCloud.Compute().HealthChecks().Update(ctx, key, ga))
		}
	}
}

func DeleteHealthCheck(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting alpha region HealthCheck %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaRegionHealthChecks().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting alpha HealthCheck %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaHealthChecks().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting beta region HealthCheck %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaRegionHealthChecks().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting beta HealthCheck %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaHealthChecks().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting ga region HealthCheck %v", key.Name)
			return mc.Observe(gceCloud.Compute().RegionHealthChecks().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting ga HealthCheck %v", key.Name)
			return mc.Observe(gceCloud.Compute().HealthChecks().Delete(ctx, key))
		}
	}
}

func GetHealthCheck(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) (*HealthCheck, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting alpha region HealthCheck %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaRegionHealthChecks().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting alpha HealthCheck %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaHealthChecks().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting beta region HealthCheck %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaRegionHealthChecks().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting beta HealthCheck %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaHealthChecks().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting ga region HealthCheck %v", key.Name)
			gceObj, err = gceCloud.Compute().RegionHealthChecks().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting ga HealthCheck %v", key.Name)
			gceObj, err = gceCloud.Compute().HealthChecks().Get(ctx, key)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	compositeType, err := toHealthCheck(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListHealthChecks(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) ([]*HealthCheck, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing alpha region HealthCheck")
			gceObjs, err = gceCloud.Compute().AlphaRegionHealthChecks().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing alpha HealthCheck")
			gceObjs, err = gceCloud.Compute().AlphaHealthChecks().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing beta region HealthCheck")
			gceObjs, err = gceCloud.Compute().BetaRegionHealthChecks().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing beta HealthCheck")
			gceObjs, err = gceCloud.Compute().BetaHealthChecks().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing ga region HealthCheck")
			gceObjs, err = gceCloud.Compute().RegionHealthChecks().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing ga HealthCheck")
			gceObjs, err = gceCloud.Compute().HealthChecks().List(ctx, filter.None)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}

	compositeObjs, err := toHealthCheckList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toHealthCheckList converts a list of compute alpha, beta or GA
// HealthCheck into a list of our composite type.
func toHealthCheckList(objs interface{}) ([]*HealthCheck, error) {
	result := []*HealthCheck{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toHealthCheck is for package internal use only (not type-safe).
func toHealthCheck(obj interface{}) (*HealthCheck, error) {
	x := &HealthCheck{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToHealthCheck convert to a composite type.
func AlphaToHealthCheck(obj *computealpha.HealthCheck) (*HealthCheck, error) {
	x := &HealthCheck{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToHealthCheck convert to a composite type.
func BetaToHealthCheck(obj *computebeta.HealthCheck) (*HealthCheck, error) {
	x := &HealthCheck{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToHealthCheck convert to a composite type.
func GAToHealthCheck(obj *compute.HealthCheck) (*HealthCheck, error) {
	x := &HealthCheck{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (healthCheck *HealthCheck) ToAlpha() (*computealpha.HealthCheck, error) {
	alpha := &computealpha.HealthCheck{}
	err := copyViaJSON(alpha, healthCheck)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", healthCheck, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (healthCheck *HealthCheck) ToBeta() (*computebeta.HealthCheck, error) {
	beta := &computebeta.HealthCheck{}
	err := copyViaJSON(beta, healthCheck)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", healthCheck, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (healthCheck *HealthCheck) ToGA() (*compute.HealthCheck, error) {
	ga := &compute.HealthCheck{}
	err := copyViaJSON(ga, healthCheck)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", healthCheck, err)
	}

	return ga, nil
}

// toHealthStatusForNetworkEndpointList converts a list of compute alpha, beta or GA
// HealthStatusForNetworkEndpoint into a list of our composite type.
func toHealthStatusForNetworkEndpointList(objs interface{}) ([]*HealthStatusForNetworkEndpoint, error) {
	result := []*HealthStatusForNetworkEndpoint{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toHealthStatusForNetworkEndpoint is for package internal use only (not type-safe).
func toHealthStatusForNetworkEndpoint(obj interface{}) (*HealthStatusForNetworkEndpoint, error) {
	x := &HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToHealthStatusForNetworkEndpoint convert to a composite type.
func AlphaToHealthStatusForNetworkEndpoint(obj *computealpha.HealthStatusForNetworkEndpoint) (*HealthStatusForNetworkEndpoint, error) {
	x := &HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToHealthStatusForNetworkEndpoint convert to a composite type.
func BetaToHealthStatusForNetworkEndpoint(obj *computebeta.HealthStatusForNetworkEndpoint) (*HealthStatusForNetworkEndpoint, error) {
	x := &HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToHealthStatusForNetworkEndpoint convert to a composite type.
func GAToHealthStatusForNetworkEndpoint(obj *compute.HealthStatusForNetworkEndpoint) (*HealthStatusForNetworkEndpoint, error) {
	x := &HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (healthStatusForNetworkEndpoint *HealthStatusForNetworkEndpoint) ToAlpha() (*computealpha.HealthStatusForNetworkEndpoint, error) {
	alpha := &computealpha.HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(alpha, healthStatusForNetworkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", healthStatusForNetworkEndpoint, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (healthStatusForNetworkEndpoint *HealthStatusForNetworkEndpoint) ToBeta() (*computebeta.HealthStatusForNetworkEndpoint, error) {
	beta := &computebeta.HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(beta, healthStatusForNetworkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", healthStatusForNetworkEndpoint, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (healthStatusForNetworkEndpoint *HealthStatusForNetworkEndpoint) ToGA() (*compute.HealthStatusForNetworkEndpoint, error) {
	ga := &compute.HealthStatusForNetworkEndpoint{}
	err := copyViaJSON(ga, healthStatusForNetworkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", healthStatusForNetworkEndpoint, err)
	}

	return ga, nil
}

// toNetworkEndpointList converts a list of compute alpha, beta or GA
// NetworkEndpoint into a list of our composite type.
func toNetworkEndpointList(objs interface{}) ([]*NetworkEndpoint, error) {
	result := []*NetworkEndpoint{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpoint is for package internal use only (not type-safe).
func toNetworkEndpoint(obj interface{}) (*NetworkEndpoint, error) {
	x := &NetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpoint convert to a composite type.
func AlphaToNetworkEndpoint(obj *computealpha.NetworkEndpoint) (*NetworkEndpoint, error) {
	x := &NetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpoint convert to a composite type.
func BetaToNetworkEndpoint(obj *computebeta.NetworkEndpoint) (*NetworkEndpoint, error) {
	x := &NetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpoint convert to a composite type.
func GAToNetworkEndpoint(obj *compute.NetworkEndpoint) (*NetworkEndpoint, error) {
	x := &NetworkEndpoint{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpoint *NetworkEndpoint) ToAlpha() (*computealpha.NetworkEndpoint, error) {
	alpha := &computealpha.NetworkEndpoint{}
	err := copyViaJSON(alpha, networkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpoint, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpoint *NetworkEndpoint) ToBeta() (*computebeta.NetworkEndpoint, error) {
	beta := &computebeta.NetworkEndpoint{}
	err := copyViaJSON(beta, networkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpoint, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpoint *NetworkEndpoint) ToGA() (*compute.NetworkEndpoint, error) {
	ga := &compute.NetworkEndpoint{}
	err := copyViaJSON(ga, networkEndpoint)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpoint, err)
	}

	return ga, nil
}

func CreateNetworkEndpointGroup(gceCloud *gce.Cloud, key *meta.Key, networkEndpointGroup *NetworkEndpointGroup) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "create", key.Region, key.Zone, string(networkEndpointGroup.Version))
	switch key.Type() {
	case meta.Zonal:
	default:
		return fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}

	switch networkEndpointGroup.Version {
	case meta.VersionAlpha:
		alpha, err := networkEndpointGroup.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha zonal NetworkEndpointGroup %v", alpha.Name)
		return mc.Observe(gceCloud.Compute().AlphaNetworkEndpointGroups().Insert(ctx, key, alpha))
	case meta.VersionBeta:
		beta, err := networkEndpointGroup.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta zonal NetworkEndpointGroup %v", beta.Name)
		return mc.Observe(gceCloud.Compute().BetaNetworkEndpointGroups().Insert(ctx, key, beta))
	default:
		ga, err := networkEndpointGroup.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga zonal NetworkEndpointGroup %v", ga.Name)
		return mc.Observe(gceCloud.Compute().NetworkEndpointGroups().Insert(ctx, key, ga))
	}
}

func DeleteNetworkEndpointGroup(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "delete", key.Region, key.Zone, string(version))
	switch key.Type() {
	case meta.Zonal:
	default:
		return fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}

	switch version {
	case meta.VersionAlpha:
		klog.V(3).Infof("Deleting alpha zonal NetworkEndpointGroup %v", key.Name)
		return mc.Observe(gceCloud.Compute().AlphaNetworkEndpointGroups().Delete(ctx, key))
	case meta.VersionBeta:
		klog.V(3).Infof("Deleting beta zonal NetworkEndpointGroup %v", key.Name)
		return mc.Observe(gceCloud.Compute().BetaNetworkEndpointGroups().Delete(ctx, key))
	default:
		klog.V(3).Infof("Deleting ga zonal NetworkEndpointGroup %v", key.Name)
		return mc.Observe(gceCloud.Compute().NetworkEndpointGroups().Delete(ctx, key))
	}
}

func GetNetworkEndpointGroup(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) (*NetworkEndpointGroup, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch key.Type() {
	case meta.Zonal:
	default:
		return nil, fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}
	switch version {
	case meta.VersionAlpha:
		klog.V(3).Infof("Getting alpha zonal NetworkEndpointGroup %v", key.Name)
		gceObj, err = gceCloud.Compute().AlphaNetworkEndpointGroups().Get(ctx, key)
	case meta.VersionBeta:
		klog.V(3).Infof("Getting beta zonal NetworkEndpointGroup %v", key.Name)
		gceObj, err = gceCloud.Compute().BetaNetworkEndpointGroups().Get(ctx, key)

	default:
		klog.V(3).Infof("Getting ga zonal NetworkEndpointGroup %v", key.Name)
		gceObj, err = gceCloud.Compute().NetworkEndpointGroups().Get(ctx, key)
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	compositeType, err := toNetworkEndpointGroup(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Scope = meta.Zonal
	compositeType.Version = version
	return compositeType, nil
}

func ListNetworkEndpointGroups(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) ([]*NetworkEndpointGroup, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch key.Type() {
	case meta.Zonal:
	default:
		return nil, fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}
	switch version {
	case meta.VersionAlpha:
		klog.V(3).Infof("Listing alpha zoneNetworkEndpointGroup")
		gceObjs, err = gceCloud.Compute().AlphaNetworkEndpointGroups().List(ctx, key.Zone, filter.None)
	case meta.VersionBeta:
		klog.V(3).Infof("Listing beta zoneNetworkEndpointGroup")
		gceObjs, err = gceCloud.Compute().BetaNetworkEndpointGroups().List(ctx, key.Zone, filter.None)
	default:
		klog.V(3).Infof("Listing ga zoneNetworkEndpointGroup")
		gceObjs, err = gceCloud.Compute().NetworkEndpointGroups().List(ctx, key.Zone, filter.None)
	}
	if err != nil {
		return nil, mc.Observe(err)
	}

	compositeObjs, err := toNetworkEndpointGroupList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

func AttachNetworkEndpoints(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, req *NetworkEndpointGroupsAttachEndpointsRequest) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "attach", key.Region, key.Zone, string(version))

	switch key.Type() {
	case meta.Zonal:
	default:
		return fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}

	switch version {
	case meta.VersionAlpha:
		alphareq, err := req.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Attaching to alpha zonal NetworkEndpointGroup %v", key.Name)
		return mc.Observe(gceCloud.Compute().AlphaNetworkEndpointGroups().AttachNetworkEndpoints(ctx, key, alphareq))
	case meta.VersionBeta:
		betareq, err := req.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Attaching to beta zonal NetworkEndpointGroup %v", key.Name)
		return mc.Observe(gceCloud.Compute().BetaNetworkEndpointGroups().AttachNetworkEndpoints(ctx, key, betareq))
	default:
		gareq, err := req.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Attaching to ga zonal NetworkEndpointGroup %v", key.Name)
		return mc.Observe(gceCloud.Compute().NetworkEndpointGroups().AttachNetworkEndpoints(ctx, key, gareq))
	}
}

func DetachNetworkEndpoints(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, req *NetworkEndpointGroupsDetachEndpointsRequest) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "detach", key.Region, key.Zone, string(version))

	switch key.Type() {
	case meta.Zonal:
	default:
		return fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}

	switch version {
	case meta.VersionAlpha:
		alphareq, err := req.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Detaching from alpha zonal NetworkEndpointGroup %v", key.Name)
		return mc.Observe(gceCloud.Compute().AlphaNetworkEndpointGroups().DetachNetworkEndpoints(ctx, key, alphareq))
	case meta.VersionBeta:
		betareq, err := req.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Detaching from beta zonal NetworkEndpointGroup %v", key.Name)
		return mc.Observe(gceCloud.Compute().BetaNetworkEndpointGroups().DetachNetworkEndpoints(ctx, key, betareq))
	default:
		gareq, err := req.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Detaching from ga zonal NetworkEndpointGroup %v", key.Name)
		return mc.Observe(gceCloud.Compute().NetworkEndpointGroups().DetachNetworkEndpoints(ctx, key, gareq))
	}
}

func ListNetworkEndpoints(gceCloud *gce.Cloud, key *meta.Key, version meta.Version, req *NetworkEndpointGroupsListEndpointsRequest) ([]*NetworkEndpointWithHealthStatus, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error

	switch key.Type() {
	case meta.Zonal:
	default:
		return nil, fmt.Errorf("Key %v not valid for zonal resource NetworkEndpointGroup %v", key, key.Name)
	}

	switch version {
	case meta.VersionAlpha:
		alphareq, reqerr := req.ToAlpha()
		if reqerr != nil {
			return nil, reqerr
		}
		klog.V(3).Infof("Listing alpha zonal NetworkEndpointGroup %v", key.Name)
		gceObjs, err = gceCloud.Compute().AlphaNetworkEndpointGroups().ListNetworkEndpoints(ctx, key, alphareq, filter.None)
	case meta.VersionBeta:
		betareq, reqerr := req.ToBeta()
		if reqerr != nil {
			return nil, reqerr
		}
		klog.V(3).Infof("Listing beta zonal NetworkEndpointGroup %v", key.Name)
		gceObjs, err = gceCloud.Compute().BetaNetworkEndpointGroups().ListNetworkEndpoints(ctx, key, betareq, filter.None)
	default:
		gareq, reqerr := req.ToGA()
		if reqerr != nil {
			return nil, reqerr
		}
		klog.V(3).Infof("Listing ga zonal NetworkEndpointGroup %v", key.Name)
		gceObjs, err = gceCloud.Compute().NetworkEndpointGroups().ListNetworkEndpoints(ctx, key, gareq, filter.None)
	}
	if err != nil {
		return nil, mc.Observe(err)
	}

	compositeObjs, err := toNetworkEndpointWithHealthStatusList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

func AggregatedListNetworkEndpointGroup(gceCloud *gce.Cloud, version meta.Version) (map[*meta.Key]*NetworkEndpointGroup, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("NetworkEndpointGroup", "aggregateList", "", "", string(version))

	compositeMap := make(map[*meta.Key]*NetworkEndpointGroup)
	var gceObjs interface{}

	switch version {
	case meta.VersionAlpha:
		klog.V(3).Infof("Aggregate List of alpha zonal NetworkEndpointGroup")
		alphaMap, err := gceCloud.Compute().AlphaNetworkEndpointGroups().AggregatedList(ctx, filter.None)
		if err != nil {
			return nil, mc.Observe(err)
		}
		// Convert from map to list
		alphaList := []*computealpha.NetworkEndpointGroup{}
		for _, val := range alphaMap {
			alphaList = append(alphaList, val...)
		}
		gceObjs = alphaList
	case meta.VersionBeta:
		klog.V(3).Infof("Aggregate List of beta zonal NetworkEndpointGroup")
		betaMap, err := gceCloud.Compute().BetaNetworkEndpointGroups().AggregatedList(ctx, filter.None)
		if err != nil {
			return nil, mc.Observe(err)
		}
		// Convert from map to list
		betaList := []*computebeta.NetworkEndpointGroup{}
		for _, val := range betaMap {
			betaList = append(betaList, val...)
		}
		gceObjs = betaList
	default:
		klog.V(3).Infof("Aggregate List of ga zonal NetworkEndpointGroup")
		gaMap, err := gceCloud.Compute().NetworkEndpointGroups().AggregatedList(ctx, filter.None)
		if err != nil {
			return nil, mc.Observe(err)
		}
		// Convert from map to list
		gaList := []*compute.NetworkEndpointGroup{}
		for _, val := range gaMap {
			gaList = append(gaList, val...)
		}
		gceObjs = gaList
	}
	compositeObjs, err := toNetworkEndpointGroupList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
		resourceID, err := cloudprovider.ParseResourceURL(obj.SelfLink)
		if err != nil || resourceID == nil || resourceID.Key == nil {
			klog.Errorf("Failed to parse SelfLink - %s for obj %v, err %v", obj.SelfLink, obj, err)
			continue
		}
		compositeMap[resourceID.Key] = obj
	}

	return compositeMap, nil
}

// toNetworkEndpointGroupList converts a list of compute alpha, beta or GA
// NetworkEndpointGroup into a list of our composite type.
func toNetworkEndpointGroupList(objs interface{}) ([]*NetworkEndpointGroup, error) {
	result := []*NetworkEndpointGroup{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpointGroup is for package internal use only (not type-safe).
func toNetworkEndpointGroup(obj interface{}) (*NetworkEndpointGroup, error) {
	x := &NetworkEndpointGroup{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpointGroup convert to a composite type.
func AlphaToNetworkEndpointGroup(obj *computealpha.NetworkEndpointGroup) (*NetworkEndpointGroup, error) {
	x := &NetworkEndpointGroup{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpointGroup convert to a composite type.
func BetaToNetworkEndpointGroup(obj *computebeta.NetworkEndpointGroup) (*NetworkEndpointGroup, error) {
	x := &NetworkEndpointGroup{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpointGroup convert to a composite type.
func GAToNetworkEndpointGroup(obj *compute.NetworkEndpointGroup) (*NetworkEndpointGroup, error) {
	x := &NetworkEndpointGroup{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpointGroup *NetworkEndpointGroup) ToAlpha() (*computealpha.NetworkEndpointGroup, error) {
	alpha := &computealpha.NetworkEndpointGroup{}
	err := copyViaJSON(alpha, networkEndpointGroup)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpointGroup, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpointGroup *NetworkEndpointGroup) ToBeta() (*computebeta.NetworkEndpointGroup, error) {
	beta := &computebeta.NetworkEndpointGroup{}
	err := copyViaJSON(beta, networkEndpointGroup)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpointGroup, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpointGroup *NetworkEndpointGroup) ToGA() (*compute.NetworkEndpointGroup, error) {
	ga := &compute.NetworkEndpointGroup{}
	err := copyViaJSON(ga, networkEndpointGroup)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpointGroup, err)
	}

	return ga, nil
}

// toNetworkEndpointGroupsAttachEndpointsRequestList converts a list of compute alpha, beta or GA
// NetworkEndpointGroupsAttachEndpointsRequest into a list of our composite type.
func toNetworkEndpointGroupsAttachEndpointsRequestList(objs interface{}) ([]*NetworkEndpointGroupsAttachEndpointsRequest, error) {
	result := []*NetworkEndpointGroupsAttachEndpointsRequest{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpointGroupsAttachEndpointsRequest is for package internal use only (not type-safe).
func toNetworkEndpointGroupsAttachEndpointsRequest(obj interface{}) (*NetworkEndpointGroupsAttachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpointGroupsAttachEndpointsRequest convert to a composite type.
func AlphaToNetworkEndpointGroupsAttachEndpointsRequest(obj *computealpha.NetworkEndpointGroupsAttachEndpointsRequest) (*NetworkEndpointGroupsAttachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpointGroupsAttachEndpointsRequest convert to a composite type.
func BetaToNetworkEndpointGroupsAttachEndpointsRequest(obj *computebeta.NetworkEndpointGroupsAttachEndpointsRequest) (*NetworkEndpointGroupsAttachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpointGroupsAttachEndpointsRequest convert to a composite type.
func GAToNetworkEndpointGroupsAttachEndpointsRequest(obj *compute.NetworkEndpointGroupsAttachEndpointsRequest) (*NetworkEndpointGroupsAttachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpointGroupsAttachEndpointsRequest *NetworkEndpointGroupsAttachEndpointsRequest) ToAlpha() (*computealpha.NetworkEndpointGroupsAttachEndpointsRequest, error) {
	alpha := &computealpha.NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(alpha, networkEndpointGroupsAttachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpointGroupsAttachEndpointsRequest, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpointGroupsAttachEndpointsRequest *NetworkEndpointGroupsAttachEndpointsRequest) ToBeta() (*computebeta.NetworkEndpointGroupsAttachEndpointsRequest, error) {
	beta := &computebeta.NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(beta, networkEndpointGroupsAttachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpointGroupsAttachEndpointsRequest, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpointGroupsAttachEndpointsRequest *NetworkEndpointGroupsAttachEndpointsRequest) ToGA() (*compute.NetworkEndpointGroupsAttachEndpointsRequest, error) {
	ga := &compute.NetworkEndpointGroupsAttachEndpointsRequest{}
	err := copyViaJSON(ga, networkEndpointGroupsAttachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpointGroupsAttachEndpointsRequest, err)
	}

	return ga, nil
}

// toNetworkEndpointGroupsDetachEndpointsRequestList converts a list of compute alpha, beta or GA
// NetworkEndpointGroupsDetachEndpointsRequest into a list of our composite type.
func toNetworkEndpointGroupsDetachEndpointsRequestList(objs interface{}) ([]*NetworkEndpointGroupsDetachEndpointsRequest, error) {
	result := []*NetworkEndpointGroupsDetachEndpointsRequest{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpointGroupsDetachEndpointsRequest is for package internal use only (not type-safe).
func toNetworkEndpointGroupsDetachEndpointsRequest(obj interface{}) (*NetworkEndpointGroupsDetachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpointGroupsDetachEndpointsRequest convert to a composite type.
func AlphaToNetworkEndpointGroupsDetachEndpointsRequest(obj *computealpha.NetworkEndpointGroupsDetachEndpointsRequest) (*NetworkEndpointGroupsDetachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpointGroupsDetachEndpointsRequest convert to a composite type.
func BetaToNetworkEndpointGroupsDetachEndpointsRequest(obj *computebeta.NetworkEndpointGroupsDetachEndpointsRequest) (*NetworkEndpointGroupsDetachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpointGroupsDetachEndpointsRequest convert to a composite type.
func GAToNetworkEndpointGroupsDetachEndpointsRequest(obj *compute.NetworkEndpointGroupsDetachEndpointsRequest) (*NetworkEndpointGroupsDetachEndpointsRequest, error) {
	x := &NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpointGroupsDetachEndpointsRequest *NetworkEndpointGroupsDetachEndpointsRequest) ToAlpha() (*computealpha.NetworkEndpointGroupsDetachEndpointsRequest, error) {
	alpha := &computealpha.NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(alpha, networkEndpointGroupsDetachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpointGroupsDetachEndpointsRequest, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpointGroupsDetachEndpointsRequest *NetworkEndpointGroupsDetachEndpointsRequest) ToBeta() (*computebeta.NetworkEndpointGroupsDetachEndpointsRequest, error) {
	beta := &computebeta.NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(beta, networkEndpointGroupsDetachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpointGroupsDetachEndpointsRequest, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpointGroupsDetachEndpointsRequest *NetworkEndpointGroupsDetachEndpointsRequest) ToGA() (*compute.NetworkEndpointGroupsDetachEndpointsRequest, error) {
	ga := &compute.NetworkEndpointGroupsDetachEndpointsRequest{}
	err := copyViaJSON(ga, networkEndpointGroupsDetachEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpointGroupsDetachEndpointsRequest, err)
	}

	return ga, nil
}

// toNetworkEndpointGroupsListEndpointsRequestList converts a list of compute alpha, beta or GA
// NetworkEndpointGroupsListEndpointsRequest into a list of our composite type.
func toNetworkEndpointGroupsListEndpointsRequestList(objs interface{}) ([]*NetworkEndpointGroupsListEndpointsRequest, error) {
	result := []*NetworkEndpointGroupsListEndpointsRequest{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpointGroupsListEndpointsRequest is for package internal use only (not type-safe).
func toNetworkEndpointGroupsListEndpointsRequest(obj interface{}) (*NetworkEndpointGroupsListEndpointsRequest, error) {
	x := &NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpointGroupsListEndpointsRequest convert to a composite type.
func AlphaToNetworkEndpointGroupsListEndpointsRequest(obj *computealpha.NetworkEndpointGroupsListEndpointsRequest) (*NetworkEndpointGroupsListEndpointsRequest, error) {
	x := &NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpointGroupsListEndpointsRequest convert to a composite type.
func BetaToNetworkEndpointGroupsListEndpointsRequest(obj *computebeta.NetworkEndpointGroupsListEndpointsRequest) (*NetworkEndpointGroupsListEndpointsRequest, error) {
	x := &NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpointGroupsListEndpointsRequest convert to a composite type.
func GAToNetworkEndpointGroupsListEndpointsRequest(obj *compute.NetworkEndpointGroupsListEndpointsRequest) (*NetworkEndpointGroupsListEndpointsRequest, error) {
	x := &NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpointGroupsListEndpointsRequest *NetworkEndpointGroupsListEndpointsRequest) ToAlpha() (*computealpha.NetworkEndpointGroupsListEndpointsRequest, error) {
	alpha := &computealpha.NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(alpha, networkEndpointGroupsListEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpointGroupsListEndpointsRequest, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpointGroupsListEndpointsRequest *NetworkEndpointGroupsListEndpointsRequest) ToBeta() (*computebeta.NetworkEndpointGroupsListEndpointsRequest, error) {
	beta := &computebeta.NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(beta, networkEndpointGroupsListEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpointGroupsListEndpointsRequest, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpointGroupsListEndpointsRequest *NetworkEndpointGroupsListEndpointsRequest) ToGA() (*compute.NetworkEndpointGroupsListEndpointsRequest, error) {
	ga := &compute.NetworkEndpointGroupsListEndpointsRequest{}
	err := copyViaJSON(ga, networkEndpointGroupsListEndpointsRequest)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpointGroupsListEndpointsRequest, err)
	}

	return ga, nil
}

// toNetworkEndpointWithHealthStatusList converts a list of compute alpha, beta or GA
// NetworkEndpointWithHealthStatus into a list of our composite type.
func toNetworkEndpointWithHealthStatusList(objs interface{}) ([]*NetworkEndpointWithHealthStatus, error) {
	result := []*NetworkEndpointWithHealthStatus{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toNetworkEndpointWithHealthStatus is for package internal use only (not type-safe).
func toNetworkEndpointWithHealthStatus(obj interface{}) (*NetworkEndpointWithHealthStatus, error) {
	x := &NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToNetworkEndpointWithHealthStatus convert to a composite type.
func AlphaToNetworkEndpointWithHealthStatus(obj *computealpha.NetworkEndpointWithHealthStatus) (*NetworkEndpointWithHealthStatus, error) {
	x := &NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToNetworkEndpointWithHealthStatus convert to a composite type.
func BetaToNetworkEndpointWithHealthStatus(obj *computebeta.NetworkEndpointWithHealthStatus) (*NetworkEndpointWithHealthStatus, error) {
	x := &NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToNetworkEndpointWithHealthStatus convert to a composite type.
func GAToNetworkEndpointWithHealthStatus(obj *compute.NetworkEndpointWithHealthStatus) (*NetworkEndpointWithHealthStatus, error) {
	x := &NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (networkEndpointWithHealthStatus *NetworkEndpointWithHealthStatus) ToAlpha() (*computealpha.NetworkEndpointWithHealthStatus, error) {
	alpha := &computealpha.NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(alpha, networkEndpointWithHealthStatus)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", networkEndpointWithHealthStatus, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (networkEndpointWithHealthStatus *NetworkEndpointWithHealthStatus) ToBeta() (*computebeta.NetworkEndpointWithHealthStatus, error) {
	beta := &computebeta.NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(beta, networkEndpointWithHealthStatus)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", networkEndpointWithHealthStatus, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (networkEndpointWithHealthStatus *NetworkEndpointWithHealthStatus) ToGA() (*compute.NetworkEndpointWithHealthStatus, error) {
	ga := &compute.NetworkEndpointWithHealthStatus{}
	err := copyViaJSON(ga, networkEndpointWithHealthStatus)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", networkEndpointWithHealthStatus, err)
	}

	return ga, nil
}

func CreateSslCertificate(gceCloud *gce.Cloud, key *meta.Key, sslCertificate *SslCertificate) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("SslCertificate", "create", key.Region, key.Zone, string(sslCertificate.Version))

	switch sslCertificate.Version {
	case meta.VersionAlpha:
		alpha, err := sslCertificate.ToAlpha()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating alpha region SslCertificate %v", alpha.Name)
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionSslCertificates().Insert(ctx, key, alpha))
		default:
			klog.V(3).Infof("Creating alpha SslCertificate %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaSslCertificates().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := sslCertificate.ToBeta()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating beta region SslCertificate %v", beta.Name)
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionSslCertificates().Insert(ctx, key, beta))
		default:
			klog.V(3).Infof("Creating beta SslCertificate %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaSslCertificates().Insert(ctx, key, beta))
		}
	default:
		ga, err := sslCertificate.ToGA()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating ga region SslCertificate %v", ga.Name)
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionSslCertificates().Insert(ctx, key, ga))
		default:
			klog.V(3).Infof("Creating ga SslCertificate %v", ga.Name)
			return mc.Observe(gceCloud.Compute().SslCertificates().Insert(ctx, key, ga))
		}
	}
}

func DeleteSslCertificate(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("SslCertificate", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting alpha region SslCertificate %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaRegionSslCertificates().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting alpha SslCertificate %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaSslCertificates().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting beta region SslCertificate %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaRegionSslCertificates().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting beta SslCertificate %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaSslCertificates().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting ga region SslCertificate %v", key.Name)
			return mc.Observe(gceCloud.Compute().RegionSslCertificates().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting ga SslCertificate %v", key.Name)
			return mc.Observe(gceCloud.Compute().SslCertificates().Delete(ctx, key))
		}
	}
}

func GetSslCertificate(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) (*SslCertificate, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("SslCertificate", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting alpha region SslCertificate %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaRegionSslCertificates().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting alpha SslCertificate %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaSslCertificates().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting beta region SslCertificate %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaRegionSslCertificates().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting beta SslCertificate %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaSslCertificates().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting ga region SslCertificate %v", key.Name)
			gceObj, err = gceCloud.Compute().RegionSslCertificates().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting ga SslCertificate %v", key.Name)
			gceObj, err = gceCloud.Compute().SslCertificates().Get(ctx, key)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	compositeType, err := toSslCertificate(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListSslCertificates(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) ([]*SslCertificate, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("SslCertificate", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing alpha region SslCertificate")
			gceObjs, err = gceCloud.Compute().AlphaRegionSslCertificates().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing alpha SslCertificate")
			gceObjs, err = gceCloud.Compute().AlphaSslCertificates().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing beta region SslCertificate")
			gceObjs, err = gceCloud.Compute().BetaRegionSslCertificates().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing beta SslCertificate")
			gceObjs, err = gceCloud.Compute().BetaSslCertificates().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing ga region SslCertificate")
			gceObjs, err = gceCloud.Compute().RegionSslCertificates().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing ga SslCertificate")
			gceObjs, err = gceCloud.Compute().SslCertificates().List(ctx, filter.None)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}

	compositeObjs, err := toSslCertificateList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toSslCertificateList converts a list of compute alpha, beta or GA
// SslCertificate into a list of our composite type.
func toSslCertificateList(objs interface{}) ([]*SslCertificate, error) {
	result := []*SslCertificate{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toSslCertificate is for package internal use only (not type-safe).
func toSslCertificate(obj interface{}) (*SslCertificate, error) {
	x := &SslCertificate{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToSslCertificate convert to a composite type.
func AlphaToSslCertificate(obj *computealpha.SslCertificate) (*SslCertificate, error) {
	x := &SslCertificate{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToSslCertificate convert to a composite type.
func BetaToSslCertificate(obj *computebeta.SslCertificate) (*SslCertificate, error) {
	x := &SslCertificate{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToSslCertificate convert to a composite type.
func GAToSslCertificate(obj *compute.SslCertificate) (*SslCertificate, error) {
	x := &SslCertificate{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (sslCertificate *SslCertificate) ToAlpha() (*computealpha.SslCertificate, error) {
	alpha := &computealpha.SslCertificate{}
	err := copyViaJSON(alpha, sslCertificate)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", sslCertificate, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (sslCertificate *SslCertificate) ToBeta() (*computebeta.SslCertificate, error) {
	beta := &computebeta.SslCertificate{}
	err := copyViaJSON(beta, sslCertificate)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", sslCertificate, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (sslCertificate *SslCertificate) ToGA() (*compute.SslCertificate, error) {
	ga := &compute.SslCertificate{}
	err := copyViaJSON(ga, sslCertificate)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", sslCertificate, err)
	}

	return ga, nil
}

func CreateTargetHttpProxy(gceCloud *gce.Cloud, key *meta.Key, targetHttpProxy *TargetHttpProxy) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpProxy", "create", key.Region, key.Zone, string(targetHttpProxy.Version))

	switch targetHttpProxy.Version {
	case meta.VersionAlpha:
		alpha, err := targetHttpProxy.ToAlpha()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating alpha region TargetHttpProxy %v", alpha.Name)
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionTargetHttpProxies().Insert(ctx, key, alpha))
		default:
			klog.V(3).Infof("Creating alpha TargetHttpProxy %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaTargetHttpProxies().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := targetHttpProxy.ToBeta()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating beta region TargetHttpProxy %v", beta.Name)
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionTargetHttpProxies().Insert(ctx, key, beta))
		default:
			klog.V(3).Infof("Creating beta TargetHttpProxy %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaTargetHttpProxies().Insert(ctx, key, beta))
		}
	default:
		ga, err := targetHttpProxy.ToGA()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating ga region TargetHttpProxy %v", ga.Name)
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionTargetHttpProxies().Insert(ctx, key, ga))
		default:
			klog.V(3).Infof("Creating ga TargetHttpProxy %v", ga.Name)
			return mc.Observe(gceCloud.Compute().TargetHttpProxies().Insert(ctx, key, ga))
		}
	}
}

func DeleteTargetHttpProxy(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpProxy", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting alpha region TargetHttpProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaRegionTargetHttpProxies().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting alpha TargetHttpProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaTargetHttpProxies().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting beta region TargetHttpProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaRegionTargetHttpProxies().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting beta TargetHttpProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaTargetHttpProxies().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting ga region TargetHttpProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().RegionTargetHttpProxies().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting ga TargetHttpProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().TargetHttpProxies().Delete(ctx, key))
		}
	}
}

func GetTargetHttpProxy(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) (*TargetHttpProxy, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpProxy", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting alpha region TargetHttpProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaRegionTargetHttpProxies().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting alpha TargetHttpProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaTargetHttpProxies().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting beta region TargetHttpProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaRegionTargetHttpProxies().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting beta TargetHttpProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaTargetHttpProxies().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting ga region TargetHttpProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().RegionTargetHttpProxies().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting ga TargetHttpProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().TargetHttpProxies().Get(ctx, key)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	compositeType, err := toTargetHttpProxy(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListTargetHttpProxies(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) ([]*TargetHttpProxy, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpProxy", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing alpha region TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().AlphaRegionTargetHttpProxies().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing alpha TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().AlphaTargetHttpProxies().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing beta region TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().BetaRegionTargetHttpProxies().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing beta TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().BetaTargetHttpProxies().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing ga region TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().RegionTargetHttpProxies().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing ga TargetHttpProxy")
			gceObjs, err = gceCloud.Compute().TargetHttpProxies().List(ctx, filter.None)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}

	compositeObjs, err := toTargetHttpProxyList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toTargetHttpProxyList converts a list of compute alpha, beta or GA
// TargetHttpProxy into a list of our composite type.
func toTargetHttpProxyList(objs interface{}) ([]*TargetHttpProxy, error) {
	result := []*TargetHttpProxy{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toTargetHttpProxy is for package internal use only (not type-safe).
func toTargetHttpProxy(obj interface{}) (*TargetHttpProxy, error) {
	x := &TargetHttpProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToTargetHttpProxy convert to a composite type.
func AlphaToTargetHttpProxy(obj *computealpha.TargetHttpProxy) (*TargetHttpProxy, error) {
	x := &TargetHttpProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToTargetHttpProxy convert to a composite type.
func BetaToTargetHttpProxy(obj *computebeta.TargetHttpProxy) (*TargetHttpProxy, error) {
	x := &TargetHttpProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToTargetHttpProxy convert to a composite type.
func GAToTargetHttpProxy(obj *compute.TargetHttpProxy) (*TargetHttpProxy, error) {
	x := &TargetHttpProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) ToAlpha() (*computealpha.TargetHttpProxy, error) {
	alpha := &computealpha.TargetHttpProxy{}
	err := copyViaJSON(alpha, targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", targetHttpProxy, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) ToBeta() (*computebeta.TargetHttpProxy, error) {
	beta := &computebeta.TargetHttpProxy{}
	err := copyViaJSON(beta, targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", targetHttpProxy, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) ToGA() (*compute.TargetHttpProxy, error) {
	ga := &compute.TargetHttpProxy{}
	err := copyViaJSON(ga, targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", targetHttpProxy, err)
	}

	return ga, nil
}

func CreateTargetHttpsProxy(gceCloud *gce.Cloud, key *meta.Key, targetHttpsProxy *TargetHttpsProxy) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpsProxy", "create", key.Region, key.Zone, string(targetHttpsProxy.Version))

	switch targetHttpsProxy.Version {
	case meta.VersionAlpha:
		alpha, err := targetHttpsProxy.ToAlpha()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating alpha region TargetHttpsProxy %v", alpha.Name)
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionTargetHttpsProxies().Insert(ctx, key, alpha))
		default:
			klog.V(3).Infof("Creating alpha TargetHttpsProxy %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaTargetHttpsProxies().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := targetHttpsProxy.ToBeta()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating beta region TargetHttpsProxy %v", beta.Name)
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionTargetHttpsProxies().Insert(ctx, key, beta))
		default:
			klog.V(3).Infof("Creating beta TargetHttpsProxy %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaTargetHttpsProxies().Insert(ctx, key, beta))
		}
	default:
		ga, err := targetHttpsProxy.ToGA()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating ga region TargetHttpsProxy %v", ga.Name)
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionTargetHttpsProxies().Insert(ctx, key, ga))
		default:
			klog.V(3).Infof("Creating ga TargetHttpsProxy %v", ga.Name)
			return mc.Observe(gceCloud.Compute().TargetHttpsProxies().Insert(ctx, key, ga))
		}
	}
}

func DeleteTargetHttpsProxy(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpsProxy", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting alpha region TargetHttpsProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaRegionTargetHttpsProxies().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting alpha TargetHttpsProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaTargetHttpsProxies().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting beta region TargetHttpsProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaRegionTargetHttpsProxies().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting beta TargetHttpsProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaTargetHttpsProxies().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting ga region TargetHttpsProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().RegionTargetHttpsProxies().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting ga TargetHttpsProxy %v", key.Name)
			return mc.Observe(gceCloud.Compute().TargetHttpsProxies().Delete(ctx, key))
		}
	}
}

func GetTargetHttpsProxy(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) (*TargetHttpsProxy, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpsProxy", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting alpha region TargetHttpsProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaRegionTargetHttpsProxies().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting alpha TargetHttpsProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaTargetHttpsProxies().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting beta region TargetHttpsProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaRegionTargetHttpsProxies().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting beta TargetHttpsProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaTargetHttpsProxies().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting ga region TargetHttpsProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().RegionTargetHttpsProxies().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting ga TargetHttpsProxy %v", key.Name)
			gceObj, err = gceCloud.Compute().TargetHttpsProxies().Get(ctx, key)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	compositeType, err := toTargetHttpsProxy(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListTargetHttpsProxies(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) ([]*TargetHttpsProxy, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpsProxy", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing alpha region TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().AlphaRegionTargetHttpsProxies().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing alpha TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().AlphaTargetHttpsProxies().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing beta region TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().BetaRegionTargetHttpsProxies().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing beta TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().BetaTargetHttpsProxies().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing ga region TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().RegionTargetHttpsProxies().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing ga TargetHttpsProxy")
			gceObjs, err = gceCloud.Compute().TargetHttpsProxies().List(ctx, filter.None)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}

	compositeObjs, err := toTargetHttpsProxyList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toTargetHttpsProxyList converts a list of compute alpha, beta or GA
// TargetHttpsProxy into a list of our composite type.
func toTargetHttpsProxyList(objs interface{}) ([]*TargetHttpsProxy, error) {
	result := []*TargetHttpsProxy{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toTargetHttpsProxy is for package internal use only (not type-safe).
func toTargetHttpsProxy(obj interface{}) (*TargetHttpsProxy, error) {
	x := &TargetHttpsProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToTargetHttpsProxy convert to a composite type.
func AlphaToTargetHttpsProxy(obj *computealpha.TargetHttpsProxy) (*TargetHttpsProxy, error) {
	x := &TargetHttpsProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToTargetHttpsProxy convert to a composite type.
func BetaToTargetHttpsProxy(obj *computebeta.TargetHttpsProxy) (*TargetHttpsProxy, error) {
	x := &TargetHttpsProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToTargetHttpsProxy convert to a composite type.
func GAToTargetHttpsProxy(obj *compute.TargetHttpsProxy) (*TargetHttpsProxy, error) {
	x := &TargetHttpsProxy{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) ToAlpha() (*computealpha.TargetHttpsProxy, error) {
	alpha := &computealpha.TargetHttpsProxy{}
	err := copyViaJSON(alpha, targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", targetHttpsProxy, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) ToBeta() (*computebeta.TargetHttpsProxy, error) {
	beta := &computebeta.TargetHttpsProxy{}
	err := copyViaJSON(beta, targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", targetHttpsProxy, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) ToGA() (*compute.TargetHttpsProxy, error) {
	ga := &compute.TargetHttpsProxy{}
	err := copyViaJSON(ga, targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", targetHttpsProxy, err)
	}

	return ga, nil
}

func CreateUrlMap(gceCloud *gce.Cloud, key *meta.Key, urlMap *UrlMap) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "create", key.Region, key.Zone, string(urlMap.Version))

	switch urlMap.Version {
	case meta.VersionAlpha:
		alpha, err := urlMap.ToAlpha()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating alpha region UrlMap %v", alpha.Name)
			alpha.Region = key.Region
			return mc.Observe(gceCloud.Compute().AlphaRegionUrlMaps().Insert(ctx, key, alpha))
		default:
			klog.V(3).Infof("Creating alpha UrlMap %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaUrlMaps().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := urlMap.ToBeta()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating beta region UrlMap %v", beta.Name)
			beta.Region = key.Region
			return mc.Observe(gceCloud.Compute().BetaRegionUrlMaps().Insert(ctx, key, beta))
		default:
			klog.V(3).Infof("Creating beta UrlMap %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaUrlMaps().Insert(ctx, key, beta))
		}
	default:
		ga, err := urlMap.ToGA()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Creating ga region UrlMap %v", ga.Name)
			ga.Region = key.Region
			return mc.Observe(gceCloud.Compute().RegionUrlMaps().Insert(ctx, key, ga))
		default:
			klog.V(3).Infof("Creating ga UrlMap %v", ga.Name)
			return mc.Observe(gceCloud.Compute().UrlMaps().Insert(ctx, key, ga))
		}
	}
}

func UpdateUrlMap(gceCloud *gce.Cloud, key *meta.Key, urlMap *UrlMap) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "update", key.Region, key.Zone, string(urlMap.Version))
	switch urlMap.Version {
	case meta.VersionAlpha:
		alpha, err := urlMap.ToAlpha()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Updating alpha region UrlMap %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaRegionUrlMaps().Update(ctx, key, alpha))
		default:
			klog.V(3).Infof("Updating alpha UrlMap %v", alpha.Name)
			return mc.Observe(gceCloud.Compute().AlphaUrlMaps().Update(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := urlMap.ToBeta()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Updating beta region UrlMap %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaRegionUrlMaps().Update(ctx, key, beta))
		default:
			klog.V(3).Infof("Updating beta UrlMap %v", beta.Name)
			return mc.Observe(gceCloud.Compute().BetaUrlMaps().Update(ctx, key, beta))
		}
	default:
		ga, err := urlMap.ToGA()
		if err != nil {
			return err
		}
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Updating ga region UrlMap %v", ga.Name)
			return mc.Observe(gceCloud.Compute().RegionUrlMaps().Update(ctx, key, ga))
		default:
			klog.V(3).Infof("Updating ga UrlMap %v", ga.Name)
			return mc.Observe(gceCloud.Compute().UrlMaps().Update(ctx, key, ga))
		}
	}
}

func DeleteUrlMap(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) error {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "delete", key.Region, key.Zone, string(version))

	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting alpha region UrlMap %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaRegionUrlMaps().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting alpha UrlMap %v", key.Name)
			return mc.Observe(gceCloud.Compute().AlphaUrlMaps().Delete(ctx, key))
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting beta region UrlMap %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaRegionUrlMaps().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting beta UrlMap %v", key.Name)
			return mc.Observe(gceCloud.Compute().BetaUrlMaps().Delete(ctx, key))
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Deleting ga region UrlMap %v", key.Name)
			return mc.Observe(gceCloud.Compute().RegionUrlMaps().Delete(ctx, key))
		default:
			klog.V(3).Infof("Deleting ga UrlMap %v", key.Name)
			return mc.Observe(gceCloud.Compute().UrlMaps().Delete(ctx, key))
		}
	}
}

func GetUrlMap(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) (*UrlMap, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting alpha region UrlMap %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaRegionUrlMaps().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting alpha UrlMap %v", key.Name)
			gceObj, err = gceCloud.Compute().AlphaUrlMaps().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting beta region UrlMap %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaRegionUrlMaps().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting beta UrlMap %v", key.Name)
			gceObj, err = gceCloud.Compute().BetaUrlMaps().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Getting ga region UrlMap %v", key.Name)
			gceObj, err = gceCloud.Compute().RegionUrlMaps().Get(ctx, key)
		default:
			klog.V(3).Infof("Getting ga UrlMap %v", key.Name)
			gceObj, err = gceCloud.Compute().UrlMaps().Get(ctx, key)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	compositeType, err := toUrlMap(gceObj)
	if err != nil {
		return nil, err
	}
	compositeType.Version = version
	return compositeType, nil
}

func ListUrlMaps(gceCloud *gce.Cloud, key *meta.Key, version meta.Version) ([]*UrlMap, error) {
	ctx, cancel := cloudprovider.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "list", key.Region, key.Zone, string(version))

	var gceObjs interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing alpha region UrlMap")
			gceObjs, err = gceCloud.Compute().AlphaRegionUrlMaps().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing alpha UrlMap")
			gceObjs, err = gceCloud.Compute().AlphaUrlMaps().List(ctx, filter.None)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing beta region UrlMap")
			gceObjs, err = gceCloud.Compute().BetaRegionUrlMaps().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing beta UrlMap")
			gceObjs, err = gceCloud.Compute().BetaUrlMaps().List(ctx, filter.None)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			klog.V(3).Infof("Listing ga region UrlMap")
			gceObjs, err = gceCloud.Compute().RegionUrlMaps().List(ctx, key.Region, filter.None)
		default:
			klog.V(3).Infof("Listing ga UrlMap")
			gceObjs, err = gceCloud.Compute().UrlMaps().List(ctx, filter.None)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}

	compositeObjs, err := toUrlMapList(gceObjs)
	if err != nil {
		return nil, err
	}
	for _, obj := range compositeObjs {
		obj.Version = version
	}
	return compositeObjs, nil
}

// toUrlMapList converts a list of compute alpha, beta or GA
// UrlMap into a list of our composite type.
func toUrlMapList(objs interface{}) ([]*UrlMap, error) {
	result := []*UrlMap{}

	err := copyViaJSON(&result, objs)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %v to %T via JSON: %v", objs, result, err)
	}
	return result, nil
}

// toUrlMap is for package internal use only (not type-safe).
func toUrlMap(obj interface{}) (*UrlMap, error) {
	x := &UrlMap{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// Users external to the package need to pass in the correct type to create a
// composite.

// AlphaToUrlMap convert to a composite type.
func AlphaToUrlMap(obj *computealpha.UrlMap) (*UrlMap, error) {
	x := &UrlMap{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// BetaToUrlMap convert to a composite type.
func BetaToUrlMap(obj *computebeta.UrlMap) (*UrlMap, error) {
	x := &UrlMap{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// GAToUrlMap convert to a composite type.
func GAToUrlMap(obj *compute.UrlMap) (*UrlMap, error) {
	x := &UrlMap{}
	err := copyViaJSON(x, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to %T via JSON: %v", obj, x, err)
	}
	return x, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (urlMap *UrlMap) ToAlpha() (*computealpha.UrlMap, error) {
	alpha := &computealpha.UrlMap{}
	err := copyViaJSON(alpha, urlMap)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute alpha type via JSON: %v", urlMap, err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (urlMap *UrlMap) ToBeta() (*computebeta.UrlMap, error) {
	beta := &computebeta.UrlMap{}
	err := copyViaJSON(beta, urlMap)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute beta type via JSON: %v", urlMap, err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (urlMap *UrlMap) ToGA() (*compute.UrlMap, error) {
	ga := &compute.UrlMap{}
	err := copyViaJSON(ga, urlMap)
	if err != nil {
		return nil, fmt.Errorf("error converting %T to compute ga type via JSON: %v", urlMap, err)
	}

	return ga, nil
}
