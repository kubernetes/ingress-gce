/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// This file was generated by "./hack/update-codegen.sh". Do not edit directly.
// directly.

package composite

import (
	"fmt"
	"reflect"
	"testing"

	"github.com/kr/pretty"
	computealpha "google.golang.org/api/compute/v0.alpha"
	computebeta "google.golang.org/api/compute/v0.beta"
	compute "google.golang.org/api/compute/v1"
)

func TestAddress(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(Address{})
	alphaType := reflect.TypeOf(computealpha.Address{})
	betaType := reflect.TypeOf(computebeta.Address{})
	gaType := reflect.TypeOf(compute.Address{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToAddress(t *testing.T)

func TestAddressToAlpha(t *testing.T) {
	composite := Address{}
	expected := &computealpha.Address{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("Address.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("Address.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestAddressToBeta(t *testing.T) {
	composite := Address{}
	expected := &computebeta.Address{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("Address.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("Address.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestAddressToGA(t *testing.T) {
	composite := Address{}
	expected := &compute.Address{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("Address.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("Address.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}

func TestAuthenticationPolicy(t *testing.T) {
	compositeType := reflect.TypeOf(AuthenticationPolicy{})
	alphaType := reflect.TypeOf(computealpha.AuthenticationPolicy{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestAuthorizationConfig(t *testing.T) {
	compositeType := reflect.TypeOf(AuthorizationConfig{})
	alphaType := reflect.TypeOf(computealpha.AuthorizationConfig{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestBackend(t *testing.T) {
	compositeType := reflect.TypeOf(Backend{})
	alphaType := reflect.TypeOf(computealpha.Backend{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}
func TestBackendService(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(BackendService{})
	alphaType := reflect.TypeOf(computealpha.BackendService{})
	betaType := reflect.TypeOf(computebeta.BackendService{})
	gaType := reflect.TypeOf(compute.BackendService{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToBackendService(t *testing.T)

func TestBackendServiceToAlpha(t *testing.T) {
	composite := BackendService{}
	expected := &computealpha.BackendService{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("BackendService.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("BackendService.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestBackendServiceToBeta(t *testing.T) {
	composite := BackendService{}
	expected := &computebeta.BackendService{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("BackendService.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("BackendService.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestBackendServiceToGA(t *testing.T) {
	composite := BackendService{}
	expected := &compute.BackendService{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("BackendService.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("BackendService.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}

func TestBackendServiceCdnPolicy(t *testing.T) {
	compositeType := reflect.TypeOf(BackendServiceCdnPolicy{})
	alphaType := reflect.TypeOf(computealpha.BackendServiceCdnPolicy{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestBackendServiceCdnPolicyBypassCacheOnRequestHeader(t *testing.T) {
	compositeType := reflect.TypeOf(BackendServiceCdnPolicyBypassCacheOnRequestHeader{})
	alphaType := reflect.TypeOf(computealpha.BackendServiceCdnPolicyBypassCacheOnRequestHeader{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestBackendServiceCdnPolicyNegativeCachingPolicy(t *testing.T) {
	compositeType := reflect.TypeOf(BackendServiceCdnPolicyNegativeCachingPolicy{})
	alphaType := reflect.TypeOf(computealpha.BackendServiceCdnPolicyNegativeCachingPolicy{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestBackendServiceConnectionTrackingPolicy(t *testing.T) {
	compositeType := reflect.TypeOf(BackendServiceConnectionTrackingPolicy{})
	alphaType := reflect.TypeOf(computealpha.BackendServiceConnectionTrackingPolicy{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestBackendServiceFailoverPolicy(t *testing.T) {
	compositeType := reflect.TypeOf(BackendServiceFailoverPolicy{})
	alphaType := reflect.TypeOf(computealpha.BackendServiceFailoverPolicy{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestBackendServiceIAP(t *testing.T) {
	compositeType := reflect.TypeOf(BackendServiceIAP{})
	alphaType := reflect.TypeOf(computealpha.BackendServiceIAP{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestBackendServiceIAPOAuth2ClientInfo(t *testing.T) {
	compositeType := reflect.TypeOf(BackendServiceIAPOAuth2ClientInfo{})
	alphaType := reflect.TypeOf(computealpha.BackendServiceIAPOAuth2ClientInfo{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestBackendServiceLogConfig(t *testing.T) {
	compositeType := reflect.TypeOf(BackendServiceLogConfig{})
	alphaType := reflect.TypeOf(computealpha.BackendServiceLogConfig{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestBackendServiceReference(t *testing.T) {
	compositeType := reflect.TypeOf(BackendServiceReference{})
	alphaType := reflect.TypeOf(computealpha.BackendServiceReference{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestCacheKeyPolicy(t *testing.T) {
	compositeType := reflect.TypeOf(CacheKeyPolicy{})
	alphaType := reflect.TypeOf(computealpha.CacheKeyPolicy{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestCallCredentials(t *testing.T) {
	compositeType := reflect.TypeOf(CallCredentials{})
	alphaType := reflect.TypeOf(computealpha.CallCredentials{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestChannelCredentials(t *testing.T) {
	compositeType := reflect.TypeOf(ChannelCredentials{})
	alphaType := reflect.TypeOf(computealpha.ChannelCredentials{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestCircuitBreakers(t *testing.T) {
	compositeType := reflect.TypeOf(CircuitBreakers{})
	alphaType := reflect.TypeOf(computealpha.CircuitBreakers{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestClientTlsSettings(t *testing.T) {
	compositeType := reflect.TypeOf(ClientTlsSettings{})
	alphaType := reflect.TypeOf(computealpha.ClientTlsSettings{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestConnectionDraining(t *testing.T) {
	compositeType := reflect.TypeOf(ConnectionDraining{})
	alphaType := reflect.TypeOf(computealpha.ConnectionDraining{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestConsistentHashLoadBalancerSettings(t *testing.T) {
	compositeType := reflect.TypeOf(ConsistentHashLoadBalancerSettings{})
	alphaType := reflect.TypeOf(computealpha.ConsistentHashLoadBalancerSettings{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestConsistentHashLoadBalancerSettingsHttpCookie(t *testing.T) {
	compositeType := reflect.TypeOf(ConsistentHashLoadBalancerSettingsHttpCookie{})
	alphaType := reflect.TypeOf(computealpha.ConsistentHashLoadBalancerSettingsHttpCookie{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestCorsPolicy(t *testing.T) {
	compositeType := reflect.TypeOf(CorsPolicy{})
	alphaType := reflect.TypeOf(computealpha.CorsPolicy{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestDuration(t *testing.T) {
	compositeType := reflect.TypeOf(Duration{})
	alphaType := reflect.TypeOf(computealpha.Duration{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}
func TestForwardingRule(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(ForwardingRule{})
	alphaType := reflect.TypeOf(computealpha.ForwardingRule{})
	betaType := reflect.TypeOf(computebeta.ForwardingRule{})
	gaType := reflect.TypeOf(compute.ForwardingRule{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToForwardingRule(t *testing.T)

func TestForwardingRuleToAlpha(t *testing.T) {
	composite := ForwardingRule{}
	expected := &computealpha.ForwardingRule{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("ForwardingRule.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("ForwardingRule.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestForwardingRuleToBeta(t *testing.T) {
	composite := ForwardingRule{}
	expected := &computebeta.ForwardingRule{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("ForwardingRule.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("ForwardingRule.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestForwardingRuleToGA(t *testing.T) {
	composite := ForwardingRule{}
	expected := &compute.ForwardingRule{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("ForwardingRule.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("ForwardingRule.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}

func TestForwardingRuleReference(t *testing.T) {
	compositeType := reflect.TypeOf(ForwardingRuleReference{})
	alphaType := reflect.TypeOf(computealpha.ForwardingRuleReference{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestForwardingRuleServiceDirectoryRegistration(t *testing.T) {
	compositeType := reflect.TypeOf(ForwardingRuleServiceDirectoryRegistration{})
	alphaType := reflect.TypeOf(computealpha.ForwardingRuleServiceDirectoryRegistration{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestGRPCHealthCheck(t *testing.T) {
	compositeType := reflect.TypeOf(GRPCHealthCheck{})
	alphaType := reflect.TypeOf(computealpha.GRPCHealthCheck{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestGrpcServiceConfig(t *testing.T) {
	compositeType := reflect.TypeOf(GrpcServiceConfig{})
	alphaType := reflect.TypeOf(computealpha.GrpcServiceConfig{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHTTP2HealthCheck(t *testing.T) {
	compositeType := reflect.TypeOf(HTTP2HealthCheck{})
	alphaType := reflect.TypeOf(computealpha.HTTP2HealthCheck{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHTTPHealthCheck(t *testing.T) {
	compositeType := reflect.TypeOf(HTTPHealthCheck{})
	alphaType := reflect.TypeOf(computealpha.HTTPHealthCheck{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHTTPSHealthCheck(t *testing.T) {
	compositeType := reflect.TypeOf(HTTPSHealthCheck{})
	alphaType := reflect.TypeOf(computealpha.HTTPSHealthCheck{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}
func TestHealthCheck(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(HealthCheck{})
	alphaType := reflect.TypeOf(computealpha.HealthCheck{})
	betaType := reflect.TypeOf(computebeta.HealthCheck{})
	gaType := reflect.TypeOf(compute.HealthCheck{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToHealthCheck(t *testing.T)

func TestHealthCheckToAlpha(t *testing.T) {
	composite := HealthCheck{}
	expected := &computealpha.HealthCheck{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("HealthCheck.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("HealthCheck.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestHealthCheckToBeta(t *testing.T) {
	composite := HealthCheck{}
	expected := &computebeta.HealthCheck{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("HealthCheck.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("HealthCheck.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestHealthCheckToGA(t *testing.T) {
	composite := HealthCheck{}
	expected := &compute.HealthCheck{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("HealthCheck.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("HealthCheck.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}

func TestHealthCheckLogConfig(t *testing.T) {
	compositeType := reflect.TypeOf(HealthCheckLogConfig{})
	alphaType := reflect.TypeOf(computealpha.HealthCheckLogConfig{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHealthCheckReference(t *testing.T) {
	compositeType := reflect.TypeOf(HealthCheckReference{})
	alphaType := reflect.TypeOf(computealpha.HealthCheckReference{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHealthCheckServiceReference(t *testing.T) {
	compositeType := reflect.TypeOf(HealthCheckServiceReference{})
	alphaType := reflect.TypeOf(computealpha.HealthCheckServiceReference{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}
func TestHealthStatusForNetworkEndpoint(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(HealthStatusForNetworkEndpoint{})
	alphaType := reflect.TypeOf(computealpha.HealthStatusForNetworkEndpoint{})
	betaType := reflect.TypeOf(computebeta.HealthStatusForNetworkEndpoint{})
	gaType := reflect.TypeOf(compute.HealthStatusForNetworkEndpoint{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToHealthStatusForNetworkEndpoint(t *testing.T)

func TestHealthStatusForNetworkEndpointToAlpha(t *testing.T) {
	composite := HealthStatusForNetworkEndpoint{}
	expected := &computealpha.HealthStatusForNetworkEndpoint{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("HealthStatusForNetworkEndpoint.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("HealthStatusForNetworkEndpoint.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestHealthStatusForNetworkEndpointToBeta(t *testing.T) {
	composite := HealthStatusForNetworkEndpoint{}
	expected := &computebeta.HealthStatusForNetworkEndpoint{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("HealthStatusForNetworkEndpoint.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("HealthStatusForNetworkEndpoint.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestHealthStatusForNetworkEndpointToGA(t *testing.T) {
	composite := HealthStatusForNetworkEndpoint{}
	expected := &compute.HealthStatusForNetworkEndpoint{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("HealthStatusForNetworkEndpoint.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("HealthStatusForNetworkEndpoint.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}

func TestHostRule(t *testing.T) {
	compositeType := reflect.TypeOf(HostRule{})
	alphaType := reflect.TypeOf(computealpha.HostRule{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpFaultAbort(t *testing.T) {
	compositeType := reflect.TypeOf(HttpFaultAbort{})
	alphaType := reflect.TypeOf(computealpha.HttpFaultAbort{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpFaultDelay(t *testing.T) {
	compositeType := reflect.TypeOf(HttpFaultDelay{})
	alphaType := reflect.TypeOf(computealpha.HttpFaultDelay{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpFaultInjection(t *testing.T) {
	compositeType := reflect.TypeOf(HttpFaultInjection{})
	alphaType := reflect.TypeOf(computealpha.HttpFaultInjection{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpFilterConfig(t *testing.T) {
	compositeType := reflect.TypeOf(HttpFilterConfig{})
	alphaType := reflect.TypeOf(computealpha.HttpFilterConfig{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpHeaderAction(t *testing.T) {
	compositeType := reflect.TypeOf(HttpHeaderAction{})
	alphaType := reflect.TypeOf(computealpha.HttpHeaderAction{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpHeaderMatch(t *testing.T) {
	compositeType := reflect.TypeOf(HttpHeaderMatch{})
	alphaType := reflect.TypeOf(computealpha.HttpHeaderMatch{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpHeaderOption(t *testing.T) {
	compositeType := reflect.TypeOf(HttpHeaderOption{})
	alphaType := reflect.TypeOf(computealpha.HttpHeaderOption{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpQueryParameterMatch(t *testing.T) {
	compositeType := reflect.TypeOf(HttpQueryParameterMatch{})
	alphaType := reflect.TypeOf(computealpha.HttpQueryParameterMatch{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpRedirectAction(t *testing.T) {
	compositeType := reflect.TypeOf(HttpRedirectAction{})
	alphaType := reflect.TypeOf(computealpha.HttpRedirectAction{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpRetryPolicy(t *testing.T) {
	compositeType := reflect.TypeOf(HttpRetryPolicy{})
	alphaType := reflect.TypeOf(computealpha.HttpRetryPolicy{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpRouteAction(t *testing.T) {
	compositeType := reflect.TypeOf(HttpRouteAction{})
	alphaType := reflect.TypeOf(computealpha.HttpRouteAction{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpRouteRule(t *testing.T) {
	compositeType := reflect.TypeOf(HttpRouteRule{})
	alphaType := reflect.TypeOf(computealpha.HttpRouteRule{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestHttpRouteRuleMatch(t *testing.T) {
	compositeType := reflect.TypeOf(HttpRouteRuleMatch{})
	alphaType := reflect.TypeOf(computealpha.HttpRouteRuleMatch{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestInt64RangeMatch(t *testing.T) {
	compositeType := reflect.TypeOf(Int64RangeMatch{})
	alphaType := reflect.TypeOf(computealpha.Int64RangeMatch{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestJwt(t *testing.T) {
	compositeType := reflect.TypeOf(Jwt{})
	alphaType := reflect.TypeOf(computealpha.Jwt{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestJwtHeader(t *testing.T) {
	compositeType := reflect.TypeOf(JwtHeader{})
	alphaType := reflect.TypeOf(computealpha.JwtHeader{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestMetadataCredentialsFromPlugin(t *testing.T) {
	compositeType := reflect.TypeOf(MetadataCredentialsFromPlugin{})
	alphaType := reflect.TypeOf(computealpha.MetadataCredentialsFromPlugin{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestMetadataFilter(t *testing.T) {
	compositeType := reflect.TypeOf(MetadataFilter{})
	alphaType := reflect.TypeOf(computealpha.MetadataFilter{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestMetadataFilterLabelMatch(t *testing.T) {
	compositeType := reflect.TypeOf(MetadataFilterLabelMatch{})
	alphaType := reflect.TypeOf(computealpha.MetadataFilterLabelMatch{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestMutualTls(t *testing.T) {
	compositeType := reflect.TypeOf(MutualTls{})
	alphaType := reflect.TypeOf(computealpha.MutualTls{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}
func TestNetworkEndpoint(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(NetworkEndpoint{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpoint{})
	betaType := reflect.TypeOf(computebeta.NetworkEndpoint{})
	gaType := reflect.TypeOf(compute.NetworkEndpoint{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToNetworkEndpoint(t *testing.T)

func TestNetworkEndpointToAlpha(t *testing.T) {
	composite := NetworkEndpoint{}
	expected := &computealpha.NetworkEndpoint{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("NetworkEndpoint.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpoint.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointToBeta(t *testing.T) {
	composite := NetworkEndpoint{}
	expected := &computebeta.NetworkEndpoint{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("NetworkEndpoint.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpoint.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointToGA(t *testing.T) {
	composite := NetworkEndpoint{}
	expected := &compute.NetworkEndpoint{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("NetworkEndpoint.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpoint.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointGroup(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(NetworkEndpointGroup{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpointGroup{})
	betaType := reflect.TypeOf(computebeta.NetworkEndpointGroup{})
	gaType := reflect.TypeOf(compute.NetworkEndpointGroup{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToNetworkEndpointGroup(t *testing.T)

func TestNetworkEndpointGroupToAlpha(t *testing.T) {
	composite := NetworkEndpointGroup{}
	expected := &computealpha.NetworkEndpointGroup{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("NetworkEndpointGroup.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroup.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointGroupToBeta(t *testing.T) {
	composite := NetworkEndpointGroup{}
	expected := &computebeta.NetworkEndpointGroup{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("NetworkEndpointGroup.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroup.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointGroupToGA(t *testing.T) {
	composite := NetworkEndpointGroup{}
	expected := &compute.NetworkEndpointGroup{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("NetworkEndpointGroup.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroup.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}

func TestNetworkEndpointGroupAppEngine(t *testing.T) {
	compositeType := reflect.TypeOf(NetworkEndpointGroupAppEngine{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpointGroupAppEngine{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestNetworkEndpointGroupCloudFunction(t *testing.T) {
	compositeType := reflect.TypeOf(NetworkEndpointGroupCloudFunction{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpointGroupCloudFunction{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestNetworkEndpointGroupCloudRun(t *testing.T) {
	compositeType := reflect.TypeOf(NetworkEndpointGroupCloudRun{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpointGroupCloudRun{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestNetworkEndpointGroupLbNetworkEndpointGroup(t *testing.T) {
	compositeType := reflect.TypeOf(NetworkEndpointGroupLbNetworkEndpointGroup{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpointGroupLbNetworkEndpointGroup{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestNetworkEndpointGroupServerlessDeployment(t *testing.T) {
	compositeType := reflect.TypeOf(NetworkEndpointGroupServerlessDeployment{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpointGroupServerlessDeployment{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}
func TestNetworkEndpointGroupsAttachEndpointsRequest(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(NetworkEndpointGroupsAttachEndpointsRequest{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpointGroupsAttachEndpointsRequest{})
	betaType := reflect.TypeOf(computebeta.NetworkEndpointGroupsAttachEndpointsRequest{})
	gaType := reflect.TypeOf(compute.NetworkEndpointGroupsAttachEndpointsRequest{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToNetworkEndpointGroupsAttachEndpointsRequest(t *testing.T)

func TestNetworkEndpointGroupsAttachEndpointsRequestToAlpha(t *testing.T) {
	composite := NetworkEndpointGroupsAttachEndpointsRequest{}
	expected := &computealpha.NetworkEndpointGroupsAttachEndpointsRequest{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("NetworkEndpointGroupsAttachEndpointsRequest.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroupsAttachEndpointsRequest.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointGroupsAttachEndpointsRequestToBeta(t *testing.T) {
	composite := NetworkEndpointGroupsAttachEndpointsRequest{}
	expected := &computebeta.NetworkEndpointGroupsAttachEndpointsRequest{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("NetworkEndpointGroupsAttachEndpointsRequest.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroupsAttachEndpointsRequest.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointGroupsAttachEndpointsRequestToGA(t *testing.T) {
	composite := NetworkEndpointGroupsAttachEndpointsRequest{}
	expected := &compute.NetworkEndpointGroupsAttachEndpointsRequest{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("NetworkEndpointGroupsAttachEndpointsRequest.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroupsAttachEndpointsRequest.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointGroupsDetachEndpointsRequest(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(NetworkEndpointGroupsDetachEndpointsRequest{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpointGroupsDetachEndpointsRequest{})
	betaType := reflect.TypeOf(computebeta.NetworkEndpointGroupsDetachEndpointsRequest{})
	gaType := reflect.TypeOf(compute.NetworkEndpointGroupsDetachEndpointsRequest{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToNetworkEndpointGroupsDetachEndpointsRequest(t *testing.T)

func TestNetworkEndpointGroupsDetachEndpointsRequestToAlpha(t *testing.T) {
	composite := NetworkEndpointGroupsDetachEndpointsRequest{}
	expected := &computealpha.NetworkEndpointGroupsDetachEndpointsRequest{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("NetworkEndpointGroupsDetachEndpointsRequest.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroupsDetachEndpointsRequest.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointGroupsDetachEndpointsRequestToBeta(t *testing.T) {
	composite := NetworkEndpointGroupsDetachEndpointsRequest{}
	expected := &computebeta.NetworkEndpointGroupsDetachEndpointsRequest{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("NetworkEndpointGroupsDetachEndpointsRequest.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroupsDetachEndpointsRequest.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointGroupsDetachEndpointsRequestToGA(t *testing.T) {
	composite := NetworkEndpointGroupsDetachEndpointsRequest{}
	expected := &compute.NetworkEndpointGroupsDetachEndpointsRequest{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("NetworkEndpointGroupsDetachEndpointsRequest.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroupsDetachEndpointsRequest.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointGroupsListEndpointsRequest(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(NetworkEndpointGroupsListEndpointsRequest{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpointGroupsListEndpointsRequest{})
	betaType := reflect.TypeOf(computebeta.NetworkEndpointGroupsListEndpointsRequest{})
	gaType := reflect.TypeOf(compute.NetworkEndpointGroupsListEndpointsRequest{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToNetworkEndpointGroupsListEndpointsRequest(t *testing.T)

func TestNetworkEndpointGroupsListEndpointsRequestToAlpha(t *testing.T) {
	composite := NetworkEndpointGroupsListEndpointsRequest{}
	expected := &computealpha.NetworkEndpointGroupsListEndpointsRequest{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("NetworkEndpointGroupsListEndpointsRequest.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroupsListEndpointsRequest.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointGroupsListEndpointsRequestToBeta(t *testing.T) {
	composite := NetworkEndpointGroupsListEndpointsRequest{}
	expected := &computebeta.NetworkEndpointGroupsListEndpointsRequest{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("NetworkEndpointGroupsListEndpointsRequest.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroupsListEndpointsRequest.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointGroupsListEndpointsRequestToGA(t *testing.T) {
	composite := NetworkEndpointGroupsListEndpointsRequest{}
	expected := &compute.NetworkEndpointGroupsListEndpointsRequest{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("NetworkEndpointGroupsListEndpointsRequest.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointGroupsListEndpointsRequest.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}

func TestNetworkEndpointGroupsListEndpointsRequestNetworkEndpointFilter(t *testing.T) {
	compositeType := reflect.TypeOf(NetworkEndpointGroupsListEndpointsRequestNetworkEndpointFilter{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpointGroupsListEndpointsRequestNetworkEndpointFilter{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}
func TestNetworkEndpointWithHealthStatus(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(NetworkEndpointWithHealthStatus{})
	alphaType := reflect.TypeOf(computealpha.NetworkEndpointWithHealthStatus{})
	betaType := reflect.TypeOf(computebeta.NetworkEndpointWithHealthStatus{})
	gaType := reflect.TypeOf(compute.NetworkEndpointWithHealthStatus{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToNetworkEndpointWithHealthStatus(t *testing.T)

func TestNetworkEndpointWithHealthStatusToAlpha(t *testing.T) {
	composite := NetworkEndpointWithHealthStatus{}
	expected := &computealpha.NetworkEndpointWithHealthStatus{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("NetworkEndpointWithHealthStatus.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointWithHealthStatus.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointWithHealthStatusToBeta(t *testing.T) {
	composite := NetworkEndpointWithHealthStatus{}
	expected := &computebeta.NetworkEndpointWithHealthStatus{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("NetworkEndpointWithHealthStatus.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointWithHealthStatus.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestNetworkEndpointWithHealthStatusToGA(t *testing.T) {
	composite := NetworkEndpointWithHealthStatus{}
	expected := &compute.NetworkEndpointWithHealthStatus{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("NetworkEndpointWithHealthStatus.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("NetworkEndpointWithHealthStatus.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}

func TestOriginAuthenticationMethod(t *testing.T) {
	compositeType := reflect.TypeOf(OriginAuthenticationMethod{})
	alphaType := reflect.TypeOf(computealpha.OriginAuthenticationMethod{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestOutlierDetection(t *testing.T) {
	compositeType := reflect.TypeOf(OutlierDetection{})
	alphaType := reflect.TypeOf(computealpha.OutlierDetection{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestPathMatcher(t *testing.T) {
	compositeType := reflect.TypeOf(PathMatcher{})
	alphaType := reflect.TypeOf(computealpha.PathMatcher{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestPathRule(t *testing.T) {
	compositeType := reflect.TypeOf(PathRule{})
	alphaType := reflect.TypeOf(computealpha.PathRule{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestPeerAuthenticationMethod(t *testing.T) {
	compositeType := reflect.TypeOf(PeerAuthenticationMethod{})
	alphaType := reflect.TypeOf(computealpha.PeerAuthenticationMethod{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestPermission(t *testing.T) {
	compositeType := reflect.TypeOf(Permission{})
	alphaType := reflect.TypeOf(computealpha.Permission{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestPermissionConstraint(t *testing.T) {
	compositeType := reflect.TypeOf(PermissionConstraint{})
	alphaType := reflect.TypeOf(computealpha.PermissionConstraint{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestPrincipal(t *testing.T) {
	compositeType := reflect.TypeOf(Principal{})
	alphaType := reflect.TypeOf(computealpha.Principal{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestRbacPolicy(t *testing.T) {
	compositeType := reflect.TypeOf(RbacPolicy{})
	alphaType := reflect.TypeOf(computealpha.RbacPolicy{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestRequestMirrorPolicy(t *testing.T) {
	compositeType := reflect.TypeOf(RequestMirrorPolicy{})
	alphaType := reflect.TypeOf(computealpha.RequestMirrorPolicy{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestSSLHealthCheck(t *testing.T) {
	compositeType := reflect.TypeOf(SSLHealthCheck{})
	alphaType := reflect.TypeOf(computealpha.SSLHealthCheck{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestSdsConfig(t *testing.T) {
	compositeType := reflect.TypeOf(SdsConfig{})
	alphaType := reflect.TypeOf(computealpha.SdsConfig{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestSecuritySettings(t *testing.T) {
	compositeType := reflect.TypeOf(SecuritySettings{})
	alphaType := reflect.TypeOf(computealpha.SecuritySettings{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}
func TestSslCertificate(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(SslCertificate{})
	alphaType := reflect.TypeOf(computealpha.SslCertificate{})
	betaType := reflect.TypeOf(computebeta.SslCertificate{})
	gaType := reflect.TypeOf(compute.SslCertificate{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToSslCertificate(t *testing.T)

func TestSslCertificateToAlpha(t *testing.T) {
	composite := SslCertificate{}
	expected := &computealpha.SslCertificate{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("SslCertificate.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("SslCertificate.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestSslCertificateToBeta(t *testing.T) {
	composite := SslCertificate{}
	expected := &computebeta.SslCertificate{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("SslCertificate.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("SslCertificate.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestSslCertificateToGA(t *testing.T) {
	composite := SslCertificate{}
	expected := &compute.SslCertificate{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("SslCertificate.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("SslCertificate.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}

func TestSslCertificateManagedSslCertificate(t *testing.T) {
	compositeType := reflect.TypeOf(SslCertificateManagedSslCertificate{})
	alphaType := reflect.TypeOf(computealpha.SslCertificateManagedSslCertificate{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestSslCertificateSelfManagedSslCertificate(t *testing.T) {
	compositeType := reflect.TypeOf(SslCertificateSelfManagedSslCertificate{})
	alphaType := reflect.TypeOf(computealpha.SslCertificateSelfManagedSslCertificate{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestSubsetting(t *testing.T) {
	compositeType := reflect.TypeOf(Subsetting{})
	alphaType := reflect.TypeOf(computealpha.Subsetting{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestTCPHealthCheck(t *testing.T) {
	compositeType := reflect.TypeOf(TCPHealthCheck{})
	alphaType := reflect.TypeOf(computealpha.TCPHealthCheck{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}
func TestTargetHttpProxy(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(TargetHttpProxy{})
	alphaType := reflect.TypeOf(computealpha.TargetHttpProxy{})
	betaType := reflect.TypeOf(computebeta.TargetHttpProxy{})
	gaType := reflect.TypeOf(compute.TargetHttpProxy{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToTargetHttpProxy(t *testing.T)

func TestTargetHttpProxyToAlpha(t *testing.T) {
	composite := TargetHttpProxy{}
	expected := &computealpha.TargetHttpProxy{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("TargetHttpProxy.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("TargetHttpProxy.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestTargetHttpProxyToBeta(t *testing.T) {
	composite := TargetHttpProxy{}
	expected := &computebeta.TargetHttpProxy{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("TargetHttpProxy.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("TargetHttpProxy.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestTargetHttpProxyToGA(t *testing.T) {
	composite := TargetHttpProxy{}
	expected := &compute.TargetHttpProxy{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("TargetHttpProxy.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("TargetHttpProxy.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestTargetHttpsProxy(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(TargetHttpsProxy{})
	alphaType := reflect.TypeOf(computealpha.TargetHttpsProxy{})
	betaType := reflect.TypeOf(computebeta.TargetHttpsProxy{})
	gaType := reflect.TypeOf(compute.TargetHttpsProxy{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToTargetHttpsProxy(t *testing.T)

func TestTargetHttpsProxyToAlpha(t *testing.T) {
	composite := TargetHttpsProxy{}
	expected := &computealpha.TargetHttpsProxy{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("TargetHttpsProxy.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("TargetHttpsProxy.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestTargetHttpsProxyToBeta(t *testing.T) {
	composite := TargetHttpsProxy{}
	expected := &computebeta.TargetHttpsProxy{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("TargetHttpsProxy.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("TargetHttpsProxy.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestTargetHttpsProxyToGA(t *testing.T) {
	composite := TargetHttpsProxy{}
	expected := &compute.TargetHttpsProxy{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("TargetHttpsProxy.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("TargetHttpsProxy.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}

func TestTlsCertificateContext(t *testing.T) {
	compositeType := reflect.TypeOf(TlsCertificateContext{})
	alphaType := reflect.TypeOf(computealpha.TlsCertificateContext{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestTlsCertificatePaths(t *testing.T) {
	compositeType := reflect.TypeOf(TlsCertificatePaths{})
	alphaType := reflect.TypeOf(computealpha.TlsCertificatePaths{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestTlsContext(t *testing.T) {
	compositeType := reflect.TypeOf(TlsContext{})
	alphaType := reflect.TypeOf(computealpha.TlsContext{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestTlsValidationContext(t *testing.T) {
	compositeType := reflect.TypeOf(TlsValidationContext{})
	alphaType := reflect.TypeOf(computealpha.TlsValidationContext{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestUDPHealthCheck(t *testing.T) {
	compositeType := reflect.TypeOf(UDPHealthCheck{})
	alphaType := reflect.TypeOf(computealpha.UDPHealthCheck{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}
func TestUrlMap(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf(UrlMap{})
	alphaType := reflect.TypeOf(computealpha.UrlMap{})
	betaType := reflect.TypeOf(computebeta.UrlMap{})
	gaType := reflect.TypeOf(compute.UrlMap{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 2
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	// Make sure that composite type is strictly alpha fields + internal bookkeeping
	for i := 2; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}

	// Verify that all beta fields are in composite type
	if err := typeEquality(betaType, compositeType, false); err != nil {
		t.Fatal(err)
	}

	// Verify that all GA fields are in composite type
	if err := typeEquality(gaType, compositeType, false); err != nil {
		t.Fatal(err)
	}
}

// TODO: these tests don't do anything as they are currently structured.
// func TestToUrlMap(t *testing.T)

func TestUrlMapToAlpha(t *testing.T) {
	composite := UrlMap{}
	expected := &computealpha.UrlMap{}
	result, err := composite.ToAlpha()
	if err != nil {
		t.Fatalf("UrlMap.ToAlpha() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("UrlMap.ToAlpha() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestUrlMapToBeta(t *testing.T) {
	composite := UrlMap{}
	expected := &computebeta.UrlMap{}
	result, err := composite.ToBeta()
	if err != nil {
		t.Fatalf("UrlMap.ToBeta() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("UrlMap.ToBeta() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
func TestUrlMapToGA(t *testing.T) {
	composite := UrlMap{}
	expected := &compute.UrlMap{}
	result, err := composite.ToGA()
	if err != nil {
		t.Fatalf("UrlMap.ToGA() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("UrlMap.ToGA() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}

func TestUrlMapTest(t *testing.T) {
	compositeType := reflect.TypeOf(UrlMapTest{})
	alphaType := reflect.TypeOf(computealpha.UrlMapTest{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestUrlMapTestHeader(t *testing.T) {
	compositeType := reflect.TypeOf(UrlMapTestHeader{})
	alphaType := reflect.TypeOf(computealpha.UrlMapTestHeader{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestUrlRewrite(t *testing.T) {
	compositeType := reflect.TypeOf(UrlRewrite{})
	alphaType := reflect.TypeOf(computealpha.UrlRewrite{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}

func TestWeightedBackendService(t *testing.T) {
	compositeType := reflect.TypeOf(WeightedBackendService{})
	alphaType := reflect.TypeOf(computealpha.WeightedBackendService{})
	if err := typeEquality(compositeType, alphaType, true); err != nil {
		t.Fatal(err)
	}
}
