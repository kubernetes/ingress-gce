/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Generates the code for the type specific pieces of the cache.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"
	"text/template"

	"k8s.io/ingress-gce/pkg/cache/meta"
)

const (
	gofmt = "gofmt"
)

var (
	noGofmt  = flag.Bool("noGofmt", false, "If set, don't run gofmt")
	unitTest = flag.Bool("unitTest", false, "If set, generate the code for the unit test")
)

func main() {
	flag.Parse()

	generated := &bytes.Buffer{}

	if *unitTest {
		genUnitTestHeader(generated)
		genBasicUnitTest(generated)
		genConversionUnitTest(generated)
	} else {
		genHeader(generated)
		genAdapter(generated)

		for _, t := range meta.AllTypes {
			for _, v := range meta.AllVersions {
				if t.Versions[v] {
					genTypeAdapter(generated, t, v)
					genDefaultConversions(generated, t, v)
				}
			}
		}

	}

	if *noGofmt {
		fmt.Print(generated.String())
		os.Exit(0)
	}

	cmd := exec.Command(gofmt)
	out := &bytes.Buffer{}
	cmd.Stdin = generated
	cmd.Stdout = out
	cmdErr := &bytes.Buffer{}
	cmd.Stderr = cmdErr

	if err := cmd.Run(); err != nil {
		fmt.Fprintf(os.Stderr, cmdErr.String())
		panic(err)
	}

	fmt.Print(out.String())
}

func capitalize(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[0:1]) + s[1:]
}

func genHeader(wr io.Writer) {
	t, err := template.New("header").Parse(
		`/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// The contents of this file is generated by "go run gen/main.go". Do not edit
// this file directly.

package cache

import (
	"fmt"

	{{.Alpha}} "google.golang.org/api/compute/v0.alpha"
	{{.Beta}} "google.golang.org/api/compute/v0.beta"
	{{.GA}} "google.golang.org/api/compute/v1"

  "k8s.io/ingress-gce/pkg/cache/meta"
)

`)
	if err != nil {
		panic(err)
	}

	err = t.Execute(wr, &struct {
		GA, Alpha, Beta meta.Version
	}{
		meta.VersionGA, meta.VersionAlpha, meta.VersionBeta,
	})
	if err != nil {
		panic(err)
	}
}

func genAdapter(wr io.Writer) {
	tmpl, err := template.New("adapter").Parse(`
// adapter is a convenience struct for embedding.
type adapter struct {
{{- range .Types}}
	{{.}} *{{.}}
{{- end}}
}

`)
	if err != nil {
		panic(err)
	}

	values := &struct{ Types []string }{}

	for _, ti := range meta.AllTypes {
		for _, v := range meta.AllVersions {
			if ti.Versions[v] {
				values.Types = append(values.Types, ti.Adapter(v))
			}
		}
	}

	err = tmpl.Execute(wr, values)
	if err != nil {
		panic(err)
	}

	fmt.Fprintf(wr, `// initAdapter initializes the adapter stubs with their backing generic stores
// and default conversion routines.
func initAdapter(a *adapter, newStore func() *store) {
	var st *store
`)

	for _, ti := range meta.AllTypes {
		fmt.Fprintf(wr, "\n\tst = newStore()\n")
		for _, version := range meta.AllVersions {
			if !ti.Versions[version] {
				continue
			}
			adapterName := ti.Adapter(version)
			fmt.Fprintf(wr, "\ta.%v = &%v{st: st}\n", adapterName, adapterName)

			for _, fromVersion := range meta.AllVersions {
				if !ti.Versions[fromVersion] || version == fromVersion {
					continue
				}
				fmt.Fprintf(wr, "\ta.%v.From%v = Default%vFrom%v\n",
					adapterName, fromVersion.CamelCase(), adapterName, fromVersion.CamelCase())
			}
		}
	}

	fmt.Fprintf(wr, "}\n")
}

func toMetadataVersion(v meta.Version) string {
	switch {
	case v == "alpha":
		return "VersionAlpha"
	case v == "beta":
		return "VersionBeta"
	default:
		return "VersionGA"
	}
}

func genTypeAdapter(wr io.Writer, ti *meta.TypeInfo, version meta.Version) {
	const tmpl = `
// {{.AdapterType}} is a stub for operating on cached objects of this type.
type {{.AdapterType}} struct {
	st *store
{{if .FromAlpha}}
	FromAlpha func(o *alpha.{{.Type}}) (*{{.APIVersion}}.{{.Type}}, error)
{{- end}}
{{- if .FromBeta}}
	FromBeta func(o *beta.{{.Type}}) (*{{.APIVersion}}.{{.Type}}, error)
{{- end}}
{{- if .FromGA}}
	FromGA func(o *ga.{{.Type}}) (*{{.APIVersion}}.{{.Type}}, error)
{{- end}}
}

// {{.AdapterType}}FilterFunc is a filter predicate.
type {{.AdapterType}}FilterFunc func(k Key, m *Metadata, o *{{.APIVersion}}.{{.Type}}) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *{{.AdapterType}}) Get(k Key, opt Options) (*Metadata, *{{.APIVersion}}.{{.Type}}, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.{{.MetadataVersion}} {
		return e.meta, e.obj.(*{{.APIVersion}}.{{.Type}}), nil
	}{{if .SupportsConversion }}
	if opt.convertVersion() {
		switch e.meta.Version {
		{{if .FromAlpha }}case meta.VersionAlpha:
			if c.FromAlpha == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromAlpha(e.obj.(*alpha.{{.Type}}))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil
		{{end}}
		{{if .FromBeta }}case meta.VersionBeta:
			if c.FromBeta == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromBeta(e.obj.(*beta.{{.Type}}))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil
		{{end}}
		{{if .FromGA }}case meta.VersionGA:
			if c.FromGA == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromGA(e.obj.(*ga.{{.Type}}))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil
		{{end}}
		}
	}{{end}}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *{{.AdapterType}}) Put(k Key, m *Metadata, obj *{{.APIVersion}}.{{.Type}}) error {
	if ! k.Valid("{{.Type}}") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.{{.MetadataVersion}}
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *{{.AdapterType}}) List() ([]Key, error) {
	fn := func(Key, *Metadata, *{{.APIVersion}}.{{.Type}}) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}
{{if .SupportsConversion}}
// ListAllVersions of the keys, including other API versions.
func (c *{{.AdapterType}}) ListAllVersions() ([]Key, error) {
	fn := func(Key, *Metadata, *{{.APIVersion}}.{{.Type}}) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, MetadataOnly)
}
{{- end}}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *{{.AdapterType}}) ListByFilter(filter {{.AdapterType}}FilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if ! opt.convertVersion() && e.meta.Version != meta.{{.MetadataVersion}} {
			return false, nil
		}
		{{- if .SupportsConversion }}
		if opt.convertVersion() {
			switch e.meta.Version {
			{{- if .FromAlpha }}
			case meta.VersionAlpha:
				if c.FromAlpha == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromAlpha(e.obj.(*alpha.{{.Type}}))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			{{- end}}
			{{- if .FromBeta }}
			case meta.VersionBeta:
				if c.FromBeta == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromBeta(e.obj.(*beta.{{.Type}}))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			{{- end}}
			{{- if .FromGA }}
			case meta.VersionGA:
				if c.FromGA == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromGA(e.obj.(*ga.{{.Type}}))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			{{- end}}
			}
		}
		{{- end}}
		return filter(e.key, e.meta, e.obj.(*{{.APIVersion}}.{{.Type}}))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *{{.AdapterType}}) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *{{.AdapterType}}) FlushByFilter(filter {{.AdapterType}}FilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}
`
	t, err := template.New("TypeCRUD").Parse(tmpl)
	if err != nil {
		panic(err)
	}

	adapterType := ti.Adapter(version)

	vars := &struct {
		APIVersion       meta.Version
		MetadataVersion  string
		AdapterType      string
		AdapterTypeEntry string
		Type             string

		FromAlpha          bool
		FromBeta           bool
		FromGA             bool
		SupportsConversion bool
	}{
		version,
		toMetadataVersion(version),
		adapterType,
		adapterType + "Entry",
		ti.Name,
		version != meta.VersionAlpha && ti.Versions[meta.VersionAlpha],
		version != meta.VersionBeta && ti.Versions[meta.VersionBeta],
		version != meta.VersionGA && ti.Versions[meta.VersionGA],
		false,
	}
	vars.SupportsConversion = vars.FromAlpha || vars.FromBeta || vars.FromGA

	if err = t.Execute(wr, vars); err != nil {
		panic(err)
	}
}

func genDefaultConversions(wr io.Writer, ti *meta.TypeInfo, version meta.Version) {
	if !ti.Versions[version] {
		return
	}
	for _, fromVersion := range meta.AllVersions {
		if !ti.Versions[fromVersion] || version == fromVersion {
			continue
		}
		const tmpl = `
// Default{{.AdapterType}}From{{.FromVersionCC}} is the default type conversion.
func Default{{.AdapterType}}From{{.FromVersionCC}}(src *{{.FromVersion}}.{{.Type}}) (*{{.Version}}.{{.Type}}, error) {
	dest := &{{.Version}}.{{.Type}}{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}
`
		t, err := template.New("DefaultConversion").Parse(tmpl)
		if err != nil {
			panic(err)
		}
		vars := map[string]string{
			"AdapterType":   ti.Adapter(version),
			"FromVersion":   string(fromVersion),
			"FromVersionCC": fromVersion.CamelCase(),
			"Type":          ti.Name,
			"Version":       string(version),
		}
		if err = t.Execute(wr, vars); err != nil {
			panic(err)
		}
	}
}

func keyForType(ty *meta.TypeInfo, suffix string) string {
	switch {
	case ty.KeyConstraint.Global:
		return fmt.Sprintf(`GlobalKey("key-%v")`, suffix)
	case ty.KeyConstraint.Regional:
		return fmt.Sprintf(`RegionalKey("key-%v", "us-central1")`, suffix)
	case ty.KeyConstraint.Zonal:
		return fmt.Sprintf(`ZonalKey("key-%v", "us-central1-b")`, suffix)
	}
	return "invalid"
}

func testKey(ty *meta.TypeInfo, suffix string) string {
	switch {
	case ty.KeyConstraint.Global:
		return fmt.Sprintf(`GlobalKey("key%v")`, suffix)
	case ty.KeyConstraint.Regional:
		return fmt.Sprintf(`RegionalKey("key%v", "us-central1")`, suffix)
	case ty.KeyConstraint.Zonal:
		return fmt.Sprintf(`ZonalKey("key%v", "us-central1-b")`, suffix)
	}
	return "invalid"
}

func genUnitTestHeader(wr io.Writer) {
	fmt.Fprintf(wr, `/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was generated with "go run gen/main.go -unitTest > gen_test.go"

package cache

import (
	"errors"
	"testing"

	alpha "google.golang.org/api/compute/v0.alpha"
	beta "google.golang.org/api/compute/v0.beta"
	ga "google.golang.org/api/compute/v1"
)
`)
}

// genBasicUnitTest generates unit tests for the basic functionality of each type
// adapter.
func genBasicUnitTest(wr io.Writer) {
	const tmpl = `
func TestGCE{{.Adapter}}(t *testing.T) {
	t.Parallel()
	gce := NewGCE()
	key := {{.Key}}
	obj := &{{.Package}}.{{.Type}}{Name: key.Name}

	// Get non-existant key.
	if meta, obj, err := gce.{{.Adapter}}.Get(key, 0); err != ErrNotFound {
		t.Errorf("gce.{{.Adapter}}.Get(%v, 0) = %v, %v, %v, want nil, nil, ErrNotFound", key, meta, obj, err)
	}

	// Flush non-existant key.
	gce.{{.Adapter}}.Flush(key)

	// List should return no objects.
	keys, err := gce.{{.Adapter}}.List()
	if len(keys) != 0 || err != nil {
		t.Errorf("gce.{{.Adapter}}.List() = %v, %v; want [], nil", keys, err)
	}

	// Put an object.
	if err := gce.{{.Adapter}}.Put(key, &Metadata{}, obj); err != nil {
		t.Errorf("gce.{{.Adapter}}.Put(%v, &Metadata{}, %v) = %v, want nil", key, obj, err)
	}

	// Cannot put nil.
	if err := gce.{{.Adapter}}.Put(key, &Metadata{}, nil); err == nil {
		t.Errorf("gce.{{.Adapter}}.Put(%v, &Metadata{}, nil) = nil, want error", key)
	}

	// Get the object back.
	m, o, err := gce.{{.Adapter}}.Get(key, 0)
	if err != nil || o != obj{
		t.Errorf("gce.{{.Adapter}}.Get(%v, 0) = %v, %v, %v, want _, _, nil", key, m, o, err)
	}

	// List.
	keys, err = gce.{{.Adapter}}.List()
	if err != nil || len(keys) != 1 || keys[0] != key {
		t.Errorf("gce.{{.Adapter}}.List() = %v, %v; want [], nil", keys, err)
	}

	// ListByFilter.
	keys, err = gce.{{.Adapter}}.ListByFilter(func(Key, *Metadata, *{{.Package}}.{{.Type}}) (bool, error) {
		return true, nil
	}, 0)
	if err != nil || len(keys) != 1 || keys[0] != key {
		t.Errorf("gce.{{.Adapter}}.List() = %v, %v; want [], nil", keys, err)
	}

	// ListByFilter, metadata only.
	keys, err = gce.{{.Adapter}}.ListByFilter(func(k Key, m *Metadata, o *{{.Package}}.{{.Type}}) (bool, error) {
		if o != nil {
			t.Errorf("gce.{{.Adapter}}.ListByFilter(..., MetadataOnly), func called with non-nil obj")
		}
		return true, nil
	}, MetadataOnly)
	if err != nil || len(keys) != 1 || keys[0] != key {
		t.Errorf("gce.{{.Adapter}}.ListByFilter(0) = %v, %v; want [], nil", keys, err)
	}

	// FlushByFilter, returning error.
	err = gce.{{.Adapter}}.FlushByFilter(func(Key, *Metadata, *{{.Package}}.{{.Type}}) (bool, error) {
		return false, errors.New("injected error")
	}, 0)
	if err == nil {
		t.Errorf("gce.{{.Adapter}}.FlushByFilter(...) = nil, want error")
	}

	// FlushByFilter.
	err = gce.{{.Adapter}}.FlushByFilter(func(Key, *Metadata, *{{.Package}}.{{.Type}}) (bool, error) {
		return true, nil
	}, 0)
	if err != nil {
		t.Errorf("gce.{{.Adapter}}.FlushByFilter(...) = %v, want nil", err)
	}
}
`
	for _, ty := range meta.AllTypes {
		for version := range ty.Versions {
			t, err := template.New("unittest").Parse(tmpl)
			if err != nil {
				panic(err)
			}
			values := struct {
				Adapter string
				Key     string
				Package string
				Type    string
			}{
				ty.Adapter(version),
				testKey(ty, ""),
				string(version),
				ty.Name,
			}
			t.Execute(wr, values)
		}
	}
}

func genConversionUnitTest(wr io.Writer) {
	const tmpl = `
func TestGCE{{.Adapter}}Conversions(t *testing.T) {
	t.Parallel()

	gce := NewGCE()
{{range .Vars}}
	key{{.Suffix}} := {{.Key}}
	obj{{.Suffix}} := &{{.Package}}.{{.Type}}{Name: key{{.Suffix}}.Name}
{{- end}}

	// Put for different versions.
{{- range .Puts}}
	if err := gce.{{.Adapter}}.Put(key{{.Suffix}}, &Metadata{}, obj{{.Suffix}}); err != nil {
		t.Errorf("gce.{{.Adapter}}.Put(key{{.Suffix}}, &Metadata{}, obj{{.Suffix}}) = %v; want nil", err)
	}
{{- end}}

	// Get for different versions.
{{- range .Gets}}
	if m, o, err := gce.{{.Adapter}}.Get(key{{.Suffix}}, ConvertVersion); err == nil {
		if o == nil {
			t.Errorf("gce.{{.Adapter}}.Get(key{{.Suffix}}, ConvertVersion) = %v, %v, %v, want _, non-nil, nil", m, o, err)
		}
	} else {
		t.Errorf("gce.{{.Adapter}}.Get(key{{.Suffix}}, ConvertVersion) = %v, %v, %v, want _, _, nil", m, o, err)
	}
{{- end}}

	// List.
	keys, err := gce.{{.Adapter}}.ListAllVersions()
	if err != nil {
		t.Errorf("gce.{{.Adapter}}.ListAllVersions() = %v, %v; want _, nil", keys, err)
	}

	// ListByFilter
	fn := func(k Key, m *Metadata, o *{{.Package}}.{{.Type}}) (bool, error) {
		return true, nil
	}
	keys, err = gce.{{.Adapter}}.ListByFilter(fn, ConvertVersion)
	if err != nil {
		t.Errorf("gce.{{.Adapter}}.ListByFilter(..., ConvertVersion) = %v, %v; want _, nil", keys, err)
	}
}
`
	type Vars struct {
		Key     string
		Suffix  string
		Package string
		Type    string
	}
	type Put struct {
		Adapter string
		Suffix  string
	}
	type Get struct {
		Adapter string
		Suffix  string
	}
	type Values struct {
		Adapter string
		Vars    []*Vars
		Puts    []*Put
		Gets    []*Get
		Package string
		Type    string
	}

	for _, ty := range meta.AllTypes {
		if len(ty.Versions) <= 1 {
			continue
		}

		for version := range ty.Versions {
			adapter := ty.Adapter(version)
			values := &Values{Adapter: adapter, Package: string(version), Type: ty.Name}
			t, err := template.New("unittest").Parse(tmpl)
			if err != nil {
				panic(err)
			}
			for version := range ty.Versions {
				values.Vars = append(values.Vars, &Vars{
					testKey(ty, string(version)),
					string(version),
					string(version),
					ty.Name,
				})
			}
			for version := range ty.Versions {
				values.Puts = append(values.Puts, &Put{
					ty.Adapter(version),
					string(version),
				})
			}
			for version := range ty.Versions {
				values.Gets = append(values.Gets, &Get{
					adapter,
					string(version),
				})
			}
			if err := t.Execute(wr, values); err != nil {
				panic(err)
			}
		}
	}
}
