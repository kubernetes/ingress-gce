/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// The contents of this file is generated by "go run gen/main.go". Do not edit
// this file directly.

package cache

import (
	"fmt"

	alpha "google.golang.org/api/compute/v0.alpha"
	beta "google.golang.org/api/compute/v0.beta"
	ga "google.golang.org/api/compute/v1"

	"k8s.io/ingress-gce/pkg/cache/meta"
)

// adapter is a convenience struct for embedding.
type adapter struct {
	Address             *Address
	BackendService      *BackendService
	Firewall            *Firewall
	ForwardingRule      *ForwardingRule
	AlphaForwardingRule *AlphaForwardingRule
	BetaForwardingRule  *BetaForwardingRule
	HealthCheck         *HealthCheck
	AlphaHealthCheck    *AlphaHealthCheck
	BetaHealthCheck     *BetaHealthCheck
	InstanceGroup       *InstanceGroup
	SslCertificate      *SslCertificate
	TargetHttpProxy     *TargetHttpProxy
	TargetHttpsProxy    *TargetHttpsProxy
	TargetPool          *TargetPool
	UrlMap              *UrlMap
}

// initAdapter initializes the adapter stubs with their backing generic stores
// and default conversion routines.
func initAdapter(a *adapter, newStore func() *store) {
	var st *store

	st = newStore()
	a.Address = &Address{st: st}

	st = newStore()
	a.BackendService = &BackendService{st: st}

	st = newStore()
	a.Firewall = &Firewall{st: st}

	st = newStore()
	a.ForwardingRule = &ForwardingRule{st: st}
	a.ForwardingRule.FromAlpha = DefaultForwardingRuleFromAlpha
	a.ForwardingRule.FromBeta = DefaultForwardingRuleFromBeta
	a.AlphaForwardingRule = &AlphaForwardingRule{st: st}
	a.AlphaForwardingRule.FromGA = DefaultAlphaForwardingRuleFromGA
	a.AlphaForwardingRule.FromBeta = DefaultAlphaForwardingRuleFromBeta
	a.BetaForwardingRule = &BetaForwardingRule{st: st}
	a.BetaForwardingRule.FromGA = DefaultBetaForwardingRuleFromGA
	a.BetaForwardingRule.FromAlpha = DefaultBetaForwardingRuleFromAlpha

	st = newStore()
	a.HealthCheck = &HealthCheck{st: st}
	a.HealthCheck.FromAlpha = DefaultHealthCheckFromAlpha
	a.HealthCheck.FromBeta = DefaultHealthCheckFromBeta
	a.AlphaHealthCheck = &AlphaHealthCheck{st: st}
	a.AlphaHealthCheck.FromGA = DefaultAlphaHealthCheckFromGA
	a.AlphaHealthCheck.FromBeta = DefaultAlphaHealthCheckFromBeta
	a.BetaHealthCheck = &BetaHealthCheck{st: st}
	a.BetaHealthCheck.FromGA = DefaultBetaHealthCheckFromGA
	a.BetaHealthCheck.FromAlpha = DefaultBetaHealthCheckFromAlpha

	st = newStore()
	a.InstanceGroup = &InstanceGroup{st: st}

	st = newStore()
	a.SslCertificate = &SslCertificate{st: st}

	st = newStore()
	a.TargetHttpProxy = &TargetHttpProxy{st: st}

	st = newStore()
	a.TargetHttpsProxy = &TargetHttpsProxy{st: st}

	st = newStore()
	a.TargetPool = &TargetPool{st: st}

	st = newStore()
	a.UrlMap = &UrlMap{st: st}
}

// Address is a stub for operating on cached objects of this type.
type Address struct {
	st *store
}

// AddressFilterFunc is a filter predicate.
type AddressFilterFunc func(k Key, m *Metadata, o *ga.Address) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *Address) Get(k Key, opt Options) (*Metadata, *ga.Address, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionGA {
		return e.meta, e.obj.(*ga.Address), nil
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *Address) Put(k Key, m *Metadata, obj *ga.Address) error {
	if !k.Valid("Address") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionGA
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *Address) List() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.Address) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *Address) ListByFilter(filter AddressFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionGA {
			return false, nil
		}
		return filter(e.key, e.meta, e.obj.(*ga.Address))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *Address) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *Address) FlushByFilter(filter AddressFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// BackendService is a stub for operating on cached objects of this type.
type BackendService struct {
	st *store
}

// BackendServiceFilterFunc is a filter predicate.
type BackendServiceFilterFunc func(k Key, m *Metadata, o *ga.BackendService) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *BackendService) Get(k Key, opt Options) (*Metadata, *ga.BackendService, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionGA {
		return e.meta, e.obj.(*ga.BackendService), nil
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *BackendService) Put(k Key, m *Metadata, obj *ga.BackendService) error {
	if !k.Valid("BackendService") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionGA
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *BackendService) List() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.BackendService) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *BackendService) ListByFilter(filter BackendServiceFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionGA {
			return false, nil
		}
		return filter(e.key, e.meta, e.obj.(*ga.BackendService))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *BackendService) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *BackendService) FlushByFilter(filter BackendServiceFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// Firewall is a stub for operating on cached objects of this type.
type Firewall struct {
	st *store
}

// FirewallFilterFunc is a filter predicate.
type FirewallFilterFunc func(k Key, m *Metadata, o *ga.Firewall) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *Firewall) Get(k Key, opt Options) (*Metadata, *ga.Firewall, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionGA {
		return e.meta, e.obj.(*ga.Firewall), nil
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *Firewall) Put(k Key, m *Metadata, obj *ga.Firewall) error {
	if !k.Valid("Firewall") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionGA
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *Firewall) List() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.Firewall) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *Firewall) ListByFilter(filter FirewallFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionGA {
			return false, nil
		}
		return filter(e.key, e.meta, e.obj.(*ga.Firewall))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *Firewall) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *Firewall) FlushByFilter(filter FirewallFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// ForwardingRule is a stub for operating on cached objects of this type.
type ForwardingRule struct {
	st *store

	FromAlpha func(o *alpha.ForwardingRule) (*ga.ForwardingRule, error)
	FromBeta  func(o *beta.ForwardingRule) (*ga.ForwardingRule, error)
}

// ForwardingRuleFilterFunc is a filter predicate.
type ForwardingRuleFilterFunc func(k Key, m *Metadata, o *ga.ForwardingRule) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *ForwardingRule) Get(k Key, opt Options) (*Metadata, *ga.ForwardingRule, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionGA {
		return e.meta, e.obj.(*ga.ForwardingRule), nil
	}
	if opt.convertVersion() {
		switch e.meta.Version {
		case meta.VersionAlpha:
			if c.FromAlpha == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromAlpha(e.obj.(*alpha.ForwardingRule))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		case meta.VersionBeta:
			if c.FromBeta == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromBeta(e.obj.(*beta.ForwardingRule))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		}
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *ForwardingRule) Put(k Key, m *Metadata, obj *ga.ForwardingRule) error {
	if !k.Valid("ForwardingRule") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionGA
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *ForwardingRule) List() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.ForwardingRule) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListAllVersions of the keys, including other API versions.
func (c *ForwardingRule) ListAllVersions() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.ForwardingRule) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, MetadataOnly)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *ForwardingRule) ListByFilter(filter ForwardingRuleFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionGA {
			return false, nil
		}
		if opt.convertVersion() {
			switch e.meta.Version {
			case meta.VersionAlpha:
				if c.FromAlpha == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromAlpha(e.obj.(*alpha.ForwardingRule))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			case meta.VersionBeta:
				if c.FromBeta == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromBeta(e.obj.(*beta.ForwardingRule))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			}
		}
		return filter(e.key, e.meta, e.obj.(*ga.ForwardingRule))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *ForwardingRule) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *ForwardingRule) FlushByFilter(filter ForwardingRuleFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// DefaultForwardingRuleFromAlpha is the default type conversion.
func DefaultForwardingRuleFromAlpha(src *alpha.ForwardingRule) (*ga.ForwardingRule, error) {
	dest := &ga.ForwardingRule{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// DefaultForwardingRuleFromBeta is the default type conversion.
func DefaultForwardingRuleFromBeta(src *beta.ForwardingRule) (*ga.ForwardingRule, error) {
	dest := &ga.ForwardingRule{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// AlphaForwardingRule is a stub for operating on cached objects of this type.
type AlphaForwardingRule struct {
	st *store

	FromBeta func(o *beta.ForwardingRule) (*alpha.ForwardingRule, error)
	FromGA   func(o *ga.ForwardingRule) (*alpha.ForwardingRule, error)
}

// AlphaForwardingRuleFilterFunc is a filter predicate.
type AlphaForwardingRuleFilterFunc func(k Key, m *Metadata, o *alpha.ForwardingRule) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *AlphaForwardingRule) Get(k Key, opt Options) (*Metadata, *alpha.ForwardingRule, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionAlpha {
		return e.meta, e.obj.(*alpha.ForwardingRule), nil
	}
	if opt.convertVersion() {
		switch e.meta.Version {

		case meta.VersionBeta:
			if c.FromBeta == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromBeta(e.obj.(*beta.ForwardingRule))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		case meta.VersionGA:
			if c.FromGA == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromGA(e.obj.(*ga.ForwardingRule))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		}
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *AlphaForwardingRule) Put(k Key, m *Metadata, obj *alpha.ForwardingRule) error {
	if !k.Valid("ForwardingRule") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionAlpha
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *AlphaForwardingRule) List() ([]Key, error) {
	fn := func(Key, *Metadata, *alpha.ForwardingRule) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListAllVersions of the keys, including other API versions.
func (c *AlphaForwardingRule) ListAllVersions() ([]Key, error) {
	fn := func(Key, *Metadata, *alpha.ForwardingRule) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, MetadataOnly)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *AlphaForwardingRule) ListByFilter(filter AlphaForwardingRuleFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionAlpha {
			return false, nil
		}
		if opt.convertVersion() {
			switch e.meta.Version {
			case meta.VersionBeta:
				if c.FromBeta == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromBeta(e.obj.(*beta.ForwardingRule))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			case meta.VersionGA:
				if c.FromGA == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromGA(e.obj.(*ga.ForwardingRule))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			}
		}
		return filter(e.key, e.meta, e.obj.(*alpha.ForwardingRule))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *AlphaForwardingRule) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *AlphaForwardingRule) FlushByFilter(filter AlphaForwardingRuleFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// DefaultAlphaForwardingRuleFromGA is the default type conversion.
func DefaultAlphaForwardingRuleFromGA(src *ga.ForwardingRule) (*alpha.ForwardingRule, error) {
	dest := &alpha.ForwardingRule{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// DefaultAlphaForwardingRuleFromBeta is the default type conversion.
func DefaultAlphaForwardingRuleFromBeta(src *beta.ForwardingRule) (*alpha.ForwardingRule, error) {
	dest := &alpha.ForwardingRule{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// BetaForwardingRule is a stub for operating on cached objects of this type.
type BetaForwardingRule struct {
	st *store

	FromAlpha func(o *alpha.ForwardingRule) (*beta.ForwardingRule, error)
	FromGA    func(o *ga.ForwardingRule) (*beta.ForwardingRule, error)
}

// BetaForwardingRuleFilterFunc is a filter predicate.
type BetaForwardingRuleFilterFunc func(k Key, m *Metadata, o *beta.ForwardingRule) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *BetaForwardingRule) Get(k Key, opt Options) (*Metadata, *beta.ForwardingRule, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionBeta {
		return e.meta, e.obj.(*beta.ForwardingRule), nil
	}
	if opt.convertVersion() {
		switch e.meta.Version {
		case meta.VersionAlpha:
			if c.FromAlpha == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromAlpha(e.obj.(*alpha.ForwardingRule))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		case meta.VersionGA:
			if c.FromGA == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromGA(e.obj.(*ga.ForwardingRule))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		}
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *BetaForwardingRule) Put(k Key, m *Metadata, obj *beta.ForwardingRule) error {
	if !k.Valid("ForwardingRule") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionBeta
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *BetaForwardingRule) List() ([]Key, error) {
	fn := func(Key, *Metadata, *beta.ForwardingRule) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListAllVersions of the keys, including other API versions.
func (c *BetaForwardingRule) ListAllVersions() ([]Key, error) {
	fn := func(Key, *Metadata, *beta.ForwardingRule) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, MetadataOnly)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *BetaForwardingRule) ListByFilter(filter BetaForwardingRuleFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionBeta {
			return false, nil
		}
		if opt.convertVersion() {
			switch e.meta.Version {
			case meta.VersionAlpha:
				if c.FromAlpha == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromAlpha(e.obj.(*alpha.ForwardingRule))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			case meta.VersionGA:
				if c.FromGA == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromGA(e.obj.(*ga.ForwardingRule))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			}
		}
		return filter(e.key, e.meta, e.obj.(*beta.ForwardingRule))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *BetaForwardingRule) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *BetaForwardingRule) FlushByFilter(filter BetaForwardingRuleFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// DefaultBetaForwardingRuleFromGA is the default type conversion.
func DefaultBetaForwardingRuleFromGA(src *ga.ForwardingRule) (*beta.ForwardingRule, error) {
	dest := &beta.ForwardingRule{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// DefaultBetaForwardingRuleFromAlpha is the default type conversion.
func DefaultBetaForwardingRuleFromAlpha(src *alpha.ForwardingRule) (*beta.ForwardingRule, error) {
	dest := &beta.ForwardingRule{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// HealthCheck is a stub for operating on cached objects of this type.
type HealthCheck struct {
	st *store

	FromAlpha func(o *alpha.HealthCheck) (*ga.HealthCheck, error)
	FromBeta  func(o *beta.HealthCheck) (*ga.HealthCheck, error)
}

// HealthCheckFilterFunc is a filter predicate.
type HealthCheckFilterFunc func(k Key, m *Metadata, o *ga.HealthCheck) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *HealthCheck) Get(k Key, opt Options) (*Metadata, *ga.HealthCheck, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionGA {
		return e.meta, e.obj.(*ga.HealthCheck), nil
	}
	if opt.convertVersion() {
		switch e.meta.Version {
		case meta.VersionAlpha:
			if c.FromAlpha == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromAlpha(e.obj.(*alpha.HealthCheck))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		case meta.VersionBeta:
			if c.FromBeta == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromBeta(e.obj.(*beta.HealthCheck))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		}
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *HealthCheck) Put(k Key, m *Metadata, obj *ga.HealthCheck) error {
	if !k.Valid("HealthCheck") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionGA
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *HealthCheck) List() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.HealthCheck) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListAllVersions of the keys, including other API versions.
func (c *HealthCheck) ListAllVersions() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.HealthCheck) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, MetadataOnly)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *HealthCheck) ListByFilter(filter HealthCheckFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionGA {
			return false, nil
		}
		if opt.convertVersion() {
			switch e.meta.Version {
			case meta.VersionAlpha:
				if c.FromAlpha == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromAlpha(e.obj.(*alpha.HealthCheck))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			case meta.VersionBeta:
				if c.FromBeta == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromBeta(e.obj.(*beta.HealthCheck))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			}
		}
		return filter(e.key, e.meta, e.obj.(*ga.HealthCheck))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *HealthCheck) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *HealthCheck) FlushByFilter(filter HealthCheckFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// DefaultHealthCheckFromAlpha is the default type conversion.
func DefaultHealthCheckFromAlpha(src *alpha.HealthCheck) (*ga.HealthCheck, error) {
	dest := &ga.HealthCheck{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// DefaultHealthCheckFromBeta is the default type conversion.
func DefaultHealthCheckFromBeta(src *beta.HealthCheck) (*ga.HealthCheck, error) {
	dest := &ga.HealthCheck{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// AlphaHealthCheck is a stub for operating on cached objects of this type.
type AlphaHealthCheck struct {
	st *store

	FromBeta func(o *beta.HealthCheck) (*alpha.HealthCheck, error)
	FromGA   func(o *ga.HealthCheck) (*alpha.HealthCheck, error)
}

// AlphaHealthCheckFilterFunc is a filter predicate.
type AlphaHealthCheckFilterFunc func(k Key, m *Metadata, o *alpha.HealthCheck) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *AlphaHealthCheck) Get(k Key, opt Options) (*Metadata, *alpha.HealthCheck, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionAlpha {
		return e.meta, e.obj.(*alpha.HealthCheck), nil
	}
	if opt.convertVersion() {
		switch e.meta.Version {

		case meta.VersionBeta:
			if c.FromBeta == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromBeta(e.obj.(*beta.HealthCheck))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		case meta.VersionGA:
			if c.FromGA == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromGA(e.obj.(*ga.HealthCheck))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		}
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *AlphaHealthCheck) Put(k Key, m *Metadata, obj *alpha.HealthCheck) error {
	if !k.Valid("HealthCheck") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionAlpha
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *AlphaHealthCheck) List() ([]Key, error) {
	fn := func(Key, *Metadata, *alpha.HealthCheck) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListAllVersions of the keys, including other API versions.
func (c *AlphaHealthCheck) ListAllVersions() ([]Key, error) {
	fn := func(Key, *Metadata, *alpha.HealthCheck) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, MetadataOnly)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *AlphaHealthCheck) ListByFilter(filter AlphaHealthCheckFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionAlpha {
			return false, nil
		}
		if opt.convertVersion() {
			switch e.meta.Version {
			case meta.VersionBeta:
				if c.FromBeta == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromBeta(e.obj.(*beta.HealthCheck))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			case meta.VersionGA:
				if c.FromGA == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromGA(e.obj.(*ga.HealthCheck))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			}
		}
		return filter(e.key, e.meta, e.obj.(*alpha.HealthCheck))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *AlphaHealthCheck) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *AlphaHealthCheck) FlushByFilter(filter AlphaHealthCheckFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// DefaultAlphaHealthCheckFromGA is the default type conversion.
func DefaultAlphaHealthCheckFromGA(src *ga.HealthCheck) (*alpha.HealthCheck, error) {
	dest := &alpha.HealthCheck{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// DefaultAlphaHealthCheckFromBeta is the default type conversion.
func DefaultAlphaHealthCheckFromBeta(src *beta.HealthCheck) (*alpha.HealthCheck, error) {
	dest := &alpha.HealthCheck{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// BetaHealthCheck is a stub for operating on cached objects of this type.
type BetaHealthCheck struct {
	st *store

	FromAlpha func(o *alpha.HealthCheck) (*beta.HealthCheck, error)
	FromGA    func(o *ga.HealthCheck) (*beta.HealthCheck, error)
}

// BetaHealthCheckFilterFunc is a filter predicate.
type BetaHealthCheckFilterFunc func(k Key, m *Metadata, o *beta.HealthCheck) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *BetaHealthCheck) Get(k Key, opt Options) (*Metadata, *beta.HealthCheck, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionBeta {
		return e.meta, e.obj.(*beta.HealthCheck), nil
	}
	if opt.convertVersion() {
		switch e.meta.Version {
		case meta.VersionAlpha:
			if c.FromAlpha == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromAlpha(e.obj.(*alpha.HealthCheck))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		case meta.VersionGA:
			if c.FromGA == nil {
				return nil, nil, ErrNoConversion
			}
			obj, err := c.FromGA(e.obj.(*ga.HealthCheck))
			if err != nil {
				return nil, nil, err
			}
			return e.meta, obj, nil

		}
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *BetaHealthCheck) Put(k Key, m *Metadata, obj *beta.HealthCheck) error {
	if !k.Valid("HealthCheck") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionBeta
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *BetaHealthCheck) List() ([]Key, error) {
	fn := func(Key, *Metadata, *beta.HealthCheck) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListAllVersions of the keys, including other API versions.
func (c *BetaHealthCheck) ListAllVersions() ([]Key, error) {
	fn := func(Key, *Metadata, *beta.HealthCheck) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, MetadataOnly)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *BetaHealthCheck) ListByFilter(filter BetaHealthCheckFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionBeta {
			return false, nil
		}
		if opt.convertVersion() {
			switch e.meta.Version {
			case meta.VersionAlpha:
				if c.FromAlpha == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromAlpha(e.obj.(*alpha.HealthCheck))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			case meta.VersionGA:
				if c.FromGA == nil {
					return false, ErrNoConversion
				}
				obj, err := c.FromGA(e.obj.(*ga.HealthCheck))
				if err != nil {
					return false, err
				}
				return filter(e.key, e.meta, obj)
			}
		}
		return filter(e.key, e.meta, e.obj.(*beta.HealthCheck))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *BetaHealthCheck) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *BetaHealthCheck) FlushByFilter(filter BetaHealthCheckFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// DefaultBetaHealthCheckFromGA is the default type conversion.
func DefaultBetaHealthCheckFromGA(src *ga.HealthCheck) (*beta.HealthCheck, error) {
	dest := &beta.HealthCheck{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// DefaultBetaHealthCheckFromAlpha is the default type conversion.
func DefaultBetaHealthCheckFromAlpha(src *alpha.HealthCheck) (*beta.HealthCheck, error) {
	dest := &beta.HealthCheck{}
	if err := copyViaJSON(dest, src); err != nil {
		return nil, err
	}
	return dest, nil
}

// InstanceGroup is a stub for operating on cached objects of this type.
type InstanceGroup struct {
	st *store
}

// InstanceGroupFilterFunc is a filter predicate.
type InstanceGroupFilterFunc func(k Key, m *Metadata, o *ga.InstanceGroup) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *InstanceGroup) Get(k Key, opt Options) (*Metadata, *ga.InstanceGroup, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionGA {
		return e.meta, e.obj.(*ga.InstanceGroup), nil
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *InstanceGroup) Put(k Key, m *Metadata, obj *ga.InstanceGroup) error {
	if !k.Valid("InstanceGroup") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionGA
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *InstanceGroup) List() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.InstanceGroup) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *InstanceGroup) ListByFilter(filter InstanceGroupFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionGA {
			return false, nil
		}
		return filter(e.key, e.meta, e.obj.(*ga.InstanceGroup))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *InstanceGroup) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *InstanceGroup) FlushByFilter(filter InstanceGroupFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// SslCertificate is a stub for operating on cached objects of this type.
type SslCertificate struct {
	st *store
}

// SslCertificateFilterFunc is a filter predicate.
type SslCertificateFilterFunc func(k Key, m *Metadata, o *ga.SslCertificate) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *SslCertificate) Get(k Key, opt Options) (*Metadata, *ga.SslCertificate, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionGA {
		return e.meta, e.obj.(*ga.SslCertificate), nil
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *SslCertificate) Put(k Key, m *Metadata, obj *ga.SslCertificate) error {
	if !k.Valid("SslCertificate") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionGA
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *SslCertificate) List() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.SslCertificate) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *SslCertificate) ListByFilter(filter SslCertificateFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionGA {
			return false, nil
		}
		return filter(e.key, e.meta, e.obj.(*ga.SslCertificate))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *SslCertificate) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *SslCertificate) FlushByFilter(filter SslCertificateFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// TargetHttpProxy is a stub for operating on cached objects of this type.
type TargetHttpProxy struct {
	st *store
}

// TargetHttpProxyFilterFunc is a filter predicate.
type TargetHttpProxyFilterFunc func(k Key, m *Metadata, o *ga.TargetHttpProxy) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *TargetHttpProxy) Get(k Key, opt Options) (*Metadata, *ga.TargetHttpProxy, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionGA {
		return e.meta, e.obj.(*ga.TargetHttpProxy), nil
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *TargetHttpProxy) Put(k Key, m *Metadata, obj *ga.TargetHttpProxy) error {
	if !k.Valid("TargetHttpProxy") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionGA
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *TargetHttpProxy) List() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.TargetHttpProxy) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *TargetHttpProxy) ListByFilter(filter TargetHttpProxyFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionGA {
			return false, nil
		}
		return filter(e.key, e.meta, e.obj.(*ga.TargetHttpProxy))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *TargetHttpProxy) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *TargetHttpProxy) FlushByFilter(filter TargetHttpProxyFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// TargetHttpsProxy is a stub for operating on cached objects of this type.
type TargetHttpsProxy struct {
	st *store
}

// TargetHttpsProxyFilterFunc is a filter predicate.
type TargetHttpsProxyFilterFunc func(k Key, m *Metadata, o *ga.TargetHttpsProxy) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *TargetHttpsProxy) Get(k Key, opt Options) (*Metadata, *ga.TargetHttpsProxy, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionGA {
		return e.meta, e.obj.(*ga.TargetHttpsProxy), nil
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *TargetHttpsProxy) Put(k Key, m *Metadata, obj *ga.TargetHttpsProxy) error {
	if !k.Valid("TargetHttpsProxy") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionGA
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *TargetHttpsProxy) List() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.TargetHttpsProxy) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *TargetHttpsProxy) ListByFilter(filter TargetHttpsProxyFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionGA {
			return false, nil
		}
		return filter(e.key, e.meta, e.obj.(*ga.TargetHttpsProxy))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *TargetHttpsProxy) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *TargetHttpsProxy) FlushByFilter(filter TargetHttpsProxyFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// TargetPool is a stub for operating on cached objects of this type.
type TargetPool struct {
	st *store
}

// TargetPoolFilterFunc is a filter predicate.
type TargetPoolFilterFunc func(k Key, m *Metadata, o *ga.TargetPool) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *TargetPool) Get(k Key, opt Options) (*Metadata, *ga.TargetPool, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionGA {
		return e.meta, e.obj.(*ga.TargetPool), nil
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *TargetPool) Put(k Key, m *Metadata, obj *ga.TargetPool) error {
	if !k.Valid("TargetPool") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionGA
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *TargetPool) List() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.TargetPool) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *TargetPool) ListByFilter(filter TargetPoolFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionGA {
			return false, nil
		}
		return filter(e.key, e.meta, e.obj.(*ga.TargetPool))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *TargetPool) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *TargetPool) FlushByFilter(filter TargetPoolFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}

// UrlMap is a stub for operating on cached objects of this type.
type UrlMap struct {
	st *store
}

// UrlMapFilterFunc is a filter predicate.
type UrlMapFilterFunc func(k Key, m *Metadata, o *ga.UrlMap) (bool, error)

// Get the cached object named by Key k. If the API version of the object
// stored does not match the API call, the metadata associated with the object
// will be returned, but NOT the object itself (o will be nil).
//
// If the ConvertVersion option is set, then the object will be automatically
// converted to the appropriate GCE API version even if the object stored is of
// a different version. Note that conversions may be lossy when going from
// alpha to beta to GA API objects. Conversion will be done by the appropriate
// c.from{Alpha,Beta,GA} function.
//
// If a given conversion fails or is not available, then an error will be
// returned.
func (c *UrlMap) Get(k Key, opt Options) (*Metadata, *ga.UrlMap, error) {
	e := c.st.get(k)
	if e == nil {
		return nil, nil, ErrNotFound
	}
	if e.meta.Version == meta.VersionGA {
		return e.meta, e.obj.(*ga.UrlMap), nil
	}
	return e.meta, nil, nil
}

// Put an object into the cache. Ownership of m and obj is transferred to the
// cache.
func (c *UrlMap) Put(k Key, m *Metadata, obj *ga.UrlMap) error {
	if !k.Valid("UrlMap") {
		return ErrInvalidKeyForType
	}
	if obj == nil {
		return fmt.Errorf("cannot Put(%v) with nil obj", k)
	}
	m.Version = meta.VersionGA
	return c.st.put(k, m, obj)
}

// List all of the keys for the given type. This does NOT list object of
// different versions.
func (c *UrlMap) List() ([]Key, error) {
	fn := func(Key, *Metadata, *ga.UrlMap) (bool, error) {
		return true, nil
	}
	return c.ListByFilter(fn, 0)
}

// ListByFilter all of the keys for the given type subject to a filter. By default,
// this will NOT list objects belonging to a different API version.
//
// If ConvertVersion option is set, then the entries for all versions will be
// passed to the filter subject to the conversion described in Get().
//
// If MetadataOnly is set, then the filter function is passed only the key and
// metadata. The obj will be nil. In this case, objects of all versions will be
// enumerated.
func (c *UrlMap) ListByFilter(filter UrlMapFilterFunc, opt Options) ([]Key, error) {
	genericFilter := func(e *entry) (bool, error) {
		if opt.metadataOnly() {
			return filter(e.key, e.meta, nil)
		}
		if !opt.convertVersion() && e.meta.Version != meta.VersionGA {
			return false, nil
		}
		return filter(e.key, e.meta, e.obj.(*ga.UrlMap))
	}
	return c.st.listByFilter(genericFilter)
}

// Flush the object named by key from the cache.
func (c *UrlMap) Flush(k Key) {
	c.st.flush(k)
}

// FlushByFilter objects from the cache that satisfy the filter predicate. See
// ListByFilter() for details on how the filter function works.
func (c *UrlMap) FlushByFilter(filter UrlMapFilterFunc, opt Options) error {
	keys, err := c.ListByFilter(filter, opt)
	if err != nil {
		return err
	}
	for _, k := range keys {
		c.st.flush(k)
	}
	return nil
}
